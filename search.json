[{"title":"google 告警调试符号文件","path":"/2024/05/16/google-告警调试符号文件/","content":"aab 包上传到 google play 时，会出现以下警告：此 App Bundle 包含原生代码，您尚未上传调试符号文件。我们建议您上传调试符号文件，这样会便于针对崩溃和 ANR 问题进行分析和调试。 解决方法：首先需要安装项目对应的 ndk： 1ndkVersion = &quot;20.1.5948944&quot; SDK Tools 记得要开启 Show Package Details，然后下载对应版本的 NDK。Android Studio -&gt; SDK Manager -&gt; SDK Tools -&gt; NDK (Side by side) -&gt; 20.1.5948944 然后在项目的 build.gradle 文件中配置： 1234567891011121314android &#123; //... buildTypes &#123; release &#123; //... minifyEnabled true proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; // 新增配置 ndk &#123; debugSymbolLevel &#x27;FULL&#x27; &#125; &#125; &#125;&#125; debugSymbolLevel 配置为 FULL，表示生成的符号文件包含所有调试信息。 最后，重新打包 aab 包，上传到 google play，即可解决此问题。","tags":["Android","Debugging","Google"],"categories":["React-Native","Android"]},{"title":"MIUI android真机无线调试","path":"/2024/05/11/MIUI-android真机无线调试/","content":"为什么需要无线调试方便无线调试可以让你在手机上进行调试，而不用连接电脑，可以节省时间。 这几天尝试使用无限调试，但是总是会有 bug，adb 死机，手机重启，导致调试失败。 12# 使用 adb 6未数字码方式 连接手机adb pair 192.168.1.100 在 Mac 下，我的手机只能成功连接一次，后续就再也连不上了 无奈，只能使用 Android Studios 调试。 使用 Android Studios 插件：ADB WI-FI USB 连接手机 打开 ADB WI-FI 面板 自动连接 这种方式目前比较稳定，可以成功连接手机，并且可以进行调试，并且每次启动都可以重新成功连接。","tags":["Android","MIUI","Wireless Debugging"],"categories":["Android"]},{"title":"2022总结","path":"/2023/01/08/2022总结/","content":"一年一度的总结时间转眼又是一年了,这三年,一年比一年魔幻. 1 月:深圳开始 24h 核酸 2 月:离职 3 月:回家 … 8 月:进厂.真正意义上的进厂,做 battery pack. … 11 月:乌鲁木齐起火烧死人,引发国内某些地方开始抗议. 12 月:大放开,预计死亡会上百万人.但是目前为止官方的死亡人数还停留在 17 人. 后续会如何发展,这下谁也说不准了.这就是习近平,能猜到他,他就不叫习近平了.做了那么多事,没有一件是成功的,千古留名. 去年的目标 学习公司管理方面的知识:没有时间 学习订单流程:没有时间 去广东主要城市旅游:没有时间,不过去了一次福建漳州,东山岛 &amp; 土楼 学习英语:继续保持 量化基本知识:没有时间 命理学:没有时间 明年预计完成的事情一直都很讨厌进厂.不是因为工资低,工作累,主要的原因是 i don’t have enough free time.真的没有时间去完成自己的事情,每天 8:00 am 上班 9:30 pm 下班,11 个小时花在工厂里,加上晚上还要陪女朋友,真的没有时间.唯一的可能就是,压榨睡眠时间,但是容易猝死. 英语,需要到精通需要学习上万小时,努力吧. 攒钱了,先把婚姻大事搞定. 目前的几本书先看完 陪女朋友出省旅游一次 日语还是慢慢来吧 电池健康管理 感觉奶奶有点老年痴呆了总要走到生死离别的.今年准备买车了,趁有时间多回家陪陪奶奶吧.","categories":["年终总结"]},{"title":"shopify开店Day1","path":"/2022/08/08/shopify开店Day1/","content":"开店第一天 确定了店名，就叫 Edward Store，暂时当个杂货铺吧，后期需要转型的话也方便。 注册域名。 开 Shopify 店铺。 已完成事件 注册域名 注册 shopify 店铺","tags":["shopify"],"categories":["创业"]},{"title":"Mac 无法通过 path 打开 code 记","path":"/2022/07/27/Mac-无法通过-path-打开-code-记/","content":"起因许久未使用mac，然后发现在terminal里使用code &lt;name&gt;的时候，报错了。 12/usr/local/bin/code: line 6: /usr/bin/python: No such file or directory/usr/local/bin/code: line 10: ./MacOS/Electron: No such file or directory 后面才发现，系统里只有python3，没有python，遂在/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code中将python修改为python3得以解决。","tags":["mac","vscode"],"categories":["macOS"]},{"title":"07-26-2022记","path":"/2022/07/26/07-26-2022记/","content":"许久未登，上来看看。发现checkbox不渲染了，于是找了个插件处理了 hexo-renderer-marked 近来股票依旧捉摸不透 事业毫无长进 还在摸索之后的道路","tags":["整理"]},{"title":"04-21-2022记","path":"/2022/04/21/04-21-2022记/","content":"炒股记录还是得看大盘炒股。前几日没卖，导致-17%再现","tags":["整理"]},{"title":"03-31-2022記","path":"/2022/03/31/03-31-2022記/","content":"今日炒股記錄又一次做 T 失敗了。總覺得不會漲到那麼搞，結果又追高了。一直盯盤十分影響心態，不能這樣繼續下去。 之後每天只看尾盤（14:30），其他時間不打開炒股軟件。","tags":["整理"]},{"title":"普京出兵乌克兰","path":"/2022/02/22/普京出兵乌克兰/","content":"出兵了！普京指示俄军方确保顿巴斯地区和平，表示“乌是俄历史上不可分割的一部分”！当地时间 21 日，俄罗斯总统普京在宣布承认顿涅茨克人民共和国和卢甘斯克人民共和国独立后，指示俄罗斯国防部在俄罗斯与顿涅茨克人民共和国和卢甘斯克人民共和国的友好合作互助条约被批准之前，确保俄罗斯武装部队维护顿涅茨克人民共和国和卢甘斯克人民共和国的和平。 据澎湃新闻，当地时间 2 月 21 日，俄罗斯总统普京发表全国电视讲话时表示，乌克兰不仅是邻国还是俄罗斯历史上不可分割的一部分，乌民众是俄方的同志和亲人，是有血缘关系的人。 据悉，联合国安理会将应乌克兰方面请求，于美东时间 21 日晚 9 时（北京时间 22 日上午 10 时）召开紧急会议。本月联合国安理会轮值主席为俄罗斯。 乌克兰地区局势紧张，国际资本市场避险情绪升温，推动股票等权益类资产进一步被抛售，而金价和黄金股均进一步上涨。 继欧洲股市普跌之后，亚太股市也普遍下跌，日经 225 指数开盘跌 1.5%，韩国 Kospi 指数下跌 1.41%。A 股市场今天上午也进一步调整，各大指数均现显著下挫，近 4000 股下跌。港股方面亦在调整，恒生指数盘中大跌超过 3%，截至午盘仍跌 2.95%。 普京要求俄军 维护两个“共和国”的和平 据央视新闻，俄罗斯法律门户网站发布了俄总统普京 21 日签署的承认顿涅茨克人民共和国和卢甘斯克人民共和国的总统令内容。根据总统令，因乌克兰拒绝执行明斯克协议，根据当地人民的意愿，俄罗斯承认两个共和国为独立主权国家。总统令责成俄外交部开始与两国进行建立外交关系的谈判，与俄罗斯其他有关部门起草友好合作互助条约，并按程序完成条约的签署。总统令要求俄罗斯国防部在友好互助条约被批准之前确保俄罗斯武装部队维护顿涅茨克人民共和国和卢甘斯克人民共和国的和平。 当日稍早时，俄罗斯总统普京发表全国视频讲话，宣布承认乌东民间武装自称的顿涅茨克人民共和国和卢甘斯克人民共和国为独立国家。 据环球网援引俄罗斯《观点报》22 日报道称，网上有消息称俄军已开始抵达顿巴斯地区，也有人公布了相关视频。 报道称，国际文传电讯社援引目击者的话说，两个装甲车队已处于“顿涅茨克共和国”并向该其北部和西部前进。 报道还称，乌克兰 OstroV 通讯社援引社交媒体的消息称，“俄军第一批部队正进入”顿巴斯地区。 据央视新闻，俄罗斯国家杜马议员米哈伊尔·谢列梅特当地时间 22 日表示，对于俄罗斯宣布承认乌克兰东部“顿涅茨克人民共和国”与“卢甘斯克人民共和国”独立，西方国家准备对俄罗斯实施新的制裁措施，对此俄罗斯已经做好了一切准备迎接事态发展，俄罗斯不会胆怯。俄罗斯不惧怕西方国家的制裁，我们重视的是人民的生命安全而不是经济。","tags":["history"]},{"title":"中国计划生育协会2022年工作要点","path":"/2022/02/10/中国计划生育协会2022年工作要点/","content":"2022 首个魔幻文件日前，中国计划生育协会官网公布的《中国计划生育协会 2022 年工作要点》（以下简称《工作要点》）提到，2022 年，要实施生殖健康促进行动，重点解决青少年、育龄人群及其他特定人群生殖健康的突出问题，开展未婚人群人工流产干预专项行动，减少青少年意外怀孕和人工流产，提高群众生殖健康水平。在新型婚育文化的建设上，上述《工作要点》称，要以“尊重生育的社会价值，提倡适龄婚育、优生优育，鼓励夫妻共担育儿责任，破除高价彩礼等陈规陋习”为重点，加强对青年婚恋观、家庭观引导，重塑多子女家庭养育文化，淡化教育焦虑，弘扬“孝”、“和”家庭价值观，推动构建积极正向的新型婚育文化。开展新型婚育文化建设项目试点，大力推广新宣传标语口号，倡导将新型婚育文化内容纳入村规民约，修订与中央《决定》精神不一致、不适应的内容。发挥“5.29 会员活动日”宣传品牌、文化社等作用，打造新环境宣传载体，注重运用网络和新媒体等青年群体喜爱的方式，在潜移默化中培育新型婚育观念。","tags":["history"]},{"title":"汤加火山爆发","path":"/2022/01/18/汤加火山爆发/","content":"又一次见证历史了。预计级别会达到VEI6，不知道后续会不会继续喷发。没想到，疫情还未过去，出现了一个比疫情更严峻的现实问题——无夏之年。 更新于 2022 年 7 月 26 日 17:22:50我错了，最近的温度已经到达了 40℃。","tags":["history"]},{"title":"2021总结","path":"/2022/01/08/2021总结/","content":"一年一度的总结时间2021，辛丑年。这一年，似乎发生了许多事；事情太多，以至于能记住的太少了。 教育减负，新东方股价蒸发 90% 房产暴雷，恒大欠债 1.6 万亿 疫情，孕妇流产、心梗无法救治、猝死、…… 是好事吗？是坏事吗？长远来看，民智开化了许多，不再一味地听从党和政府，有了自己的思考。但是，如果一个政府没有了民心支持，那么他还能维持不倒吗？每次变革都是流血，只希望不要起太大的冲突。 去年的目标 加薪：今年无加薪，可能是疫情原因。不过没所谓，已经准备不干了。 独自旅游：去了广州、潮州、汕头等地。 学习炒股：只学习了皮毛，感觉技术分析始终只是判读过去，无法预知未来。需要多了解一下订单流。 学习数学：丝毫未看。 深入技术：深入了解了React源码以及部分Vue源码，虽然不准备干这行了，但是为了留后路还是需要时常补习。 学习色彩与构图：构图算是入了个门，色彩尚未开始。学习，就是需要多看，多实践。纸上得来终觉浅，绝知此事要躬行。 明年预计完成的事情 学习公司管理方面的知识。 学习整个订单流程。短期内应该是需要自己动手，了解之后才知道如何改进。 有机会的话，游遍整个广东的主要城市吧。 英语当然是要坚持打卡的。 学习命理知识。 加一个量化的基本知识吧。 花无重开日，人无再少年。奶奶年纪也大了，每天下班看着地铁内的人，心情极差。思来想去，打工也是一辈子，闯一闯也是一辈子，再者八字暗示会有长辈相助，适合从商，那就搏一搏吧。转行要趁早。同时，不能被利益迷惑了双眼，保持初心。现在公司的老板，初心已经变了。从最开始的打造全国顶尖云存储，到现在的只想噶韭菜，整个人都疑神疑鬼的。还是得学习稻盛和夫的公司管理，一个公司，不仅仅是用于赚钱的工具，更多的，是为那些工人提供避风港。","tags":["整理"],"categories":["年终总结"]},{"title":"《乡土中国》记录","path":"/2021/12/09/《乡土中国》记录/","content":"序言 农业和游牧或工业不同，它是直接取资与土地的。游牧的人飘忽不定，工业可以择地而居。而种地的人却搬不动地。 从农业本身来看，是无需群居的。最小的社区可以只有一户人家。夫妻和孩子聚集，满足两性与抚养的需要。无论在什么性质的社会里，家庭总是最基本的抚养社群。 中国农民聚集而居原因： 耕地面积小，小农经营。住所与耕地不会相隔太远 需要水利，所以大家一起合作。 合作弊害。 土地继承。 农村属于 face to face group，所以 文字 在农村并没有太大意义。 社会学中通常两种不同性质的社会： 共同体：没有主要的目的聚集。 社会：有主要的目的聚集。 孝是什么，孔子并没有抽象地加以说明。最后归结到“心安”二字。做子女的在日常接触中熟悉父母的性格，然后承他们的欢，做到心安。 文字下乡大家口中的愚，并不是觉得农村人不聪明，只是因为农村人不识字。主要的原因还是在于农村环境下，接触到文字的地方很少。但是并不代表农村人学习能力差。 不善用文字 -&gt; 学习机会少 -&gt; 文盲 乡下孩子不像教授们的孩子到处看见书籍，到处接触字。 并不见得他们的孩子有什么善于辨字的能力，显而易见的是他们有易于识字的环境。 文字，一种双方约定好代表一种意义的记号。文字所能表达的情感有限，所以需要使用文法，还原意境。 由于文字是用于双方交流，所以不能有个人的语言，只能有社会的语言。要让大多数人能对同一象征具有同一意义，他们必须有相同的经历（文化沉淀）。 在每个特殊的生活团体中，必有他们特色的语言，其他语言无法翻译。 群体愈大，人群的经验愈复杂，发生语言的共同基础也必愈有限，于是语言会趋于简单化（文言文 -&gt; 繁体 -&gt; 简体（同化））。在社群使用的通用语言之外，必然会产生一些少数人使用的语言（行话）。行话是同行人中的话，外行人因为没有经验，无法理解。 最普遍的特殊语言发生在母亲和孩子之间。 在亲密社群中可用来做象征体系的原料比较多。表情、动作，在面对面的情境中，有时比声音更容易传情达意。 再论文字下乡 文字是发生在人和人传情达意的过程中受到了空间和时间的阻隔的情境里。 时间上的隔阂： 今夕之隔 社会的世代之隔 小白鼠并不向其他老鼠学习，每只老鼠都在自己的具体情境里，从“试验”中得到个别的经验。他们并不能相互传递经验，相互学习。 文化：社会世代共同的经验累积。 大多数记忆，是由于当前的需要，而追忆过去。记忆并非无所为的，而是实用的，为了生活。乡土社会是一个很安定的社会，在一个地方出生，就在这个地方生长直到死。 极端的乡土社会是老子的理想社会，“鸡犬相闻，老死不相往来” 由于乡土社会安定，所以社会积累的经验永远不会更新。经验无需积累，只需保存。语言在这种社会里，算是可以传递世代的经验。 大家在同一环境里，你先走，他后走，靠的是口口相传，哪里需要文字。 中国是乡土社会，为什么会产生文字呢？ 中国社会从基层上看是乡土性，但是文字并不是从基层上发生。在乡土社会，面对面的接触中，并不是愚昧到字都不认识，而是文字没有帮助他们生活的必要。 差序格局 中国人可以为了自己牺牲家，可以为了家牺牲族。只要一件物品是公家的，意味着可以“不负责”。 家庭在西方是界限分明的团体，一般只由父母、孩子组成。中国人的家，可以大到一片地方都属于自己家，也可以小到自己就是自己家。 家族，地缘关系的体现。不是一个固定的团体，而是一个范围。有势力的人家的街坊可以遍及全村，穷苦人家的街坊只是比邻的两三家。 西方社会里争的是权力，而中国社会却多的是攀关系、讲交情。西方社会的团体是按照资格划分：有资格的进入群体，没资格的自动脱离群体。 个人主义：基于团体的概念，个人是团体的一份子。 自我主义：以自我为中心。 在传统的社会结构里最基本的概念，人来人往所构成的网格中的纲纪，就是一个差序，也就是伦。《礼记》大传里说：“亲亲也，尊尊也，长长也，男女有别，此其不可得与民变革者也”。社会的架构是不变的，变得只是利用这架构做的事情。 在差序格局中，社会关系是通过一个个人推出去的，是私人关系的增加，社会范围是一根根私人联系所构成的网格。社会道德在私人关系中才有意义，所以现代社会需要法律来进行约束。 在差序格局里，公和私是相对而言的，站在任何一圈里，在外看是私，在内看就成了公。 维系着私人关系的道德 中国人的道德和法律，具有伸缩性，要看对象和子的关系而定。在一个安居的乡土社会，每个人可以在土地上自食其力地生活时，只在偶然和临时的非常状态中才感觉到伙伴的需要。和别人的关系是次要的，而且在不同场合下需要不同的结合，并不需要一个经常性的团体，因此社会采用了“差序格局”。道德是社会对个人行为的执行力。 执行团体的意志时，需要代理者（例如：牧师、发言人、算命先生）。团体不能为任何个人所有。如果代理者违反了这些“不证自明的真理”，代理者就失去了代理的资格。为了防止代理者滥用权力，所以发生了宪法。 宪法观念是和西洋公务观念相配合的。国家可以要求人民服务，但是国家也得保证不侵害人民的权力，在公道和爱护的范围内行使权力。 但是在中国这种差序格局中，不容易找到个人对团体的道德因素。在西洋团体格局的社会中，公务、履行义务是一个清除明白的行为规范。孝悌忠信，都是私的关系。道德仅存于私人关系之间。 家族在西方，家是团体性社群，夫妇是主轴，经营的事务很少，主要是生儿育女。但在中国的乡土社会里，“家”在结构上俨然是一个氏族，根据单系（父亲）亲属原则所组成的社群，且构成的分子不仅限于亲子关系，因而具有生育和事业的双重功能。 家庭（Family）：西方观念，由亲子（双系，父母双方）构成的生育社群。主要是为了生育。孩子成长之后，脱离父母抚育，去成立新的家庭。所以“家庭”是暂时性的，抚养孩子的目的就在于抚养结束。 家族（Extended Family）：乡土社会中的基本社群，具有生育之外的功能，夫妻之间的合作不因停止抚育孩子而停止，是长期的稳定的合作。 大家庭：结构复杂（父母、子女、婿、媳、堂、表等组成），不按数量区分。 小家庭：结构简单。 中国家族的扩大是单系的：大部分的家并不能同时包括儿媳和女婿。在父系原则下，女婿和结了婚的女儿都是外家人。在社会学里，单系亲属组成的叫做“氏族”，但是氏族是由许多家族组成，所以中国的家族，实际上是“小氏族”，结构原则上一样。 人类学上的说法，氏族是一个事业组织，再扩大就可以成为部落。具有政治、经济、宗教等复杂功能。中国乡土社会采取差序格局，利用亲属的伦常去结合社群，经营各种事业，把基本的家变成了氏族性。 在乡土社会中，家是个连续性的事业社群，他的主轴是父子之间，婆媳之间，是纵的。夫妻之间，异性之间，属于副轴。一切事业都不能脱离高效率，高效率就得有纪律，就不能有私情。所以夫妻之间“相敬如宾”，女子“三从四德”，亲子间讲究负责和服从，都是事业性社群的特点。夫妻俩各自之间有各自的工作，属于合作关系，感情占比不大。同时同性和同性之间联系比较多，性别和年龄组之间保持着很大距离，这是将生育之外的功能拉入这社群之后的结果。 男女有别从社会关系上来说，感情是具有破环和创造作用的。感情的激动改变了原有的关系。如果要维持固定的社会关系，就得避免感情的激动。 两种文化模式： 阿波罗（Apollonian）：宇宙有一个完善的秩序，人只是去接受它。 浮士德（Faustian）：冲突是存在的基础。文化就是无尽创造的过程，不断改变。 乡土社会是阿波罗式的，现代社会是浮士德式的。 乡土社会靠亲密和长期的共同生活来相互配合，社会是熟习的，每个人对彼此都足够了解。完全的道义必须有充分的了解，无所隔，但是由于两性关系，性别的鸿沟是基本的阻碍。所以乡土社会选择对性进行抹杀。浮士德是感情的象征，把感情的激动，不断地变化，作为生命的主脉。 在乡土社会，不需要创造新的社会关系，社会关系是生下来就决定的。社会结构多的是同性之间的组合。家庭受到同性组合的影响，不易维护，于是家族代替了家庭，成了以同性为主、异性为辅的单系组合。乡土社会是个男女有别的社会，也是一个安稳的社会。 礼治秩序乡土社会属于无政府社会，一种不需要规律的秩序，自动的秩序，无治而治。礼制社会并不一定是君子国，并没有文明的意思，礼制也可以很野蛮。礼是社会公认合式的行为规范。法则是由国家权力执行的规章制度。在乡土社会中传统效力更大。但是在一个变化快的社会，传统的效力是无法保证的，礼制社会是不能在变迁快的时代出现的。所以当现代社会的法进入乡土社会后，破坏了他们的礼，甚至认为律师是帮着法说话的坏人。 无讼法律属于专业知识，所以在都市中存在律师、法律顾问等职位。但在乡土社会里，不懂礼就成了坏人。打官司，必然是有人破坏了传统规矩，父母官应该做的是教化，而不是折狱。 理想的礼治是每个人都自动的遵守规矩，不必有外在的监督。社会假定每个人是知礼的，至少社会有责任使每个人知礼，这也是乡土社会中通行连坐的证据。 与礼不同的是，法不考虑伦理问题，只保护应有的权力不受侵犯。所以在不同的场合下，往往有不同的判决方法，导致无法沉淀。 在差序格局中，不认为具有一套人人通用的法。所以现行的司法制度在乡间发生了很特殊的副作用，它破坏了原有的礼治秩序，但并不能有效的建立起法制秩序。 无为政治权力： 社会冲突来看（横暴权力）：权力是冲突的持续，性质还在，但被支配的一方认输，属于压迫性质。 社会合作来看（同意权力）：干涉别人是权力，被别人干涉是义务，权力的基础是同意制度。 权力之所以诱人，最主要的应当是经济利益。在同意权力下，有权利者并不是为了保障自己的特殊权益，所以必须用荣誉和高薪来延揽。但在横暴权力下，统治者要用暴力来维持他们的地位，维护自己的利益。 一个只生产他生存必需品的人是没有资格做奴隶的。在农业民族的斗争中，最主要的方式就是把土著赶走而占据他们的土地自己来耕种。 和平发展 -&gt; 积累力量 -&gt; 扩大势力 -&gt; 民不聊生 -&gt; 内乱 -&gt; 伤亡惨重 -&gt; 和平发展 乡土社会可以自给自足，是同意权力扩大的阻碍。所以皇帝长远来看，是无为的。 长老统治中国除了横暴权力、同意权力，还存在一种教化性的权力。 在被教化的古城镇并不发生这个问题，被教化者并没有选择的机会。文化，是先他而存在的。 血缘和地缘年长对年幼有强制的权利，这是血缘社会的基础。血缘的意思是人和人的权利和义务根据亲属关系决定。职业、财富、地位都存在继承。生育没有社会化之前，血缘作用的强弱是以社会变迁的速率决定。 血缘是稳定的力量。血缘是先人而存在的，地缘是血缘的投影 一个地方的人口发展到一定的规模，就不得不去另寻住处。但不论怎么发展，与最开始都保持着地缘关系，即使后来成为了其他乡的人。 在亲密的血缘社会中商业是无法存在的。他们之间的交易是以人情来维持的，是相互馈赠的方式。外乡客成了商业的媒介，商业是在血缘之外发展的。 所以大家会聚集在集市贸易，抛开彼此的血缘、地缘关系。 地缘是从商业里发展出来的社会关系。血缘是身份社会的基础，地缘是契约社会的基础。 名实的分离社会变迁快，长老权利小；社会变迁慢，长老权利大。社会结构自身也存在变迁。由旧结构到新结构之间，会出现时势权利（苏联：形式上是独裁的，但是从苏联人民的立场来看，苏联的独裁和沙皇的独裁并不一样）。 长老权利是建立在教化作用之上的，教化是有知对无知，如果所传递的文化是有效的，被教的自然没有反对的必要。在横暴权利下，没有反对，只有反抗。在时势权利中，反对是发生于对同一种问题不同的答案上。 面子就是表面的无违，名实之间的距离随着社会变迁速率增加。 从欲望到需要 乡土社会，欲望驱动。 现代社会，需要驱动。 欲望 -&gt; 紧张 -&gt; 动作 -&gt; 满足 -&gt; 愉快，那是人类的行为过程。欲望如果要通过意志对行为有所控制，它必须是行为者所自觉的。 人类现有行为，后有思想。决定行为的是从试验与错误的公式中累计出来的经验，思想只有保留这些经验的作用，自觉的欲望是文化的命令。社会变迁快，文化无法满足于生活，逐渐重视起功能，从欲望到了需要。 在现代社会里只是即是权利，因为在这种社会里生活的人要依他们的需要做计划。从知识中得来的权利是时势权利。乡土社会是靠经验的，他们不必计划，因为在积累的过程中，自然替他们选择出了一个足以依赖的传统生活方案，各人遵照执行即可。","tags":["记录"]},{"title":"阿米巴经营记录","path":"/2021/12/08/阿米巴经营记录/","content":"日航哲学 – 成功方程式 人生 · 工作的结果 &#x3D; 思维方式 _ 努力 _ 能力 作为人，何谓正确 领导人率先垂范，以身作则。 阿米巴系统京瓷的经营理念： 在追求全体员工物质和精神两方面幸福的同时，为人类社会的进步发展做出贡献。 阿米巴经营是通过一个个小集体的独立核算来实现全员参与经营、凝聚全体员工力量和智慧的经营管理系统。 但是在 乌合之众 中说到，群体聚集在一起的智商，只会降低。所以是否可以利用群体的力量，独立的领导人（智慧&amp;方向），达到目的。 阿米巴经营的目的 确立与市场挂钩的分部门核算制度 培养具有经营意识的人才 实现全员参与的经营 创业初期部门结构 核心技术在研发 传统公司经营模式 如果市场价格波动，销售的售价必然下降。此时，如果减少销量，会增加库存。增加销量，成本增高，总利润下降。 此时拆分成阿米巴之后，生产和销售之间必然会产生分歧。此时直接损害生产部的利益，所以传统经营模式在阿米巴经营中并不适用。 细分阿米巴的三个条件 能够独立核算的单位 独立完成某个业务的单位 划分组织必须有利于实现公司的方针和目标","tags":["记录"]},{"title":"Windows VL 激活","path":"/2021/11/12/Windows-VL-激活/","content":"激活 Windows 查看 OS 版本： run.exe: slmgr.vbs -dlv，查看产品密钥通道。 OEM：出厂版本 Retail：零售版本 VL(Vol)：批量激活版本 只有 VL 版本可以激活。 使用 cmd：slmgr /skms kms.03k.org，把skms地址设置为 kms.03k.org slmgr /ato，手动激活 激活 OfficeOffice 必须是 VL 版本 进入 Office 安装地址，找到 OSPP.VBS cmd：cscript ospp.vbs /sethst:kms.03k.org，指定kms服务地址 cscript ospp.vbs /act，手动激活 工具网站：office tool plus","tags":["整理"]},{"title":"10/31/2021 记","path":"/2021/10/31/10-31-2021-记/","content":"晚上睡不着。看了一眼 HuoBi发现自己的合约被强制平仓了。陆续开始清退大陆用户。 也就几百块，取出来也没多大作用。 看了看最近的风口 Meta verse，买了点币。顺便跟着孙割买了点币。 15 个 MANA: 基于 VR 的游戏平台 9600 个 BTT: Bit torrent 之后 HuoBi 清退，还需要把币提出来。麻烦 周一看看能不能把股市内的基金投入到 恒生30ETF恒生ETF中很大一部分是 Meta Verse 概念。股市还是太难玩了。玩不明白。","tags":["记录"]},{"title":"Vue中对Array拓展的方法","path":"/2021/10/14/Vue中对Array拓展的方法/","content":"原理通过改写[].__proto__上的方法，实现对Array原生方法的拦截。 源码位置为 /core/instance/observer/array.js 123456789101112131415161718192021222324252627282930313233343536// cache the original Array.prototypeconst originalPrototype = Array.prototype// create an object from original Array.prototypeconst arrayMethods = Object.create(originalPrototype)const methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;,]methodsToPatch.forEach((method) =&gt; &#123; arrayMethods[method] = function (...args) &#123; // use original Array methods to get the result const result = originalPrototype[method].apply(this, args) // proxy here console.log(`catch $&#123;method&#125;`) return result &#125;&#125;)const a = [1, 2, 3]a.__proto__ = arrayMethodsa.push(1)a.reverse()a.pop()console.log(a)","tags":["学习"]},{"title":"Promise a+","path":"/2021/10/08/Promise-a/","content":"Promise A+ 规范 promise：是一个拥有then方法的对象或函数，其行为符合本规范。 thenable：是一个定义了then方法的对象或函数。这个主要是用来兼容一些老的Promise实现，只要一个Promise实现是thenable，也就是拥有then方法的，就可以跟Promises/A+兼容。 value：指reslove出来的值，可以是任何合法的 JS 值(包括 undefined , thenable 和 promise等) exception：异常，在Promise里面用throw抛出来的值 reason：拒绝原因，是reject里面传的参数，表示reject的原因 Promise Status pending: 一个promise在resolve或者reject前就处于这个状态。 fulfilled: 一个promise被resolve后就处于fulfilled状态，这个状态不能再改变，而且必须拥有一个不可变的值(value)。 rejected: 一个promise被reject后就处于rejected状态，这个状态也不能再改变，而且必须拥有一个不可变的拒绝原因(reason)。 thenable1promsie.then(onFulfilled, onRejected) Optional parameters 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 onFulfilled如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值value 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因reason 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 thenthen 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 Returnthen 方法必须返回一个 promise 对象。 1promise2 = promise1.then(onFulfilled, onRejected) 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320var PENDING = &#x27;pending&#x27;var FULFILLED = &#x27;fulfilled&#x27;var REJECTED = &#x27;rejected&#x27;function Promise(fn) &#123; this.status = PENDING // initial status this.value = null // initial value this.reason = null // initial reason this.onFulfilledCallbacks = [] this.onRejectedCallbacks = [] var _this = this function resolve(value) &#123; if (_this.status === PENDING) &#123; _this.status = FULFILLED _this.value = value _this.onFulfilledCallbacks.forEach((i) =&gt; i(_this.value)) &#125; &#125; function reject(reason) &#123; if (_this.status === PENDING) &#123; _this.status = REJECTED _this.reason = reason _this.onRejectedCallbacks.forEach((i) =&gt; i(_this.reason)) &#125; &#125; try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;function resolvePromise(promise, x, resolve, reject) &#123; if (promise === x) &#123; reject(new TypeError(&#x27;The promise and the return value are the same&#x27;)) &#125; if (x instanceof Promise) &#123; x.then(function (y) &#123; resolvePromise(promise, y, resolve, reject) &#125;, reject) &#125; else if (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; if (x === null) &#123; return resolve(x) &#125; try &#123; var then = x.then &#125; catch (e) &#123; return reject(e) &#125; if (typeof then === &#x27;function&#x27;) &#123; var called = false try &#123; then.call( x, function (y) &#123; if (called) return called = true resolvePromise(promise, y, resolve, reject) &#125;, function (r) &#123; if (called) return called = true reject(r) &#125;, ) &#125; catch (e) &#123; if (called) return reject(e) &#125; &#125; else &#123; resolve(x) &#125; &#125; else &#123; resolve(x) &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; var checkOnFulfilled = onFulfilled if (typeof onFulfilled !== &#x27;function&#x27;) &#123; checkOnFulfilled = function (value) &#123; return value &#125; &#125; var checkOnRejected = onRejected if (typeof onRejected !== &#x27;function&#x27;) &#123; checkOnRejected = function (reason) &#123; throw reason &#125; &#125; var _this = this if (this.status === FULFILLED) &#123; // 如果前面的 promise 抛出异常，后面的必须拒绝执行 var promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; if (typeof onFulfilled !== &#x27;function&#x27;) &#123; resolve(_this.value) &#125; else &#123; var x = checkOnFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) return promise2 &#125; if (this.status === REJECTED) &#123; var promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; if (typeof onRejected !== &#x27;function&#x27;) &#123; reject(_this.reason) &#125; else &#123; var x = checkOnRejected(_this.reason) resolvePromise(promise2, x, resolve, reject) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) return promise2 &#125; if (this.status === PENDING) &#123; var promise2 = new Promise(function (resolve, reject) &#123; _this.onFulfilledCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; if (typeof onFulfilled !== &#x27;function&#x27;) &#123; resolve(_this.value) &#125; else &#123; var x = checkOnFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) _this.onRejectedCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; if (typeof onRejected !== &#x27;function&#x27;) &#123; reject(_this.reason) &#125; else &#123; var x = checkOnRejected(_this.reason) resolvePromise(promise2, x, resolve, reject) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125;) return promise2 &#125;&#125;Promise.resolve = function (parameter) &#123; if (parameter instanceof Promise) &#123; return parameter &#125; return new Promise(function (resolve) &#123; resolve(parameter) &#125;)&#125;Promise.reject = function (reason) &#123; return new Promise(function (resolve, reject) &#123; reject(reason) &#125;)&#125;Promise.all = function (promises) &#123; return new Promise(function (resolve, reject) &#123; var count = 0 var result = [] var len = promises.length if (length === 0) &#123; return resolve(result) &#125; promises.forEach(function (promise, index) &#123; Promise.resolve(promise).then( function (value) &#123; count++ result[index] = value if (count === len) &#123; resolve(result) &#125; &#125;, function (reason) &#123; reject(reason) &#125;, ) &#125;) &#125;)&#125;Promise.race = function (promises) &#123; return new Promise(function (resolve, reject) &#123; var len = promises.length if (length === 0) &#123; return resolve() &#125; else &#123; for (var i = 0; i &lt; len; i++) &#123; Promise.resolve(promises[i]).then( function (value) &#123; return resolve(value) &#125;, function (reason) &#123; return reject(reason) &#125;, ) &#125; &#125; &#125;)&#125;Promise.catch = function (onRejected) &#123; this.then(null, onRejected)&#125;Promise.finally = function (fn) &#123; return this.then( function (value) &#123; return Promise.resolve(fn()).then(function () &#123; return value &#125;) &#125;, function (error) &#123; return Promise.resolve(fn()).then(function () &#123; throw error &#125;) &#125;, )&#125;Promise.allSettled = function (promises) &#123; return new Promise(function (resolve) &#123; var len = promises.length var result = [] var count = 0 if (len === 0) &#123; resolve(result) &#125; else &#123; for (let i = 0; i &lt; len; i++) &#123; ;(function (i) &#123; var current = Promise.resolve(promises[i]) current.then( function (value) &#123; count++ result[i] = &#123; status: &#x27;fulfilled&#x27;, value, &#125; if (count === len) &#123; return resolve(result) &#125; &#125;, function (reason) &#123; count++ result[i] = &#123; status: &#x27;rejected&#x27;, reason, &#125; if (count === len) &#123; return resolve(result) &#125; &#125;, ) &#125;)(i) &#125; &#125; &#125;)&#125;// for promises-aplus-tests testPromise.deferred = function () &#123; var result = &#123;&#125; result.promise = new Promise(function (resolve, reject) &#123; result.resolve = resolve result.reject = reject &#125;) return result&#125;module.exports = Promise","tags":["记录","Promise A+"],"categories":["JavaScript"]},{"title":"通用中心路由基座式微前端实现","path":"/2021/09/13/通用中心路由基座式微前端实现/","content":"什么是微前端微前端架构具备以下几个核心价值 技术栈无关：主框架不限制接入应用的技术栈，子应用具备完全自主权 独立开发、独立部署：子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新 独立运行时：每个子应用之间状态隔离，运行时状态不共享 现有解决方案 路由分发（nginx） npm 子包：基座负责打包构建发布，打包时集成； iframe：应用之间完全独立；需要基座提供通信方案； 通用中心路由基座式：完全独立；需要基座提供通信方案；使用 DOM 实现；（阿里乾坤） 特定中心路由基座式：相同技术栈；复用基座公共基建内容；（美团广告业务） 方案对比 方案 技术栈是否能统一 单独打包 单独部署 打包部署速度 单页应用体验 子工程切换速度 工程间通信难度 现有工程侵入性 学习成本 NPM 式 是（不强制） 否 否 慢 是 快 正常 高 高 iframe 式 是（不强制） 是 是 正常 否 慢 高 高 低 通用中心路由基座式 是（不强制） 是 是 正常 是 慢 高 高 高 特定中心路由基座式 是（强制） 是 是 快 是 快 正常 低 低 通用中心路由基座式实现应用架构123456graph TBApp[App]App --&gt; App1[App1]App --&gt; App2[App2]App --&gt; App3[App3]App --&gt; App4[...] 实现方案1234567891011graph LRStart(Start)Start --&gt; Route(/subapp/xxx/index)Route --&gt; Match(根路由匹配到 /subapp)Match --&gt; DoubleMatch&#123;二级路由xxx匹配到子路由注册信息&#125;DoubleMatch --&gt; | 匹配失败 | MatchError(失败处理) --&gt; End(End)DoubleMatch --&gt; | 匹配成功 | IsLoaded&#123;检查是否已经加载&#125;IsLoaded --&gt; | 是 | Loaded(直接获取模块) --&gt; EndIsLoaded --&gt; | 否 | LoadJs&#123;异步获取JS&#125;LoadJs --&gt; | 失败 | MatchJsError(失败处理) --&gt; EndLoadJs --&gt; | 成功 | MatchSuccess(获取子工程模块) --&gt; LoadPage(显示子工程页面) --&gt; End 核心流程1、注册子应用12graph LRStart(Start) --&gt; GetList[拿到子应用列表] --&gt; Init[将子应用初始状态设置为 NOT_LOADED] --&gt; GlobalHook(设置全局生命周期) --&gt; End(End) 2、运行12graph LRStart(Start) --&gt; Hijack[Hijack Route] --&gt; Reroute[ReRoute] --&gt; LoadOther(对其他子应用进行资源预加载) --&gt; End(End) 3、页面路由切换12graph LRStart(Start) --&gt; ReRoute --&gt; End(end) 核心代码逻辑1、Hijack Route 设置全局变量 HistoryEvent 重写 pushState 方法，每次调用之后生成一个 PopStateEvent，赋值给 HistoryEvent 重写 replaceState 方法，每次调用之后生成一个 PopStateEvent ，赋值给 HistoryEvent 监听 hashChange ，调用 reroute 监听 popstate，调用reroute 对addEventListener和removeEventListener注入，对hashChange和popstate进行拦截 2、ReRoute actives：所有处于 active 状态的子应用列表 unmounted：所有处于 unmount 状态的子应用列表 1234567graph LRStart(Start) --&gt; IfUrl&#123;url !== lastUrl&#125;IfUrl --&gt; | false | End(End)IfUrl --&gt; | true | AppList[拿到app的状态列表]AppList --&gt; | unmount | UnMount --&gt; Finish[Finish]AppList --&gt; | active | BeforeLoad --&gt; Assets --&gt; Mounted --&gt; FinishFinish --&gt; OpenListener[启动监听] --&gt; End 生命周期函数1、beforeLoad12graph LRStart --&gt; Loading[set app state to LOADING] --&gt; GlobalHook --&gt; LoadHTML --&gt; Loaded[set app state to LOADED] --&gt; End LoadHTML： 12graph LRStart --&gt; Init[get container ant entry] --&gt; Dom[get dom node] --&gt; parseHTML --&gt; CSS[get external css] --&gt; JS[get external js] --&gt; RunCode --&gt; Return[return application] 2、Assets1234graph LRStart --&gt; IsLoaded&#123;&quot;status === LOADED&quot;&#125;IsLoaded --&gt; | false | EndIsLoaded --&gt; | true | Assets[set app state to ASSETS_LOADING] --&gt; RunApp[run app.assets] --&gt; NotMounted[set app state to NOT_MOUNTED] --&gt; End 3、Mounted12graph LRStart --&gt; Mounting[set app state to MOUNTING] --&gt; RunApp[run app.mounted] --&gt; GloalHook --&gt; Mounted[set app state to MOUNTED] --&gt; End 4、UnMounted12graph LRStart --&gt; UnMounting[set app state to UNMOUNTING] --&gt; RunApp[run app.unmount] --&gt; GlobalHook --&gt; NotMounted[set app state to NOT_MOUNTED] --&gt; End","tags":["学习"]},{"title":"module导入script方式","path":"/2021/07/19/module导入script方式/","content":"type=&quot;module&quot;1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;module&quot;&gt; // will not block the button console.log(this) // undefined console.log(import.meta.url) // the url of import file &lt;/script&gt; &lt;script&gt; // will block the button console.log(this) // window &lt;/script&gt; &lt;script async type=&quot;module&quot; src=&quot;http://example.com/test.js&quot;&gt; // will run immediate when the file is load // example.com needs the Access-Control-Allow-Origin flag import &#123;sayHi&#125; from &#x27;sayHi&#x27; // this will get error because no path import in this module block. &lt;/script&gt; &lt;script nomodule&gt; alert(&#x27;The Browser can not support the module import.&#x27;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Button&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","tags":["学习","module"],"categories":["JavaScript"]},{"title":"React Reconciler Diff Example","path":"/2021/07/19/react-reconciler-diff/","content":"before: abcd after: acdb &#x3D;&#x3D;&#x3D;第一轮遍历开始&#x3D;&#x3D;&#x3D;a（之后）vs a（之前）key 不变，可复用此时 a 对应的 oldFiber（之前的 a）在之前的数组（abcd）中索引为 0所以 lastPlacedIndex = 0; 继续第一轮遍历… c（之后）vs b（之前）key 改变，不能复用，跳出第一轮遍历此时 lastPlacedIndex === 0;&#x3D;&#x3D;&#x3D;第一轮遍历结束&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;第二轮遍历开始&#x3D;&#x3D;&#x3D;newChildren === cdb，没用完，不需要执行删除旧节点oldFiber === bcd，没用完，不需要执行插入新节点 将剩余 oldFiber（bcd）保存为 map &#x2F;&#x2F; 当前 oldFiber：bcd&#x2F;&#x2F; 当前 newChildren：cdb 继续遍历剩余 newChildren key === c 在 oldFiber 中存在const oldIndex = c（之前）.index;此时 oldIndex === 2; &#x2F;&#x2F; 之前节点为 abcd，所以 c.index &#x3D;&#x3D;&#x3D; 2比较 oldIndex 与 lastPlacedIndex; 如果 oldIndex &gt;= lastPlacedIndex 代表该可复用节点不需要移动并将 lastPlacedIndex = oldIndex;如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动 在例子中，oldIndex 2 &gt; lastPlacedIndex 0，则 lastPlacedIndex = 2;c 节点位置不变 继续遍历剩余 newChildren &#x2F;&#x2F; 当前 oldFiber：bd&#x2F;&#x2F; 当前 newChildren：db key === d 在 oldFiber 中存在const oldIndex = d（之前）.index;oldIndex 3 &gt; lastPlacedIndex 2 &#x2F;&#x2F; 之前节点为 abcd，所以 d.index &#x3D;&#x3D;&#x3D; 3则 lastPlacedIndex = 3;d 节点位置不变 继续遍历剩余 newChildren &#x2F;&#x2F; 当前 oldFiber：b&#x2F;&#x2F; 当前 newChildren：b key === b 在 oldFiber 中存在const oldIndex = b（之前）.index;oldIndex 1 &lt; lastPlacedIndex 3 &#x2F;&#x2F; 之前节点为 abcd，所以 b.index &#x3D;&#x3D;&#x3D; 1则 b 节点需要向右移动&#x3D;&#x3D;&#x3D;第二轮遍历结束&#x3D;&#x3D;&#x3D; 最终 acd 3 个节点都没有移动，b 节点被标记为移动","tags":["学习","React","React Reconciler"],"categories":["React"]},{"title":"JSDoc remark","path":"/2021/07/13/JSDoc-remark/","content":"Class in ES2015123456789101112131415161718192021222324/** * Class representing a point. */class Point &#123; /** * Create a point. * @param &#123;number&#125; x - The x value. * @param &#123;number&#125; y - The y value. */ constructor(x, y) &#123;&#125; /** * Get the x value. * @return &#123;number&#125; The x value. */ getX() &#123;&#125; /** * Convert a string containing two comma-separated number into a point. * @param &#123;string&#125; str - The string containing two comma-separated number. * @return &#123;Point&#125; A point object. */ static fromStringStr(str) &#123;&#125;&#125; extends123456789101112131415161718192021/** * Class representing a point. * @extends Point */class Dot extends Point &#123; /** * Create a dot. * @param &#123;number&#125; x - The x value. * @param &#123;number&#125; y - The y value. * @param &#123;number&#125; width - The width of the dot. */ constructor(x, y, width) &#123; super(x, y) &#125; /** * Get the width of the dot. * @return &#123;number&#125; The dot&#x27;s width. */ getWidth() &#123;&#125;&#125; @abstract1234567891011121314151617181920212223242526272829/** * Foo. * @constructor */function Foo() &#123;&#125;/** * Check if is solid. * @abstract * @return &#123;boolean&#125; */Foo.prototype.isSolid = function () &#123; throw new Error(&#x27;Must be implemented by suclass.&#x27;)&#125;/** * Bar. * @constructor * @arguments Foo */function Bar() &#123;&#125;/** * Check if is solid. * @return &#123;boolean&#125; Always return false. */Bar.prototype.isSolid = function () &#123; return false&#125; @assets12345678910111213141516171819202122232425262728/** * @constructor */function Foo() &#123; /** * @assets private * @type &#123;number&#125; */ let foo = 0 /** * @assets protected * @type &#123;string&#125; */ this.bar = &#x27;1&#x27; /** * @assets package * @type &#123;string&#125; */ this.barz = &#x27;2&#x27; /** * @assets public * @type &#123;string&#125; */ this.barm = &#x27;3&#x27;&#125; @author1234/** * @author Edward &lt;wang.huiyang@outlook.com&gt; */function MyClass() &#123;&#125; @callback1234567891011121314151617/** * @class */function Foo() &#123;&#125;/** * Send a request. * @param &#123;requestCallback&#125; cb - The callback than handles the response. */Foo.prototype.send = function (cb) &#123;&#125;/** * Callback * @callback requestCallback * @param &#123;number&#125; responseCode * @param &#123;string&#125; responseMessage */ @event1234567891011121314151617/** * @constructor */function Foo() &#123;&#125;/** * Do some test. * @fires Foo#test */Foo.prototype.test = function () &#123;&#125;/** * Foo test. * @event Foo#test * @type &#123;object&#125; * @property &#123;boolean&#125; isPass - Check if is pass. */","tags":["JavaScript","JSDoc"],"categories":["JavaScript"]},{"title":"ES6 Class","path":"/2021/07/02/ES6-Class/","content":"Class1234567891011// class factoryfunction classFactory(phone) &#123; return class &#123; getName() &#123; return phone &#125; &#125;&#125;let _187 = classFactory(&#x27;18720128815&#x27;)console.log(new _187().getName()) Calculated attribute name1234567class User &#123; [&#x27;say&#x27; + &#x27;Hi&#x27;]() &#123; console.log(&#x27;hi&#x27;) &#125;&#125;new User()[&#x27;sayHi&#x27;] Class field12345678// class fieldclass User &#123; name = &#x27;Edward&#x27; // is not at the prototype&#125;const user = new User()console.log(user.name) // Edwardconsole.log(User.prototype.name) // undefined Extends — How the super run12345678910111213141516171819202122232425262728293031let animal = &#123; name: &#x27;Animal&#x27;, eat() &#123; console.log(this.name + &#x27; eat&#x27;) &#125;,&#125;let rabbit = &#123; __proto__: animal, // extends animal eat() &#123; super.eat() &#125;,&#125;let err = &#123; __proto__: rabbit, // extends rabbit name: &#x27;err obj&#x27;, eat() &#123; super.eat() &#125;,&#125;// super.eat() -&gt; [[Rabbit.prototype]].eat// -&gt; super.eat -&gt; [[Animal.prototype]].eat// this -&gt; errerr.eat()class Animal &#123;&#125;class Rabbit extends Animal &#123;&#125;console.log(Rabbit.__proto__ === Animal) // class extends linkconsole.log(Rabbit.prototype.__proto__ === Animal.prototype) // prototype extends link Prototypechange the basic class 12345678910111213141516let user = &#123; name: &#x27;Edward&#x27;, hello(name) &#123; console.log(`hi $&#123;this.name&#125;, this is $&#123;name&#125;`) &#125;,&#125;Function.prototype.defer = function (ms) &#123; let f = this return function (...arg) &#123; setTimeout(() =&gt; f.apply(this, arg), ms) &#125;&#125;user.hello = user.hello.defer(1000)user.hello(&#x27;Ejklfj&#x27;) // will delay 1000ms Magic of the instance of12345678class Animal &#123; static [Symbol.hasInstance](obj) &#123; if (obj.canEat) return true &#125;&#125;let obj = &#123; canEat: true &#125;console.log(obj instanceof Animal) // it will find from the [[Prototype]] Static123456789101112131415161718192021222324class User &#123; static staticMethod() &#123; console.log(this === User) &#125;&#125;class Article &#123; constructor(title, date) &#123; this.title = title this.date = date &#125; static compare(articleA, articleB) &#123; return articleA.date - articleB.date &#125;&#125;let articles = [ new Article(&#x27;HTML&#x27;, new Date(2019, 1, 1)), new Article(&#x27;Css&#x27;, new Date(2019, 0, 1)),]articles.sort(Article.compare)console.log(articles)","tags":["学习"]},{"title":"Decorator 装饰器模式","path":"/2021/06/21/Decorator-装饰器模式/","content":"e.g.12345678910111213141516171819202122232425262728293031let worker = &#123; someMethod() &#123; return 1 &#125;, slow(x) &#123; console.log(&#x27;called with &#x27; + x) return x * this.someMethod() &#125;,&#125;function decorator(func) &#123; const cache = new Map() return function (x) &#123; if (cache.has(x)) &#123; console.log(&#x27;cache hit&#x27;) return cache.get(x) &#125; const result = func.call(this, x) cache.set(x, result) return result &#125;&#125;worker.slow = decorator(worker.slow)console.log(worker.slow(2))console.log(worker.slow(2)) Injection1234567891011121314151617181920function injection(func, ...argsBound) &#123; return function (...args) &#123; return func.call(this, ...argsBound, ...args) &#125;&#125;// usagelet user = &#123; firstName: &#x27;Edward&#x27;, say(time, phrase) &#123; console.log(`[$&#123;time&#125;]: $&#123;this.firstName&#125; $&#123;phrase&#125;`) &#125;,&#125;user.say = injection( user.say, new Date().getHours() + &#x27;:&#x27; + new Date().getMinutes(),)user.say(&#x27;Hi&#x27;) arrow function123456789101112function defer(f, ms) &#123; return function () &#123; setTimeout(() =&gt; f.apply(this, arguments), ms) &#125;&#125;function sayHello(name) &#123; console.log(`Hi, $&#123;name&#125;`)&#125;const deferSay = defer(sayHello, 2000)deferSay(&#x27;Edward&#x27;) prototype12345678910111213141516let user = &#123; name: &#x27;Edward&#x27;, hello(name) &#123; console.log(`hi $&#123;this.name&#125;, this is $&#123;name&#125;`) &#125;,&#125;Function.prototype.defer = function (ms) &#123; let f = this return function (...arg) &#123; setTimeout(() =&gt; f.apply(this, arg), ms) &#125;&#125;user.hello = user.hello.defer(1000)user.hello(&#x27;Ejklfj&#x27;)","tags":["整理"],"categories":["ECMAScript"]},{"title":"Binary Indexed Array","path":"/2021/06/19/Binary-Index-Array/","content":"DefinitionA Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. update(index, delta): 将delta加到index位置上。 prefixSum(index): 求 sum[1, index]的值。 rangeSum(from, to): 求 sum[from, to] 的值。 时间复杂度： update(index, delta): 更新需要循环更新每一个parent的值，从index开始到最后一个parent。复杂度为O(n)。 prefixSum(index): 直接返回sum[index + 1]即可，复杂度为O(1)。 rangeSum(from, to): 直接返回sum[to + 1] - sum[from]即可，复杂度为O(1)。 Build现在有个nums初始数组，通过这个数组构造一个BITArray。构造Binary Indexed Array。 实现insert(index, delta): 123456function insert(index, delta) &#123; while (index &lt; this.BITArray.length) &#123; this.BITArray[index] += delta index += index &amp; -index // BIT中，parent的index计算方法为：parent = child + (child &amp; -child) &#125;&#125; 构造 BITArray: 123456function MyArray(nums) &#123; this.BITArray = new Array(nums.length + 1).fill(0) for (let i = 0, len = nums.length; i &lt; len; i++) &#123; this.insert(i + 1, nums[i]) // 在每个index处循环插入，delta就是初始值。 &#125;&#125; 实现sum(index): 123456789function sum(index) &#123; let sum = 0 while (index &gt; 0) &#123; sum += this.BITArray[index] index -= index &amp; -index // BIT中，child的计算方法为：child = parent - (parent &amp; -parent) &#125; return sum&#125; 实现perfixSum(from, to) 123function perfixSum(from, to) &#123; return this.sum(to + 1) - this.sum(from)&#125;","tags":["算法"]},{"title":"parseInt()的奇幻现象","path":"/2021/06/18/parseInt-的奇幻现象/","content":"parseInt 中塞 number12parseInt(0.000001) // 0parseInt(0.0000001) // 1 为什么会得到这样的结果？ parseInt(arg: string)：接收的是一个string变量。 0.0000001转成string会变为1e-7。 parseInt(&#39;1e-7&#39;)结果为1。 所以要截取小数，最好还是使用Math.trunc(n)","tags":["整理","parseInt"],"categories":["Javascript"]},{"title":"Typescript Enum取key&value","path":"/2021/06/16/Typescript-Enum取key-value/","content":"12345678910const enum Foo &#123; AA = &#x27;aa&#x27;, BB = &#x27;bb&#x27;,&#125;type B = keyof typeof Foo // &#x27;AA&#x27; | &#x27;BB&#x27;// Template Literal Typestype C = `$&#123;keyof &#123; [x in Foo]: string &#125;&#125;`// &#x27;aa&#x27; | &#x27;bb&#x27;","tags":["整理","学习"],"categories":["Typescript"]},{"title":"Ubuntu折腾笔记--音频","path":"/2021/06/15/Ubuntu折腾笔记-音频/","content":"缘由公司的 PC 没有音卡。导致耳机不能播放。 使用 pavucontrol 输出为模拟信号刚开始总报找不到这个 package。换了官方源也没用。后来才发现需要打开开源 package 安装。。。software &amp; updates &gt; ubuntu software &gt; open-source software","tags":["整理"]},{"title":"2021-05-09","path":"/2021/05/09/2021-05-09/","content":"天下无不散的宴席实习生只剩下一个了，其他都离职了。对他们来说是件好事，呆在这里也不能提高多少。 最近发生的事情太多了： 养了一只猫：某天突然就想养只猫了，下午决定晚上就去领了一只。回家后花了不少精力，现在活得还算不错。 新买了个镜头：入了个 35mm f2.0 镜头，扫街+人像应该够了。 不知不觉喜欢上了一个女生：深入了解后发现希望不大，还是放弃了。 去了家公司参观：这家公司有 Node 中间层，是以前未接触过的。今后还需努力。 刷了一点 leetcode：在公司需求不多，就刷着为以后做准备了。 买了一点书：身体和心灵总有一个在路上。 去桂山岛旅游：看了看人烟稀少的小镇是什么样的生活。 币圈疯狂的人们数字货币的世界，涨跌不需要理由。公司一群人炒币，只有一个人脱身，其余的加起来估计亏了百来万。地铁上，公交上，餐厅奶茶店；俊男靓女，大爷大妈，所有人都在炒币，太疯狂了。 人的欲望总是无穷的，赌徒只需要输一次就能将所有的钱输完，人性的弱点。大家都希望山底买，山顶卖。但是谁又知道你是不是买在山顶呢。大家都信仰最大傻瓜理论，觉得自己不是那个大傻瓜。 安心生活周末出去走走看看世界看一场电影看几本书与朋友游戏几局平安喜乐就够了 还是决定关闭 blog 了。太多黑历史，何况还有骂 GCD 的东西。","tags":["雜談"]},{"title":"Flutter 语法","path":"/2021/01/27/Flutter-语法/","content":"Null-aware operators12345678910String foo = &#x27;a string&#x27;;String bar; // Unassigned objects are null by default.// Substitute an operator that makes &#x27;a string&#x27; be assigned to baz.String baz = foo ?? bar;void updateSomeVars() &#123; // Substitute an operator that makes &#x27;a string&#x27; be assigned to bar. bar ??= &#x27;a string&#x27;;&#125; Conditional property accessmyObject?.someProperty equals to (myObject != null) ? myObject.someProperty : null. 123456// This method should return the uppercase version of `str`// or null if `str` is null.String upperCaseIt(String str) &#123; // Try conditionally accessing the `toUpperCase` method here. return str?.toUpperCase();&#125; CascadesmyObject.someMethod() will get the return value of the someMethod(), myObject..someMethod() will get the reference of the myObject. 12345678910111213141516171819class BigObject &#123; int anInt = 0; String aString = &#x27;&#x27;; List&lt;double&gt; aList = []; bool _done = false; void allDone() &#123; _done = true; &#125;&#125;BigObject fillBigObject(BigObject obj) &#123; // Create a single statement that will update and return obj: return obj ..anInt = 1 ..aString = &quot;String!&quot; ..aList = [3.0] ..allDone();&#125; Optional named parameters12345678910111213141516171819class MyDataObject &#123; final int anInt; final String aString; final double aDouble; MyDataObject(&#123; this.anInt = 1, this.aString = &#x27;Old!&#x27;, this.aDouble = 2.0, &#125;); // Add your copyWith method here: MyDataObject copyWith(&#123;int newInt, String newString, double newDouble&#125;) &#123; return MyDataObject(anInt: newInt ?? this.anInt, aString: newString ?? this.aString, aDouble: newDouble ?? this.aDouble ); &#125;&#125; Initializer lists12345678910class FirstTwoLetters &#123; final String letterOne; final String letterTwo; // Create a constructor with an initializer list here: FirstTwoLetters(String word) : assert(word.length &gt;= 2), letterOne = word[0], letterTwo = word[1] &#123;&#125;&#125; Named constructors12345678910111213class Color &#123; int red; int green; int blue; Color(this.red, this.green, this.blue); Color.black() &#123; red = 0; green = 0; blue = 0; &#125;&#125; Factory constructors1234567891011121314151617181920212223242526272829class IntegerHolder &#123; IntegerHolder(); // Create your factory constructor called &quot;fromList&quot; here. factory IntegerHolder.fromList(List&lt;int&gt; list) &#123; if (list.length == 1) return IntegerSingle(list[0]); if (list.length == 2) return IntegerDouble(list[0], list[1]); if (list.length == 3) return IntegerTriple(list[0], list[1], list[2]); return null; &#125;&#125;class IntegerSingle extends IntegerHolder &#123; final int a; IntegerSingle(this.a);&#125;class IntegerDouble extends IntegerHolder &#123; final int a; final int b; IntegerDouble(this.a, this.b);&#125;class IntegerTriple extends IntegerHolder &#123; final int a; final int b; final int c; IntegerTriple(this.a, this.b, this.c);&#125; Redirecting constructors123456789101112class Color &#123; int red; int green; int blue; Color(this.red, this.green, this.blue); // Create a named constructor called &quot;black&quot; here and redirect it // to call the existing constructor Color.assign(int red, int green, int blue): this(red, green, blue); Color.black(): this.assign(0, 0, 0);&#125; Const constructors1234567class Recipe &#123; final List&lt;String&gt; ingredients; final int calories; final double milligramsOfSodium; const Recipe(this.ingredients, this.calories, this.milligramsOfSodium);&#125;","tags":["学习","Flutter"]},{"title":"useMemo","path":"/2021/01/13/useMemo/","content":"useMemouseMemo 是拿来保持一个对象引用不变的。useMemo 和 useCallback 都是 React 提供来做性能优化的。比起 classes， Hooks 给了开发者更高的灵活度和自由，但是对开发者要求也更高了，因为 Hooks 使用不恰当很容易导致性能问题。 假设有个 component，在 dataConfig 变化的时候重新去 fetchData： 123456&lt;Child fetchData=&#123;() =&gt; &#123; // fetch data &#125;&#125; dataConfig=&#123;&#123; id: getId(queryId) &#125;&#125;/&gt; 如果是个 Class Component，会这么写： 1234567class Child extends React.Component&lt;Props&gt; &#123; componentWillReceiveProps(nextProps: Props) &#123; if (nextProps.dataConfig !== this.props.dataConfig) &#123; nextProps.fetchData(nextProps.dataConfig) &#125; &#125;&#125; 使用 Hooks 后长这样： 12345const Child = (&#123; fetchData, dataConfig &#125;: Props) =&gt; &#123; useEffect(() =&gt; &#123; fetchData(dataConfig) &#125;, [fetchData, dataConfig])&#125; 使用 Class Component 时我们需要手动管理依赖，但是使用 Hooks 时会带来副作用：React 使用的是Object.is()，如果fetchData的 reference 变了，也会触发 useEffect。虽然逻辑上 React 的处理是合理的，但是还是需要手动去解决它导致的性能问题：官方提供了 useCallback 这个 hooks，用于解决函数引用问题。 12345678910const App = () =&gt; &#123; const fetchData = useCallback( (config: any) =&gt; &#123; queryList(config) &#125;, [queryList], ) return &lt;Child fetchData=&#123;fetchData&#125; dataConfig=&#123;&#123; id: getId(queryId) &#125;&#125; /&gt;&#125; 但是这个时候还有一个地方没有解决——Props。只要 props 更新，组件还是会重新 fetchData，因为 dataConfig 也是一个会变化的 prop。memo 是一个最容易被忽略的 Hooks，即使我们有意不在 JSX 中做计算，写成这样： 12345678910const fetchData = useCallback( (config: any) =&gt; &#123; queryList(config) &#125;, [queryList],)const dataConfig = queryConfig(id)return &lt;Child fetchData=&#123;fetchData&#125; dataConfig=&#123;dataConfig&#125; /&gt; 由于习惯函数式编程，我们已经习惯了这种写法。但是组件是有状态的，状态更新了就得处理相关逻辑，触发 re-render。我们需要告诉 React 什么时候该处理这个状态，这时候 useMemo 就登场了。 12345678910111213const fetchData = useCallback( (config: any) =&gt; &#123; queryList(config) &#125;, [queryList],)const dataConfig = useMemo( () =&gt; (&#123; ...config, id: getId(queryId) &#125;), [getId, queryId],)return &lt;Child fetchData=&#123;fetchData&#125; dataConfig=&#123;dataConfig&#125; /&gt; 这样 dataConfig 只有在 getId 或 queryId 变化时才重新生成，组件才会在必要的时候重新 fetchData memo只使用 useMemo 和 useCallback 来进行优化是有可能达不到效果的，原因在于如果 props 引用不发生变化，虽然不会重新渲染，但它依然会重新执行。 12345678910111213141516171819202122232425const Child = (&#123; name &#125;: Props) =&gt; &#123; console.log(&#x27;run&#x27;) // will log every second // some complex calculations return &lt;div&gt;&#123;name&#125;&lt;/div&gt;&#125;const App = () =&gt; &#123; const [name] = useState(&#x27;foo&#x27;) const [count, setCount] = useState(0) useEffect(() =&gt; &#123; setInterval(() =&gt; &#123; setCount((prev) =&gt; prev + 1) &#125;, 1000) &#125;, []) return ( &lt;div&gt; &lt;div&gt;&#123;count&#125;&lt;/div&gt; &lt;Child name=&#123;name&#125; /&gt; &lt;/div&gt; )&#125; 如果 Child 中的计算量非常大，这时候的性能主要就耗在重新执行的这个过程了。如果想要阻断这一过程重新执行，React 有一个 API：memo，它相当于一个 PureComponent，是一个 HOC，默认对 props 进行一次浅比较，如果 props 不变，则不会重新执行。现在给 Child 套上 memo： 1234567const Child = memo((&#123; name &#125;: Props) =&gt; &#123; console.log(&#x27;run&#x27;) // will log only once // some complex calculations return &lt;div&gt;&#123;name&#125;&lt;/div&gt;&#125;) 或者使用 useMemo 包裹： 12345678910111213141516171819const App = () =&gt; &#123; const [name] = useState(&#x27;foo&#x27;) const [count, setCount] = useState(0) useEffect(() =&gt; &#123; setInterval(() =&gt; &#123; setCount((prev) =&gt; prev + 1) &#125;, 1000) &#125;, []) const memoChild = useMemo(() =&gt; &lt;Child name=&#123;name&#125; /&gt;, [name]) return ( &lt;div&gt; &lt;div&gt;&#123;count&#125;&lt;/div&gt; &#123;memoChild&#125; &lt;/div&gt; )&#125; 何时何处使用？ 开销大的组件可以考虑使用 memo。因为有的组件重新渲染的开销可能比用 memo 做浅比较的开销还小，但是如果组件的重新执行开销很大，使用 memo 一定可以加快性能。 用 useMemo 和 useCallback 来控制 props 的引用，和 memo 配套使用效果最佳。性能优化是一个整体的过程，不是单独在某个组件里就可以改善的。 useMemo 避免昂贵计算，useCallback 解决 reference 问题，memo 解决 shouldComponentUpdate 问题。","tags":["学习"]},{"title":"Waves svg","path":"/2021/01/12/Waves-svg/","content":"","tags":["svg"]},{"title":"useRef","path":"/2021/01/11/useRef/","content":"useRef mutable ref presist eg: 实现一个需求：点击按钮时 input 自动聚焦。 createRef 实现 12345678910111213141516const HomePage = () =&gt; &#123; const input = createRef&lt;HTMLInputElement&gt;() const handle = () =&gt; &#123; if (input.current) &#123; input.current.focus() &#125; &#125; return ( &lt;div&gt; &lt;input ref=&#123;input&#125; /&gt; &lt;button onClick=&#123;handle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125; useRef 实现 12345678910111213141516const HomePage = () =&gt; &#123; const input = useRef&lt;HTMLInputElement | null&gt;(null) const handle = () =&gt; &#123; if (input.current) &#123; input.current.focus() &#125; &#125; return ( &lt;div&gt; &lt;input ref=&#123;input&#125; /&gt; &lt;button onClick=&#123;handle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125; 两者的区别在于：createRef 每次渲染会返回一个新的引用，而 useRef 返回的是相同的引用（persist）。对于函数式组件，每次 useState 会造成整个组件的重新渲染，但是 uesRef 可以保证引用不变，不会触发 re-render。 eg： 12345678910111213141516171819202122const HomePage = () =&gt; &#123; const [index, setIndex] = useState(1) const click = () =&gt; &#123; setTimeout(() =&gt; &#123; /** * 2 * 3 * 4 */ console.log(index) &#125;, 3000) &#125; return ( &lt;div&gt; &lt;span&gt;current: &#123;index&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; setIndex((prev) =&gt; prev + 1)&#125;&gt;increase&lt;/button&gt; &lt;button onClick=&#123;click&#125;&gt;log index&lt;/button&gt; &lt;/div&gt; )&#125; log 出来的并不是实时的 index，每次触发 setState 都会重新渲染，timeout 中拿到的都是当时的 index。使用 useRef 就可以拿到实时更改的结果： 123456789101112131415161718192021222324252627const HomePage = () =&gt; &#123; const [index, setIndex] = useState(1) const ref = useRef&lt;number | null&gt;(null) useEffect(() =&gt; &#123; ref.current = index &#125;) const click = () =&gt; &#123; setTimeout(() =&gt; &#123; /** * 4 * 4 * 4 */ console.log(ref.current) &#125;, 3000) &#125; return ( &lt;div&gt; &lt;span&gt;current: &#123;index&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; setIndex((prev) =&gt; prev + 1)&#125;&gt;increase&lt;/button&gt; &lt;button onClick=&#123;click&#125;&gt;log index&lt;/button&gt; &lt;/div&gt; )&#125; useRef 还可拿到前一个值12345678910111213141516const HomePage = () =&gt; &#123; const [index, setIndex] = useState(1) const ref = useRef&lt;number | null&gt;(null) useEffect(() =&gt; &#123; ref.current = index &#125;) return ( &lt;div&gt; &lt;span&gt;current: &#123;index&#125;&lt;/span&gt; &lt;span&gt;prev: &#123;ref.current&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; setIndex((prev) =&gt; prev + 1)&#125;&gt;increase&lt;/button&gt; &lt;/div&gt; )&#125; React 渲染 JSX 比 useEffect 快，所以已经渲染完成，才给 ref.current 赋值，ref 引用不变，不引起 re-render，所以渲染出来的是上一个值。通过这个特性可以封装一个 usePrevious： 123456789const usePrevious = (value: any) =&gt; &#123; const ref: any = useRef() useEffect(() =&gt; &#123; ref.current = value &#125;, [value]) return ref.current&#125; 还有一个特别的用处，可以用于记录 timer： 123456789const timer = useRef&lt;NodeJS.Timeout | null&gt;(null)useEffect(() =&gt; &#123; timer.current = setInterval(() =&gt; &#123; // do something &#125;, 1000) return () =&gt; clearInterval(timer.current as NodeJS.Timeout)&#125;)","tags":["学习"]},{"title":"State/Effect 分层","path":"/2021/01/10/State-Effect-分层/","content":"友好的 React Hooks网络上对 react hooks 的评价负面大于正面，确实很容易写出性能有问题的代码，关键就在于：我们太喜欢用 useState 了。在 vue-composition-api 中，reactivity 数据都有 wrapper，custom-vca 里不管产生多少个 reactivity 对象，不会直接产生 re-render。只有那些被 return 到外部跟 template 绑定的部分才会触发视图渲染。而 react 的 reactivity 就是通过 re-render 实现的，useState 没有 wrapper，每次使用都会得到一个触发渲染的函数。在这种 reactivity 机制下，就需要特殊的方式编写 hooks —— State&#x2F;Effect 分层 假设有个 useHeight： 1const [ref, height] = useHeight() 高度变化时，被动 re-render，难以转换合并。大部分情况下，不提供 state，而提供 effect 可能会更好： 12345const [height, setHeight] = useState(0)const ref = useHeight((height: number) =&gt; &#123; // do something setHeight(height)&#125;) 使用者在外部声明 state，然后在 callback 中按需 setState。使用者可以结合其他 state，做 dispatch 到 reducer 的一次整体更新，而不是被动 re-render。根据 State&#x2F;Effect 分层理念，尝试着给出友好地 react hooks 公式： 1const handler = useProducer(consumer, options) producer 接收 consumer callback 作为参数，返回 handler 控制函数，用于绑定到事件或其他位置。 React 实现 useHeight给定一个 resizable 的 textarea，我们监听它的高度变化，并展示到文本里。同时给个 checkbox，用户决定是否继续监听。并且只监听一定范围内的尺寸变化。代码实现按照 low-level -&gt; high-level 首先实现一个 useResizeObserver，对 dom api 的 low-level 适配： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; useCallback, useLayoutEffect, useRef &#125; from &#x27;react&#x27;const useDispatch = &lt;I extends any[], O&gt;(f: (...args: I) =&gt; O): typeof f =&gt; &#123; const dispatchRef = useRef&lt;typeof f&gt;(f) const callback = useCallback&lt;typeof f&gt;((...args) =&gt; &#123; return dispatchRef.current(...args) &#125;, []) useLayoutEffect(() =&gt; &#123; dispatchRef.current = f &#125;, [f]) return callback&#125;export const useResizeObserver = &lt;T extends HTMLElement&gt;( callback: (target: T) =&gt; any,) =&gt; &#123; const ref = useRef&lt;T | null&gt;(null) const observerRef = useRef&lt;ResizeObserver | null&gt;(null) const dispatch = useDispatch(callback) const trigger = (elem: T | null) =&gt; &#123; ref.current = elem if (observerRef.current) &#123; observerRef.current.disconnect() observerRef.current = null &#125; if (!elem) &#123; return &#125; const observer = new ResizeObserver(() =&gt; &#123; dispatch(elem) &#125;) observer.observe(elem) observerRef.current = observer &#125; const enable = () =&gt; &#123; if (ref.current) &#123; observerRef.current?.observe(ref.current) &#125; &#125; const disable = () =&gt; &#123; if (ref.current) &#123; observerRef.current?.unobserve(ref.current) &#125; &#125; return &#123; trigger, enable, disable &#125;&#125; useResizeObserver 不返回 state 出去，而是暴露一个 resize effect。然后再使用 useResizeObserver 实现 useHeight： 1234567891011121314export const useHeight = &lt;T extends HTMLElement&gt;( callback: (height: number) =&gt; any,) =&gt; &#123; const heightRef = useRef&lt;number&gt;(0) const observer = useResizeObserver&lt;T&gt;((target) =&gt; &#123; const height = target.offsetHeight heightRef.current = height callback(height) &#125;) const getCurrentHeight = () =&gt; heightRef.current return &#123; ...observer, getCurrentHeight &#125;&#125; 同样的思路还能实现其他监听。最后在页面中使用： 12345678910111213141516171819202122232425262728293031323334353637export default function App() &#123; const [height, setHeight] = useState(0) const [checked, setChecked] = useState(false) const handler = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123; setChecked(event.target.checked) &#125; const observer = useHeight &lt; HTMLTextAreaElement &gt; ((currentHeight) =&gt; &#123; if (currentHeight &gt; 300) &#123; if (currentHeight !== 300) &#123; setHeight(300) &#125; &#125; else &#123; setHeight(currentHeight) &#125; &#125;) useEffect(() =&gt; &#123; if (checked) &#123; observer.enable() &#125; else &#123; observer.disable &#125; &#125;, [checked, observer]) return ( &lt;div&gt; &lt;textarea ref=&#123;observer.trigger&#125; /&gt; &lt;div&gt;height is &#123;height&#125;&lt;/div&gt; &lt;input type=&quot;checkbos&quot; checked=&#123;checked&#125; onChange=&#123;handler&#125; /&gt; &lt;/div&gt; )&#125;","tags":["学习","React","React Hooks"],"categories":["React"]},{"title":"TikTok svg","path":"/2021/01/08/TikTok-svg/","content":"","tags":["svg"]},{"title":"Battery svg","path":"/2021/01/05/Battery-svg/","content":"","tags":["svg"]},{"title":"Mix-ins","path":"/2021/01/04/Mix-ins/","content":"Mix-ins Abstract subclasses or mix-ins are templates for classes. An ECMAScript class can only have a single superclass, so multiple inheritance from tooling classes, for example, is not possible. The functionality must be provided by the superclass. eg: 12345678910111213141516171819const calculatorMixin = (Base) =&gt; class extends Base &#123; calc() &#123; // do something &#125; &#125;const randomizerMixin = (Base) =&gt; class extends Base &#123; remdomize() &#123; // do something &#125; &#125;class Foo &#123;&#125;class Bar extends calculatorMixin(randomizerMixin(Foo)) &#123;&#125;const bar = new Bar()console.log(bar.calc)console.log(bar.remdomize) // also a function.","tags":["JavaScript","Mix-ins"],"categories":["JavaScript"]},{"title":"2021观影记录","path":"/2021/01/01/2021观影记录/","content":"电影 &#x2611; 沐浴之王：老套路。看完了感觉很无聊。 &#x2611; Dead to 2020：英剧喜剧片。有点意思，照例黑老美。 &#x2611; 十诫：老电影，十分艺术。 &#x2611; Megan Leavey：军人与军犬之间的故事，但是我还是觉得一旦走上了这条路，就很难回归正常生活了。 &#x2610; 邪不压正 &#x2611; 急先锋：很难想象是 2020 年的电影，给我的感觉比不上神话。 &#x2611; Azizler（易舍难分）：拿到了好的题材，拍了一部烂片。 &#x2611; Mosul（血战摩苏尔）：钢枪很热血，剧情挺狗血。 &#x2611; Greenland（末日逃生）：强行拖剧情，很多地方逻辑不通。特效还可以。 &#x2611; 赵子龙：垃圾片。 &#x2611; 送你一朵小红花 &#x2611; 盗梦空间 纪录片 &#x2611; Alien Worlds：根据现有的环境对其他星球进行模拟，幻想存在的物种。最后一集很震撼，随着进化只剩下神经系统，不需要肉体。靠葡萄糖维持生命，高度发达的机器人。","tags":["整理"]},{"title":"macOS打不开非官方dmg文件","path":"/2021/01/01/macOS打不开非官方dmg文件/","content":"直接使用 su 权限移除镜像的 quarantine 标志1sudo xattr -rd com.apple.quarantine /Applications/&lt;application-name&gt;","tags":["整理"],"categories":["macOS"]},{"title":"2020总结","path":"/2021/01/01/2020总结/","content":"转眼间就是新的一年了。2020 年，庚子年。发生了许多事情。 新冠 澳洲大火 美股熔断 ··· 在这一年里我也毕业了，入职了，成为了一个打工人士。有了收入之后之前想买的东西都基本买齐了，之前想做的事还在稳步进行中。虽然很多人说 2020 是未来十年中最好的一年，但是在我这还是有可圈可点的地方。大环境的改变，正是抓住机遇的时候。 今年完成的事情 毕业 入职 购买想要的数码产品 补习数学（线性代数、离散） 学习英语 看剧 听歌（QQ 音乐榜单显示全年听了 3700 首） 数字货币（盈利） 基金（亏损） 股票（亏损） 明年预计完成的事情 加薪 独自旅游 学习炒股 学习数学（代数） 深入技术 学习色彩与构图 仰望星空，脚踏实地。在之前的学生生涯中，总是容易对自己的些许成就沾沾自喜。进入了社会后才会发现之前的成就根本不值一提。需要学习的还有很多，在 TypeScript 群里学习了很多新的知识。 新的一年，希望能认识更多优秀的人，学习更多新的知识。","tags":["整理"],"categories":["年终总结"]},{"title":"Clash Service","path":"/2020/12/19/Clash-Service/","content":"config clash.servicefile path: /etc/systemd/system 12345678910111213[Unit]Description=Clash serviceAfter=network.target[Service]Type=simpleUser=edwardExecStart=/usr/bin/clash -d /home/edward/.config/clash &gt;&gt; /home/edward/.config/clash/clash.logRestart=on-failureRestartPreventExitStatus=23[Install]WantedBy=multi-user.target start: systemctl start clash stop: systemctl stop clash enable(start when system start): systemctl enable clash disable: systemctl disable clash status: systemctl status clash","tags":["Clash","Linux"],"categories":["Clash"]},{"title":"2020/11 總結","path":"/2020/12/07/2020-11-總結/","content":"最近在做的事 去中心化 APP 閱讀”我的簡史” 上月任務 Testing: 需求過多,完成一半 結構優化: Done. TS: 擱置 shell: 擱置 這個月的目標 線性代數 Webpack 去中心化 APP 最近的事 BTC 接近 20000 去道院參觀 補習數學","tags":["雜談"]},{"title":"使用clash進行科學上網","path":"/2020/11/08/使用clash進行科學上網/","content":"之前使用的是 trojan, 奈何找不到好的管理程序, 現使用 clashclash 的 config 使用的是 yaml 文件, 所以比較好寫. 1234567891011121314151617181920212223242526272829303132333435port: 7890socks-port: 7891mixed-port: 7892 # 混合端口allow-lan: true # 允許局域網連接log-level: infoexternal-controller: 127.0.0.1:9090 # 外部控制端口extarnal-ui: dashborad # 使用的uiproxies: # clash官方文檔有更清楚的寫法 - &#123; type: ss, name: &#x27;TEST-SS&#x27;, server: 127.0.0.1, port: 2020, password: 123456, plugin: obfs, plugin-opts: &#123; mode: http &#125;, &#125; # 公司使用的是ss協議 - &#123; type: trojan, name: &#x27;TEST-TROJAN&#x27;, server: 127.0.0.1, port: 443, password: 123456, #sni skip-cert-verify: true, &#125;proxy-groups: - &#123; name: WORK, type: select, proxies: [&#x27;TEST-SS&#x27;] &#125; # 將所需的proxy單獨進行分組 - &#123; name: Proxy, type: select, proxies: [&#x27;TEST-TROJAN&#x27;] &#125;rules: - IP-CIDR, 10.8.0.0/12, WORK # 根據rule將不同的請求轉發到所需的分組去 - IP-CIDR, 172.30.0.0/12, WORK - IP-CIDR, 100.64.0.0/10, DIRECT - IP-CIDR, 127.0.0.0/8, DIRECT - DOMAIN-SUFFIX, google.com, Proxy","tags":["雜談"]},{"title":"2020/10 總結","path":"/2020/11/07/2020-10-總結/","content":"最近的任務量比較多10 月份除開 1-8 只休息了四天, 需求很趕, 代碼質量參差不齊. 上個月的任務 React Hook: 這個月打算將之前的代碼邏輯抽離城自定義 hooks shell: 需求太密已擱置 Linux: 需求太密已擱置 優化 code: 大部分都已經優化掉了, 少數 code 還存在很大問題. 這個月的目標: 補全測試 優化代碼結構, 文件結構 挖掘 Jest 深入用法 重新熟悉 Typescript shell 最近的事 BTC 價格接近 16000 美國大選 追完說唱新世代, 一場三個小時是有夠久的 人生中第一次得蕁麻疹, 查不出病因","tags":["雜談"]},{"title":"使用generator處理無限數據流","path":"/2020/10/07/使用generator處理無限數據流/","content":"Example假設現在有一個數據非常多的數組,但是我們只需要它的前幾個數據,并且進行一定的操作,這時候可以使用 generator 來進行 take 的操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]const from = (arr) =&gt; arr[Symbol.iterator]()const filter = (f) =&gt; function* (iter) &#123; let v = iter.next() while (!v.done) &#123; if (f(v.value)) yield v.value v = iter.next() &#125; &#125;const multipy = (n) =&gt; function* (iter) &#123; let v = iter.next() while (!v.done) &#123; yield v.value * n v = iter.next() &#125; &#125;const take = (n) =&gt; function* (iter) &#123; let i = 0 let v = iter.next() while (!v.done &amp;&amp; i &lt; n) &#123; yield v.value i++ v = iter.next() &#125; &#125;const pipe = (...arr) =&gt; arr.reduce((acc, func) =&gt; func(acc))console.log([ ...pipe( from(arr), filter((v) =&gt; v % 2 === 0), multipy(3), take(30), filter((v) =&gt; v &gt; 15), ),]) // [18, 24, 30, 36]","tags":["JavaScript","ES6","generator"],"categories":["ECMAScript"]},{"title":"Transducer","path":"/2020/10/03/Transducer/","content":"ReducerReducer 將多個 input flod 成一個 output. 1234const add = (a, b) =&gt; a + bconst multiply = (a, b) =&gt; a * bconst concatString = (a, b) =&gt; a + bconst concatArray = (a, b) =&gt; [...a, ...b] TransducerTransducer 做的事情大致相同,但是與普通的 reducer 不同的是,它可以通過多個 function 組合而成.而普通的 reducer 不能組合,因爲他們接受兩個參數,但是只返回一個值,所以不能將這次的結果傳入下一個 reducer: 1234567// reducerf: (a, c) =&gt; ag: (a, c) =&gt; a// transducerf: (reducer) =&gt; reducerg: (reducer) =&gt; reducer Why Transducers?儅我們處理數據時,將處理過程拆分成相互獨立,然後組合的步驟會非常有用.假設現在有一個非常大的數據集,現在需要對數據集處理某些操作,你可能會這樣做: 12345678910111213const friends = [ &#123; id: 1, name: &#x27;Sting&#x27;, nearMe: true &#125;, &#123; id: 2, name: &#x27;Radiohead&#x27;, nearMe: true &#125;, &#123; id: 3, name: &#x27;NIN&#x27;, nearMe: false &#125;, &#123; id: 4, name: &#x27;Echo&#x27;, nearMe: true &#125;, &#123; id: 5, name: &#x27;Zeppelin&#x27;, nearMe: false &#125;,]const isNearMe = (&#123; nearMe &#125;) =&gt; nearMeconst getName = (&#123; name &#125;) =&gt; nameconst results = friends.filter(isNearMe).map(getName)console.log(results) // =&gt; [&quot;Sting&quot;, &quot;Radiohead&quot;, &quot;Echo&quot;] 上面的例子存在著一定的問題:只能處理 array;如果存在從網絡上來的無限數據流,該如何處理? 每次在 array 上使用.語法時,JavaScript 都會構造一個全新的 intermediate array,如果你的 array 非常龐大,這時的性能會出現指數級的下降.若使用 transducer,則可以將每個 item 在 pipe 中傳輸,無需建立中間對象,從而節省了大量的時間和内存. Example下面的代碼暫時未實現具體的操作,但是可以先觀察 transducer 是如何構建的. 12345678910111213const friends = [ &#123; id: 1, name: &#x27;Sting&#x27;, nearMe: true &#125;, &#123; id: 2, name: &#x27;Radiohead&#x27;, nearMe: true &#125;, &#123; id: 3, name: &#x27;NIN&#x27;, nearMe: false &#125;, &#123; id: 4, name: &#x27;Echo&#x27;, nearMe: true &#125;, &#123; id: 5, name: &#x27;Zeppelin&#x27;, nearMe: false &#125;,]const isNearMe = (&#123; nearMe &#125;) =&gt; nearMeconst getName = (&#123; name &#125;) =&gt; nameconst getFriendsNearMe = compose(filter(isNearMe), map(getName))const results2 = toArray(getFriendsNearMe, friends) Transducer 在需要使用並給它傳遞數據時才會執行,也就是上述代碼的toArray()部分,你可以自己實現 transducer 的轉換結果.Transducer 可以映射各種類型,例如 &#123;x, y, z&#125; -&gt; &#123;x, y, z&#125; &#123;x, y ,z&#125; -&gt; &#123;x, z&#125; &#123;x, y, z&#125; -&gt; &#123;x, y, z, xx, yy, zz&#125; 假設我們現在需要讓一個 array 中的數字翻倍,我們可以這麽實現: 1234const double = (x) =&gt; x * 2const arr = [1, 2, 3]const result = arr.map(double) 在上述例子中,arr 是一個可枚舉對象,map 將每個對象單獨進行 double 處理,然後將所有的值纍加到新的 array 中.我們還可以實現新的效果: 1234567const isEven = (x) =&gt; x % 2 === 0const double = (x) =&gt; x * 2const arr = [1, 2, 3, 4, 5, 6]const result = arr.filter(isEven).map(double)console.log(result) 但是,處理無限數據流時會發生什麽?數組是不能無限長的,在數組的處理中,你必須將整個迭代成一個集合,才能進行下一步的處理.這種限制就會導致性能降低,因爲需要創建一個中間數組,并且為每個操作迭代一次新的集合.就用上述的例子來説,首先有一個過濾單數的操作,然後有一個倍增的操作.必須先在過濾操作中將所有的元素進行過濾,然後再在 double 中執行所有的元素,才能夠拿到你想要的數據.一種處理方法是將每個值單獨映射,一次通過一個值,這樣就避免了每次生成一個映射集合,并且隨時能夠通過值來發出終止信號: Pull: lazy evaluation: 直到用戶要求取下一個值時,才會拿出下一個值.如Iterable. Push: eager evaluation: 每次拿出一個值,然後傳入 reducer 中,生成新值.如Array.reduce() Transducer 不關心你使用的是哪種方式,也不關心數據的具體結構,他們只是簡單的調用傳入的 reducer 並纍加新值.實際上就是一個 Higher Order Reducer,它的類型大致為: 12reducer = (accumulator, current) =&gt; accumulatortransducer = (reducer) =&gt; reducer 大多數 transducer 需要使用一定的參數以實現特定的功能,所以一個 map transducer 也許類型為這樣: 1234map = (transform) =&gt; (reducer) =&gt; reducer;// another waymap = ((a) =&gt; b) =&gt; (step) =&gt; reducer; map 接受一個 mapping function(transform),一個 reducer(step)然後返回一個新的 reducer.現在來看一些簡單的例子. Naive Examples123456789101112131415const compose = (...fns) =&gt; (x) =&gt; fns.reduceRight((y, f) =&gt; f(y), x)const map = (f) =&gt; (step) =&gt; (a, c) =&gt; step(a, f(c))const filter = (predicate) =&gt; (step) =&gt; (a, c) =&gt; predicate(c) ? step(a, c) : aconst isEven = (n) =&gt; n % 2 === 0const double = (n) =&gt; n * 2const doubleEvens = compose(filter(isEven), map(double)) // also a transducerconst arrayConcat = (a, c) =&gt; a.concat([c]) // stepconst xform = doubleEvens(arrayConcat) // a reducerconst result = [1, 2, 3, 4, 5, 6].reduce(xform, []) // [4, 8, 12] 在這個例子中,map 就是一個 transducer,你還能這樣使用: 123456const double = (x) =&gt; x * 2const doubleMap = map(double) // double is a transformconst step = (a, c) =&gt; console.log(c)doubleMap(step)(0, 4) // 8doubleMap(step)(0, 21) // 42 其中,0 代表 reducer 的初始值,step 函數本該是一個 reducer,但是方便演示就將他寫成一個 logger.這種技巧也可以在單元測試中作斷言使用.","tags":["学习","函数式编程"],"categories":["Functional Programming"]},{"title":"Blog集成到CI","path":"/2020/10/01/Blog集成到CI/","content":"閑著無聊看了看如何部署公司内部有 k8s 集群,所以也需要學習如何寫 deploy 脚本.目前服務挂在 Travis CI 上,後續可能會使用自己的機器裝個 Github Runner 啥的… 步驟大致為: 在 Travis 中登錄,然後選擇需要 watch 的倉庫 編寫 deploy 文件,需要内部暴露字段的可以在 setting 中添加 在 github 中拿到 person access token,添加到 Travis 因爲 blog 還不需要 build 和 test 的步驟,所以我的 deploy file 暫時還沒有這些: 1234567891011121314151617181920212223242526272829303132333435language: node_jsnode_js: - 10 # hexo目前似乎還不支持node 14版本branches: only: - master # 需要監聽的branchbefore_install: - npm install -g hexo-cliinstall: - npm install - npm install hexo-deployer-gitbefore_script: - git config user.name &quot;$&#123;username&#125;&quot; - git config user.email &quot;$&#123;email&#125;&quot; - rm -rf themes/next - git clone https://github.com/theme-next/hexo-theme-next themes/next - cp assets/config/_config.yml themes/next/_config.yml # 我將自己的theme config存在assets中 - cp assets/images/avatar.jpg themes/next/source/images/avatar.jpg - sed -i &quot;s/github_token/$&#123;GITHUB_TOKEN&#125;/g&quot; _config.ymlscript: - hexo clean - hexo generate - echo &quot;Generation finished.&quot; - hexo deploynotifications: email: - foo@example.com on_success: change on_failure: always October Plan React Hook: 首要完成的目標 shell: 不知道能學到什麽程度 Linux 命令: 不知道能學到什麽程度 優化之前的 code: 算是屎山了 September Harvest Test Driven Development: 業務需求太多,暫時還是需求開發 State Management: 還不熟練 Null Value Judgment: 後端新使用的框架,如果字段值為0或者&#39;&#39;,返回的 data 裏直接沒這個字段了(XD),所以很多地方都新增了判空處理 Left Questions Mobx 包裹的對象無法 log React Native 難以 debug 移動端難以 testing","tags":["雜談"]},{"title":"Alibaba Cloud","path":"/2020/09/14/Alibaba-Cloud/","content":"買了個阿里雲服務有點太貴了。隨便跑點什麽 Memory 就 100%。 時常掉綫，不知道是不是網絡的問題。拿到公司 Network 環境一樣掉綫。 想搭個 Gatsby 玩玩，還是用自己的電腦吧。","tags":["雜談"]},{"title":"一點總結","path":"/2020/09/11/一點總結/","content":"工作以來的感受最大的感受就是，需要學習的還有很多很多。獨立思考可以讓你的思維更加開放、活躍，同時可以激發更多的靈感。目前的技術棧：React+Mobx+TypeScirpt 從前對狀態管理沒有什麽概念，自從接觸到工程項目之後，對爲何要進行 State Management 越來越清晰。當然也產生了一定的不良影響 -&gt; 只要上手就會想如何設計 State，導致有的地方代碼實在冗餘。 同時在項目代碼中瞭解了許多新知識，如何去設計一個可繼承、可復用的 Function；如何將 Store 封裝，便於使用；如何對請求進行封裝；何時使用 Interface、何時使用 Type；等等…… 接下來需要做的 思考之前的代碼如何優化 思考目前的代碼是否還能拆分 閲讀 State Management 的文章 …… 課餘時間的活動 書籍 熵的世界 我的簡史 - 霍金 日常 陰陽師 B 站 手游 - 跑跑卡丁車 音樂 綜藝 説唱新世代 中國新説唱 影視劇 甜蜜蜜 投名狀 親愛的 八佰 Mulan 信條 挖坑考慮用點什麽搭一個自己的博客。","tags":["雜談"]},{"title":"Higher Order Components","path":"/2020/08/11/Higher-Order-Components/","content":"使用 HOC 进行代码复用假设存在下面两个组件： 1234567891011121314151617181920212223242526272829import React from &#x27;react&#x27;class ButtonCounter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0, &#125; &#125; increase = () =&gt; &#123; let &#123; step &#125; = this.props this.setState((pre) =&gt; &#123; return &#123; count: pre.count + step, &#125; &#125;) &#125; render() &#123; let &#123; count &#125; = this.state return &lt;button onClick=&#123;this.increase&#125;&gt;click &#123;count&#125; times&lt;/button&gt; &#125;&#125;export default ButtonCounter 1234567891011121314151617181920212223242526272829import React from &#x27;react&#x27;class ButtonCounter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0, &#125; &#125; increase = () =&gt; &#123; let &#123; step &#125; = this.props this.setState((pre) =&gt; &#123; return &#123; count: pre.count + step, &#125; &#125;) &#125; render() &#123; let &#123; count &#125; = this.state return &lt;div onMouseLeave=&#123;this.increase&#125;&gt;click &#123;count&#125; times&lt;/div&gt; &#125;&#125;export default ButtonCounter 使用 HOC 进行改造HOC 通过传入的组件，返回一个新的组件。 12345678910111213import React from &#x27;react&#x27;const withCounter = (OriginalComponent) =&gt; &#123; class newComponent extends React.Component &#123; render() &#123; return &lt;OriginalComponent /&gt; &#125; &#125; return newComponent&#125;export default withCounter 将 counter 中的方法放到 HOC 中1234567891011121314151617181920212223242526272829303132333435363738import React from &#x27;react&#x27;const withCounter = (OriginalComponent, step) =&gt; &#123; // 将step从props中抽离出来 class newComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0, &#125; &#125; increase = () =&gt; &#123; this.setState((pre) =&gt; &#123; return &#123; count: pre.count + step, &#125; &#125;) &#125; render() &#123; let &#123; count &#125; = this.state return ( &lt;OriginalComponent increase=&#123;this.increase&#125; count=&#123;count&#125; &#123;...this.props&#125; /&gt; ) &#125; &#125; return newComponent&#125;export default withCounter 12345678910111213import React from &#x27;react&#x27;import withCounter from &#x27;../util/withCounter&#x27;class ButtonCounter extends React.Component &#123; render() &#123; let &#123; increase, count &#125; = this.props return &lt;button onClick=&#123;increase&#125;&gt;click &#123;count&#125; times&lt;/button&gt; &#125;&#125;export default withCounter(ButtonCounter, 2)","tags":["React","HOC"],"categories":["React"]},{"title":"防抖与节流","path":"/2020/07/30/防抖与节流/","content":"防抖浏览器中有的事件触发非常频繁，如果在事件触发的时候就调用，这时就会不断地产生新的调用，导致变‘卡’。防抖就是在某段时间间隔内，不调用函数，直到一段时间后不在再新的事件触发，再调用函数；或者是先调用函数，在一段时间间隔内继续触发不再重复调用函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let times = 0let container = document.querySelector(&#x27;#container&#x27;)let button = document.querySelector(&#x27;#cancel&#x27;)function getUserAction() &#123; // do some thing container.innerHTML = `run $&#123;++times&#125; time(s).`&#125;/** * * @param &#123;function(): *&#125; func * @param &#123;number&#125; wait * @param &#123;boolean&#125; immediate * @returns &#123;function(): *&#125; */function debounce(func, wait, immediate) &#123; let timer // start a new timer every time it is triggered let result // get the return from func | undefined(only if the immediate is true will return a value) let debounced = function () &#123; let context = this // current context let args = arguments // events if (timer) &#123; clearTimeout(timer) &#125; if (immediate) &#123; // check whether it is called immediately let callNow = !timer // callNow is always false unless the timer is null timer = setTimeout(() =&gt; &#123; timer = null // set the timer null after wait time &#125;, wait) if (callNow) &#123; // means timer is null now, then call func result = func.apply(context, args) &#125; &#125; else &#123; timer = setTimeout(() =&gt; &#123; // 1. bind the `this` to `&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;` // 2. get the `event` func.apply(context, args) &#125;, wait) &#125; return result &#125; debounced.cancel = function () &#123; // to cancel the debounce clearTimeout(timer) timer = null // reset to null &#125; return debounced&#125;let userAction = debounce(getUserAction, 5000, true) // get the function `debounced`container.onmousemove = userActionbutton.onclick = function () &#123; userAction.cancel()&#125; 节流如果持续触发事件，那么每固定时间内只触发一次事件。实现方式可以使用时间戳，或者定时器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let times = 0let container = document.querySelector(&#x27;#container&#x27;)let button = document.querySelector(&#x27;#cancel&#x27;)function getUserAction() &#123; // do some thing container.innerHTML = `run $&#123;++times&#125; time(s).`&#125;function throttle( func, wait, options = &#123; leading: true, // run immediately trailing: true, // run after wait time &#125;,) &#123; let timer let context let args let previous = 0 let later = function () &#123; previous = !options.leading ? 0 : new Date().getTime() timer = null func.apply(context, args) context = args = null &#125; let throttled = function () &#123; let now = new Date().getTime() if (!previous &amp;&amp; !options.leading) previous = now let remaining = wait - (now - previous) context = this args = arguments if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timer) &#123; clearTimeout(timer) timer = null &#125; previous = now func.apply(context, args) if (!timer) context = args = null &#125; else if (!timer &amp;&amp; options.trailing) &#123; timer = setTimeout(later, remaining) &#125; &#125; throttled.cancel = function () &#123; clearTimeout(timer) previous = 0 timer = null &#125; return throttled&#125;let userAction = throttle(getUserAction, 5000, &#123; leading: true, trailing: false,&#125;)// let userAction = throttle(getUserAction, 5000, &#123;leading: false, trailing: true&#125;)container.onmousemove = userActionbutton.onclick = userAction.cancel","tags":["JavaScript","ES6"],"categories":["ECMAScript"]},{"title":"创建对象的多种方式","path":"/2020/07/29/创建对象的多种方式/","content":"Factory缺点：对象无法区分，所有的实例指向一个原型 12345678910111213function Person(name) &#123; let o = new Object() o.name = name o.getName = function () &#123; return this.name &#125; return o&#125;let person = new Person(&#x27;Edward&#x27;)console.log(person instanceof Person) // falseconsole.log(person instanceof Object) // true Constructor缺点：每次创建实例时，每个方法需要被创建一次。 1234567function Person(name) &#123; this.name = name this.getName = function () &#123; // create function return this.name &#125;&#125; Prototype缺点： 所有的属性和方法都共享 不能初始化值 12345678function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: &#x27;Edward&#x27;, getName: function () &#123; return this.name &#125;,&#125; Constructor &amp; Prototype12345678910function Person(name) &#123; this.name = name&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; return this.name &#125;,&#125; Safe constructor没有公共属性，方法也不使用this对象，无法识别对象所属类型。 1234567891011121314function Person(name) &#123; let o = new Object() o.name = name o.getName = function () &#123; return name // formal parameter &#125; return o&#125;let person = new Person(&#x27;Edward&#x27;)console.log(person.getName()) // Edwardperson.name = &#x27;Jack&#x27;console.log(person.getName()) // also Edward","tags":["JavaScript","ES6"],"categories":["ECMAScript"]},{"title":"词法作用域与动态作用域","path":"/2020/07/28/词法作用域与动态作用域/","content":"JavaScript 采用的是词法作用域（lexical scoping）JavaScript 函数的作用域在函数定义的时候就确定了，所以实际使用的值与函数定义位置有关系。 123456789101112let value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; let value = 2 foo()&#125;bar() // 1 上面这个例子中，foo函数中的value向上寻找为在全局定义的1，所以会打印出1。 1234567891011value=1function foo()&#123; echo $value&#125;function bar() &#123; local value=2 foo&#125;bar #2 而在bash中，由于是动态作用域，所以会打印出2。 一个例子输出的都会是local。 1234567891011let text = &#x27;global&#x27;let foo = () =&gt; &#123; let text = &#x27;local&#x27; let f = () =&gt; text return f() // return f&#125;console.log(foo()) // local// console.log(foo()()) // local","tags":["JavaScript","ES6"],"categories":["ECMAScript"]},{"title":"RegExp断言","path":"/2020/07/24/RegExp断言/","content":"先行断言 lookahead assertion：x在y之前才匹配，格式为/x(?=y)/ negative lookahead assertion：只有x不在y之前才匹配，格式为/x(?!y)/ 1234let str = &#x27;now is 02:11:44&#x27;/\\d+(?=:)/.exec(str) // [&#x27;02&#x27;]/\\d+(?!\\.)/.exec(str) // [&#x27;0&#x27;] 后行断言 lookbehind assertion：x只有在y后面才匹配，格式为/(?&lt;=y)x/ negative lookbehind assertion：只有x不在y后面才匹配，格式为/(?&lt;!y)x/ 1234let str = &#x27;now is 02:11:44&#x27;/(?&lt;=:)\\d+/.exec(str) // [&#x27;11&#x27;]/(?&lt;!:)\\d+/.exec(str) // [&#x27;02&#x27;]","categories":["ECMAScript"]},{"title":"ECMAScript新增String方法","path":"/2020/07/24/ECMAScript新增String方法/","content":"ES2017 新增padStart(), padEnd()字符串补全功能，接受两个参数，如果第二个参数为空，则默认使用空格补全。 123456// fill with the template&#x27;12&#x27;.padStart(3, &#x27;000&#x27;) // &#x27;012&#x27;&#x27;12&#x27;.padEnd(3, &#x27;000&#x27;) // &#x27;120&#x27;// fill with space&#x27;12&#x27;.padStart(4) // &#x27; 12&#x27; ES2019 新增trimStart(), trimEnd()与String.trim()的行为一致，不会修改原字符串。 1234567let str = &#x27; string &#x27;// str.trimLeft()str.trimStart() // &#x27;string &#x27;// str.trimRight()str.trimEnd() // &#x27; string&#x27;","tags":["整理"],"categories":["ECMAScript"]},{"title":"绘制不同颜色","path":"/2020/06/22/WebGL绘制不同颜色/","content":"绘制过程 执行 Vertex Shader，配置顶点。 调用gl.drawArrays()，装配图形。 光栅化，将图形转换为 Fragment。 执行 Fragment Shader。 代码实现使用varying标识符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const vShaderSource = ` attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; void main() &#123; gl_Position = a_Position; gl_PointSize = 10.0; v_Color = a_Color; &#125;`const fShaderSource = ` precision mediump float; varying vec4 v_Color; void main() &#123; gl_FragColor = v_Color; &#125;`const main = () =&gt; &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) return let n = initVertexBuffers(gl) if (n &lt; 0) return gl.clearColor(0, 0, 0, 1) gl.clear(gl.COLOR_BUFFER_BIT) // gl.drawArrays(gl.LINE_LOOP, 0, n); gl.drawArrays(gl.TRIANGLES, 0, n)&#125;const initVertexBuffers = (gl) =&gt; &#123; let verticesColor = new Float32Array([ // [x, y, r, g, b] 0, 0.5, 1, 0, 0, -0.5, -0.5, 0, 1, 0, 0.5, -0.5, 0, 0, 1, ]) let n = 3 let vertexColorBuffer = gl.createBuffer() if (!vertexColorBuffer) return -1 gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer) gl.bufferData(gl.ARRAY_BUFFER, verticesColor, gl.STATIC_DRAW) const SIZE = verticesColor.BYTES_PER_ELEMENT let a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;) let a_Color = gl.getAttribLocation(gl.program, &#x27;a_Color&#x27;) gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, SIZE * 5, 0) gl.enableVertexAttribArray(a_Position) gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, SIZE * 5, SIZE * 2) gl.enableVertexAttribArray(a_Color) return n&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"制作动画","path":"/2020/06/20/WebGL制作动画/","content":"绘制流程 计算变换后的位置坐标。 清空画板。 绘制 循环 1-3 操作。 代码实现使用库函数简化数学计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_ModelMatrix; void main() &#123; gl_Position = u_ModelMatrix * a_Position; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); &#125;`const main = () =&gt; &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn let n = initVertexBuffers(gl) if (n &lt; 0) return gl.clearColor(0, 0, 0, 1) rotating(gl, n, 360)&#125;const rotating = (gl, n, ANGLE_STEP = 30) =&gt; &#123; let currentAngle = 0 let modelMatrix = new Matrix4() let u_ModelMatrix = gl.getUniformLocation(gl.program, &#x27;u_ModelMatrix&#x27;) let tick = function () &#123; currentAngle = animate(currentAngle, ANGLE_STEP) draw(gl, n, currentAngle, modelMatrix, u_ModelMatrix) requestAnimationFrame(tick) &#125; tick()&#125;const draw = (gl, n, currentAngle, modelMatrix, u_ModelMatrix) =&gt; &#123; modelMatrix.setRotate(currentAngle, 0, 0, 1) // Set rotation matrix. // modelMatrix.translate(0.5, 0, 0); gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements) gl.clear(gl.COLOR_BUFFER_BIT) // Clear canvas. gl.drawArrays(gl.TRIANGLES, 0, n) // Draw triangle.&#125;let g_last = Date.now()/** * Get the new angle. * @param currentAngle &#123;number&#125; * @param ANGLE_STEP &#123;number&#125; * @returns &#123;number&#125; */const animate = (currentAngle, ANGLE_STEP) =&gt; &#123; let now = Date.now() let temp = now - g_last g_last = now return (currentAngle + (ANGLE_STEP * temp) / 1000) % 360&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"使用矩阵进行变换","path":"/2020/06/19/WebGL使用矩阵进行变换/","content":"WebGL 中的矩阵是列主序的。 平移变换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_xFormMatrix; void main() &#123; gl_Position = u_xFormMatrix * a_Position; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`const Tx = 0.5, Ty = 0.2, Tz = 0function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn let n = initVertexBuffers(gl) if (n &lt; 0) return let xFormMatrix = new Float32Array([ 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, Tx, Ty, Tz, 1.0, ]) let u_xFormMatrix = gl.getUniformLocation(gl.program, &#x27;u_xFormMatrix&#x27;) gl.uniformMatrix4fv(u_xFormMatrix, false, xFormMatrix) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES, 0, n)&#125; 旋转变换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_xFormMatrix; void main() &#123; gl_Position = u_xFormMatrix * a_Position; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`const ANGLE = 30function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn let n = initVertexBuffers(gl) if (n &lt; 0) return let radian = (Math.PI * ANGLE) / 180.0 let sinB = Math.sin(radian), cosB = Math.cos(radian) let xFormMatrix = new Float32Array([ // column major order cosB, sinB, 0, 0, -sinB, cosB, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, ]) let u_xFormMatrix = gl.getUniformLocation(gl.program, &#x27;u_xFormMatrix&#x27;) gl.uniformMatrix4fv(u_xFormMatrix, false, xFormMatrix) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES, 0, n)&#125; 缩放变换缩放矩阵： $$\\begin{bmatrix} x’ \\ y’ \\ z’ \\ 1 \\\\end{bmatrix} &#x3D;\\begin{bmatrix} Sx &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; Sy &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; Sz &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix} ×\\begin{bmatrix} x \\ y \\ z \\ 1 \\\\end{bmatrix}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_xFormMatrix; void main() &#123; gl_Position = u_xFormMatrix * a_Position; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`const Sx = 1.0, Sy = 1.5, Sz = 1.0function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn let n = initVertexBuffers(gl) if (n &lt; 0) return let xFormMatrix = new Float32Array([ Sx, 0, 0, 0, 0, Sy, 0, 0, 0, 0, Sz, 0, 0, 0, 0, 1, ]) let u_xFormMatrix = gl.getUniformLocation(gl.program, &#x27;u_xFormMatrix&#x27;) gl.uniformMatrix4fv(u_xFormMatrix, false, xFormMatrix) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES, 0, n)&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"图像旋转","path":"/2020/06/19/WebGL图像旋转/","content":"旋转原理将 WebGL 坐标系转为极坐标，然后通过角度计算得出旋转后的左标位置。旋转矩阵： $$\\begin{bmatrix} x’ \\ y’ \\ z’ \\ 1 \\\\end{bmatrix} &#x3D;\\begin{bmatrix} \\cos \\beta &amp; -\\sin \\beta &amp; 0 &amp; 0 \\ \\sin \\beta &amp; \\cos \\beta &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix} ×\\begin{bmatrix} x \\ y \\ z \\ 1 \\\\end{bmatrix}$$ 代码实现使用u_SinBCosB存放SinB与CosB。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 2d rotate * x&#x27; = x * cosB - y * sinB * y&#x27; = x * sinB + y * cosB * z&#x27; = z */const vShaderSource = ` attribute vec4 a_Position; uniform vec2 u_SinBCosB; void main() &#123; gl_Position.x = a_Position.x * u_SinBCosB.y - a_Position.y * u_SinBCosB.x; gl_Position.y = a_Position.x * u_SinBCosB.x + a_Position.y * u_SinBCosB.y; gl_Position.z = a_Position.z; gl_Position.w = 1.0; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`let ANGLE = 30.0function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) return let n = initVertexBuffers(gl) if (n &lt; 0) return let radian = (Math.PI * ANGLE) / 180.0 // Transform to radian. let SinB = Math.sin(radian) let CosB = Math.cos(radian) let u_SinBCosB = gl.getUniformLocation(gl.program, &#x27;u_SinBCosB&#x27;) gl.uniform2f(u_SinBCosB, SinB, CosB) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES, 0, n)&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"图像位移","path":"/2020/06/18/WebGL图像位移/","content":"位移原理与在普通的坐标系中一样，只需在需要位移的坐标位置加入相应的矢量即可。(x1, y1, z1, w1) + (x2, y2, z2, w2) -&gt; (x1 + x2, y1 + y2, z1 + z2, w1 + w2)平移矩阵： $$\\begin{bmatrix} x’ \\ y’ \\ z’ \\ 1\\end{bmatrix} &#x3D;\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; Tx \\ 0 &amp; 1 &amp; 0 &amp; Ty \\ 0 &amp; 0 &amp; 1 &amp; Tz \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix} ×\\begin{bmatrix} x \\ y \\ z \\ 1 \\\\end{bmatrix}$$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// position = P + ▲Pconst vShaderSource = ` attribute vec4 a_Position; uniform vec4 u_Translation; void main() &#123; gl_Position = a_Position + u_Translation; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`// Displacementconst Tx = 0.4, Ty = -0.2, Tz = 0.3Tw = 0.0function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) return let n = initVertexBuffers(gl) if (n &lt; 0) return let u_Translation = gl.getUniformLocation(gl.program, &#x27;u_Translation&#x27;) gl.uniform4f(u_Translation, Tx, Ty, Tz, Tw) gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.TRIANGLES, 0, n)&#125;function initVertexBuffers(gl) &#123; let vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]) let n = vertices.length / 2 let vertexBuffer = gl.createBuffer() if (!vertexBuffer) &#123; console.log(&#x27;failed to create buffer&#x27;) return -1 &#125; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer) gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW) let a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;) gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0) gl.enableVertexAttribArray(a_Position) return n&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"绘制多个点","path":"/2020/06/18/WebGL绘制多个点/","content":"绘制步骤 创建顶点数组。 创建一个 Buffer。 将 WebGL 的 ARRAY_BUFFER 指向所创建的 Buffer。 将顶点数组赋值到 Buffer 中。 将 Buffer 分配给 Vertex Shader 中的 Attribute。 让 Vertex Shader 访问 Buffer。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const vShaderSource = ` attribute vec4 a_Position; void main() &#123; gl_Position = a_Position; gl_PointSize = 5.0; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;) if (!initShaders(gl, vShaderSource, fShaderSource)) &#123; return &#125; let n = initVertexBuffers(gl) if (n &lt; 0) &#123; console.log(&#x27;failed to set positions&#x27;) return &#125; gl.clearColor(0.0, 0.0, 0.0, 1.0) gl.clear(gl.COLOR_BUFFER_BIT) gl.drawArrays(gl.POINTS, 0, n) // (type, first, count = n)&#125;function initVertexBuffers(gl) &#123; let vertices = new Float32Array([ // Create points array. 0.0, 0.5, -0.5, -0.5, 0.5, -0.5, ]) let n = vertices.length / 2 // Compute the n. let vertexBuffer = gl.createBuffer() // Create buffer. if (!vertexBuffer) &#123; console.log(&#x27;failed to create buffer&#x27;) return -1 &#125; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer) // Bind buffer. gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW) // Draw data into buffer. let a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;) // size = 2 because of the [x, y] components gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0) // Set data into &#x27;a_Position&#x27;. gl.enableVertexAttribArray(a_Position) // Link attribute and Buffer. return n&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"绘制点","path":"/2020/06/17/绘点/","content":"ShaderWebGL 使用两种 Shader： Vertex Shader：用于描述 point 的特性。 Fragment Shader：用于逐片处理。 Shader Program 使用的是 GLSL ES 语言，在 JS 中需要使用字符串编写，再通过函数加载进去。 WebGL 的执行流程大致为： Get canvas. Get WebGL context. Initialize vertex shader and fragment shader. Set clear color. Clear canvas. Draw. vec4在 GLSL ES 中，vec4类型用四维适量描述一个点的三维空间投影，(x, y, z, w)等价与三维空间的(x / w, y / w, z / w)。WebGL 坐标系统水平向右为 x 正轴，竖直向上为 y 正轴，垂直屏幕向外为 z 正轴。范围都在[-1, 1]之间。 使用 onmousedown 搭配 WebGL 进行图像绘制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const vShaderSource = ` attribute vec4 a_Position; attribute float a_PointSize; void main() &#123; gl_Position = a_Position; gl_PointSize = a_PointSize; &#125;`const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`function main() &#123; const canvas = document.querySelector(&#x27;#canvas&#x27;) const gl = canvas.getContext(&#x27;webgl&#x27;) if (!gl) &#123; console.log(&#x27;failed to initialize context for WebGL&#x27;) return &#125; if (!initShaders(gl, vShaderSource, fShaderSource)) &#123; // initialize program console.log(&#x27;failed to initialize shaders.&#x27;) return &#125; const a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;) if (a_Position &lt; 0) &#123; console.log(&#x27;failed to get the storage location of a_Position&#x27;) return &#125; const a_PointSize = gl.getAttribLocation(gl.program, &#x27;a_PointSize&#x27;) gl.vertexAttrib1f(a_PointSize, 5.0) // set the &#x27;attribute float a_PointSize&#x27; // canvas.onmousemove = function (event) &#123; canvas.onmousedown = function (event) &#123; click(event, gl, canvas, a_Position) &#125; gl.clearColor(0.0, 0.0, 0.0, 1) gl.clear(gl.COLOR_BUFFER_BIT)&#125;let g_points = []function click(event, gl, canvas, a_Position) &#123; let x = event.clientX let y = event.clientY let rect = event.target.getBoundingClientRect() // toggle the domain of points x, y to [-1, 1] x = (x - rect.left - canvas.width / 2) / (canvas.width / 2) y = (canvas.height / 2 - (y - rect.top)) / (canvas.height / 2) g_points.push(x) g_points.push(y) gl.clear(gl.COLOR_BUFFER_BIT) for (let i = 0, len = g_points.length; i &lt; len; i += 2) &#123; gl.vertexAttrib3f(a_Position, g_points[i], g_points[i + 1], 0) // set x, y gl.drawArrays(gl.POINTS, 0, 1) &#125;&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"美股再次熔断","path":"/2020/03/13/美股再次熔断/","content":"开盘受挫 开盘后，标普 500 指数跌幅扩大至 7%，触发本周第二次熔断，美股暂停交易 15 分钟。而加拿大多伦多证交所暂停股票交易，股指跌 9.17%，触发一级市场熔断。 恢复交易后，三大指数进一步下跌，道指一度下挫 2100 点。波音下跌 15.4%，仅仅一个月时间，市值腰斩。巴里克黄金 10.2%，特斯拉跌 9.4%。美股邮轮股大跌，挪威邮轮跌超 30%，皇家加勒比邮轮跌超 25%。 今天，美股期货连续出现熔断，早间，纳斯达克指数期货就跌至 7600 点触发熔断，跌幅超 5%。下午标普 500 指数期货跌超 5%，也触发交易限制。 今日，标普 500 期货、道指期货、纳指期货均跌超 5%，再度触发熔断。据不完全统计，除了美股期指外，日内还有泰国股市、菲律宾股市、韩国股市、巴基斯坦股市、印尼股市、巴西股市，加拿大股市 8 个国家股市发生熔断。巴西股市触发二级熔断 欧洲央行维持三大关键利率不变欧洲央行公布 3 月会议的利率决议，其中，欧洲央行是否会追随美联储和英国央行的步伐进行降息成为最大看点，今日，欧洲央行宣布，维持三大关键利率不变，其中，维持基准利率在 0.000%不变，将存款利率维持在-0.500%不变。此前市场预期降息 10 个基点。 比特币跌破 5000,24h 涨幅-40%北京时间 13&#x2F;03&#x2F;2020 7:30am，BTC 跌破 5000 美元。短线来看 BTC 的避险属性几乎为零。 比特币跌破 4000,24h 涨幅-47%北京时间 13&#x2F;03&#x2F;2020 10:15am","tags":["history"]},{"title":"美股熔断","path":"/2020/03/10/美股熔断/","content":"股市停止跳动美国股市有熔断制度： 当大盘跌幅达到-7%的时候，触发 1 级熔断，美国证券市场停止交易 15 分钟。 当大盘跌幅达到-13%的时候，触发 2 级熔断，美国证券市场再停止交易 15 分钟。 当大盘跌幅达到-20%的时候，触发 3 级熔断，当天直接停盘，不再交易。 这是自颁布以来，继 1997&#x2F;10&#x2F;27 之后的第二次熔断。主要的原因很有可能是石油大国之间的价格战争。 石油减产协议 2020&#x2F;3&#x2F;6，欧佩克和俄罗斯谈崩，无法达成减产 150 万&#x2F;日的协议。 2020&#x2F;3&#x2F;7，沙特发出增产公告，并大幅度调整官方油价，俄罗斯也应战，增加石油产量。 周一开盘，国际油价暴跌 30%，危机情绪加大，引发各国股市大幅震荡。","tags":["history"]},{"title":"TypeScript Type Compatibility","path":"/2020/03/06/TypeScript-Type-Compatibility/","content":"Introduction123456789interface A &#123;text: string;&#125;class B &#123;text: string;&#125;let a: A = new B(); // no error At least same member1234567891011interface A &#123;text: string;&#125;function foo(obj: &#123; text: string &#125;): string &#123;return obj.text;&#125;let obj = &#123;text: &#x27;some text&#x27;, num: 3&#125;;let a: A = obj; // successfoo(obj); // success Functions1234567891011let a = (a: number) =&gt; a;let b = (a: number, b: number) =&gt; a + b;b = a; // successa = b; // errorlet x = () =&gt; (&#123;text: &#x27;some text&#x27;&#125;);let y = () =&gt; (&#123;text: &#x27;some text&#x27;, num: 3&#125;);x = y; // successy = x; // error Classes12345678910111213141516171819class Animal &#123;feet: number;constructor(name: string, numFeet: number) &#123;&#125;&#125;class Size &#123;feet: number;constructor(name: string, numFeet: number) &#123;&#125;&#125;let a: Animal;let b: Size;a = b; // successb = a; // success Generics123456789101112131415interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;string&gt;;let y: Empty&lt;number&gt;;x = y; // successinterface T&lt;T&gt; &#123;data: T;&#125;let x1: T&lt;string&gt;;let x2: T&lt;number&gt;;x1 = x2; // error","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Enums","path":"/2020/03/05/TypeScript-Enums/","content":"Numeric enums123456789101112enum Direction &#123;UP,DOWN,LEFT,RIGHT&#125;function move(length: number, direction: Direction): void &#123;console.log(`move: $&#123;direction&#125; $&#123;length&#125;meters.`);&#125;move(10, Direction.UP); String enums123456enum Direction &#123;UP=&#x27;UP&#x27;,DOWN=&#x27;DOWN&#x27;,LEFT=&#x27;LEFT&#x27;,RIGHT=&#x27;RIGHT&#x27;&#125; Heterogeneous enums1234enum E &#123;yes,no = &#x27;no&#x27;&#125; Computed members1234567enum E &#123;None,Read = 1 &lt;&lt; 1,Write = 1 &lt;&lt; 2,ReadWrite = Read | Write,L = &#x27;1234&#x27;.length&#125; Union enums and enum member types12345678910111213141516enum Kind &#123;Square,Circle&#125;interface Circle &#123;kind: Kind.Circle,radius: number&#125;interface Square &#123;kind: Kind.Square,length: number&#125;let c: Circle = &#123;kind: Kind.Circle, radius: 5&#125;; Enums at runtime123456789enum E &#123;X, Y, Z&#125;function f(obj: &#123; X: number &#125;) &#123;return obj.X;&#125;f(E); // work Enums at compile time1234567891011121314enum LogLevel &#123;ERROR, WARN, INFO, DEBUG&#125;type LogLevelString = keyof typeof LogLevel;function print(key: LogLevelString, message: string): void &#123;const num = LogLevel[key];if (num &lt;= LogLevel.WARN) &#123;console.log(`$&#123;key&#125;-$&#123;num&#125;-$&#123;message&#125;`);&#125;&#125;print(&#x27;WARN&#x27;, &#x27;warning&#x27;); Reverse mappings123456enum E &#123;A&#125;let a = E.A;let getName = E[a]; // &#x27;A&#x27;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Generics","path":"/2020/03/04/TypeScript-Generics/","content":"Generics12345678function foo&lt;T&gt;(arg: T): T &#123;return arg;&#125;function len&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;console.log(arg.length);return arg;&#125; Generics Types1234567891011function foo&lt;T&gt;(arg: T): T &#123;return arg;&#125;interface fooInterface&lt;T&gt; &#123;(arg: T): T;&#125;let myFunction: &lt;T&gt;(arg: T) =&gt; T = foo;let otherFunction: &#123; &lt;T&gt;(arg: T): T &#125; = foo;let interfaceFunction: fooInterface&lt;number&gt; = foo; Generics Classes123456789101112131415161718class GenericsNumber&lt;T&gt; &#123;zeroValue: T;add: (x: T, y: T) =&gt; T;&#125;let number = new GenericsNumber&lt;number&gt;();number.zeroValue = 0;number.add = function (x, y) &#123;return x + y;&#125;;let string = new GenericsNumber&lt;string&gt;();string.zeroValue = &#x27;&#x27;;string.add = function (x, y) &#123;return x + y;&#125;;console.log(string.add(string.zeroValue, &#x27;test&#x27;)); Generics Constraints12345678interface Lengthwise &#123;length: number;&#125;function foo&lt;T extends Lengthwise&gt;(arg: T): T &#123;console.log(arg.length);return arg;&#125; Using Type Parameters in Generic Constraints1234567function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;return obj[key];&#125;let obj = &#123;a: 1, b: 2, c: 3, d: 4&#125;;console.log(getProperty(obj, &#x27;a&#x27;));console.log(getProperty(obj, &#x27;e&#x27;)); // error Using Class Types in Generics12345678910111213141516171819202122232425262728293031323334353637function create&lt;T&gt;(c: &#123; new(): T &#125;): T &#123;return new c();&#125;class BeeKeeper &#123;constructor(private hasMask: boolean = false) &#123;&#125;&#125;class ZooKeeper &#123;constructor(private nameTag: string = &#x27;undefined&#x27;) &#123;&#125;&#125;class Animal &#123;constructor(private numLegs: number = 0) &#123;&#125;&#125;class Bee extends Animal &#123;constructor(num: number, public keeper: BeeKeeper) &#123;super(num);&#125;&#125;class Lion extends Animal &#123;constructor(num: number, public keeper: ZooKeeper) &#123;super(num);&#125;&#125;function createInstance&lt;A extends Animal&gt;(c: new (x, y) =&gt; A, numLegs: number, keeper: any): A &#123;return new c(numLegs, keeper);&#125;console.log(createInstance(Bee, 2, new BeeKeeper(true)));console.log(createInstance(Lion, 4, new ZooKeeper(&#x27;lion&#x27;)));","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Functions","path":"/2020/03/03/TypeScript-Functions/","content":"Function TypesTyping the function1234567function foo(x: number, y: string): string &#123;return x + y;&#125;let fo = function (x: number, y: string): string &#123;return x + y;&#125;; Writing the function type123let foo: (x: number, y: string) =&gt; string = function (x: number, y: string): string &#123;return x + y;&#125;; Inferring types123let foo: (x: number, y: string) =&gt; string = function (x, y) &#123;return x + y;&#125; Optional and Default Parameters12345678910111213141516171819202122232425function getName(firstName: string, lastName?: string): string &#123;if (lastName) &#123;return firstName + &#x27; &#x27; + lastName;&#125; else &#123;return firstName;&#125;&#125;getName(&#x27;Edward&#x27;);getName(&#x27;Edison&#x27;, undefined);getName(&#x27;Jack&#x27;, &#x27;Li&#x27;);getName(&#x27;Jack&#x27;, &#x27;R&#x27;, &#x27;Li&#x27;); // error, too many parameters.function buildName(firstName: string, lastName: string = &#x27;Li&#x27;): string &#123;if (lastName) &#123;return firstName + &#x27; &#x27; + lastName;&#125; else &#123;return firstName;&#125;&#125;buildName(&#x27;Edward&#x27;);buildName(&#x27;Edison&#x27;, undefined);buildName(&#x27;Jack&#x27;, &#x27;Li&#x27;);buildName(&#x27;Jack&#x27;, &#x27;R&#x27;, &#x27;Li&#x27;); // error, too many parameters. Rest Parameters123456function buildName(firstName: string, ...restOfName: string[]): string &#123;return firstName + &#x27; &#x27; + restOfName.join(&#x27; &#x27;);&#125;let buildNameFun: (firstName: string, ...restOfName: string[]) =&gt; string = buildName;console.log(buildName(&#x27;Jack&#x27;, &#x27;R&#x27;, &#x27;Chen&#x27;)); this and arrow functions12345678910111213141516let deck = &#123;suits: [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;],cards: Array(52),createCardPicker: function () &#123;// NOTE: The arrow function allowing us to capture &#x27;this&#x27; right herereturn () =&gt; &#123;let pickedCard = Math.floor(Math.random() \\* 52);let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125;&#125;&#125;;console.log(deck.createCardPicker()()); this parameters123456789101112131415161718192021222324252627interface Card &#123;suit: string;card: number;&#125;interface Deck &#123;suits: string[];cards: number[];createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123;suits: [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;],cards: Array(52),createCardPicker: function (this: Deck) &#123;return () =&gt; &#123;let pickedCard = Math.floor(Math.random() \\* 52);let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125;&#125;&#125;;console.log(deck.createCardPicker()()) Overloads1234567891011121314151617181920let suits = [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;];function pickCard(x: &#123; suit: string, card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string, card: number &#125;;function pickCard(x): any &#123;if (typeof x == &#x27;object&#x27;) &#123;let pickedCard = Math.floor(Math.random() \\* x.length);return pickedCard;&#125; else if (typeof x == &#x27;number&#x27;) &#123;let pickedSuit = Math.floor(x / 13);return &#123;suit: suits[pickedSuit], card: x % 13&#125;;&#125;&#125;let myDeck = [&#123;suit: &quot;diamonds&quot;, card: 2&#125;, &#123;suit: &quot;spades&quot;, card: 10&#125;, &#123;suit: &quot;hearts&quot;, card: 4&#125;];let pickedCard1 = myDeck[pickCard(myDeck)];console.log(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);let pickedCard2 = pickCard(35);console.log(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Classes","path":"/2020/02/29/TypeScript-Classes/","content":"Classes1234567891011class Greeter &#123;greeting: string;constructor(message: string) &#123;this.greeting = message;&#125;greet(): string &#123;return &#x27;Hello, &#x27; + this.greeting;&#125;&#125; Private123456789101112131415161718192021class Animal &#123;constructor(private name: string) &#123;&#125;&#125;class Horse extends Animal &#123;constructor() &#123;super(&#x27;Horse&#x27;);&#125;&#125;class Human &#123;constructor(private name: string) &#123;&#125;&#125;let animal = new Animal(&#x27;Lucy&#x27;);let horse = new Horse();let human = new Human(&#x27;Jack&#x27;);animal = horse; // successanimal = human; // failed Protected123456789101112131415161718192021222324class Person &#123;protected name: string;protected constructor(name: string) &#123;this.name = name;&#125;&#125;class Employee extends Person &#123;private department: string;constructor(name: string, department: string) &#123;super(name);this.department = department;&#125;public getInfo(): string &#123;return `name: $&#123;this.name&#125;, department: $&#123;this.department&#125;`&#125;&#125;let Edward = new Employee(&#x27;Edward&#x27;, &#x27;front-end&#x27;);let person = new Person(&#x27;Jack&#x27;); // failedconsole.log(Edward.getInfo()); Readonly modifier12345678910class C &#123;readonly name: string;readonly length: number = 8;constructor(name: string) &#123;this.name = name;&#125;&#125;new C(&#x27;test&#x27;).name = &#x27;test1&#x27;; // failed Accessors1234567891011121314151617const MAX = 10;class Person &#123;private \\_fullName: string;get fullName(): string &#123;return this.\\_fullName;&#125;set fullName(name: string) &#123;if (name &amp;&amp; name.length &gt; MAX) &#123;throw new Error(&#x27;too long&#x27;);&#125;this.\\_fullName = name;&#125;&#125;new Person().fullName = &#x27;Edward&#x27;; Static Properties123456789101112131415class Point &#123;static origin = &#123;x: 0, y: 0&#125;;constructor(public scale: number) &#123;&#125;calculateDistance(point: &#123; x: number, y: number &#125;): number &#123;let xDist = (point.x - Point.origin.x);let yDist = (point.y - Point.origin.y);return Math.sqrt(xDist ** 2 + yDist ** 2);&#125;&#125;let point1 = new Point(1, 0);console.log(point1.calculateDistance(&#123;10, 20&#125;)); Abstract Classes12345678910111213141516171819202122232425262728abstract class Department &#123;constructor(public name: string) &#123;&#125;printName(): void &#123;console.log(&#x27;name: &#x27; + this.name);&#125;abstract printMeeting(): void;&#125;class AccountingDepartment extends Department &#123;constructor() &#123;super(&#x27;AccountingDepartment&#x27;);&#125;printMeeting(): void &#123;console.log(&#x27;This is Accounting Department&#x27;);&#125;foo(): void &#123;console.log(&#x27;foo&#x27;);&#125;&#125;let department: Department = new Department(); // error: can not create an instance of an abstract classlet department2: Department = new AccountingDepartment();department2.foo(); // error: method doesn&#x27;t exist on declared abstract type Using a class as an interface12345678910class Point &#123;x: number;y: number;&#125;interface point3D extends Point &#123;z: number;&#125;const point: point3D = &#123;x: 0, y: 0, z: 0&#125;;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Interface","path":"/2020/02/26/TypeScript-Interface/","content":"Interface12345678910interface labelValue &#123;label: string;&#125;function printLabel(obj: labelValue): void &#123;console.log(obj.label);&#125;let obj = &#123;size: 10, label: &#x27;some text&#x27;&#125;;printLabel(obj); Optional Properties1234567891011121314interface SquareConfig &#123;color?: string;width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string, area: number &#125; &#123;let defaultSquare = &#123;color: &#x27;White&#x27;, area: 200&#125;;if (config.color) defaultSquare.color = config.color;if (config.width) defaultSquare.area = config.width \\*\\* 2;return defaultSquare;&#125;console.log(createSquare(&#123;color: &#x27;Black&#x27;, width: 30&#125;)); Readonly Properties1234567interface Point &#123;readonly x: number;readonly y: number;&#125;let readOnlyArray: ReadonlyArray&lt;number&gt; = [1, 2, 3, 4];let a: number[] = readOnlyArray as number[]; // readonly array assignment to ordinary array Excess Property Checks1234567interface SquareConfig &#123;color?: string;width?: number;[propName: string]: any;&#125;let newSquare = createSquare(&#123;width: 100, opacity: 0.5&#125; as SquareConfig); Function Types1234567interface foo &#123;(source: string, subString: string): boolean;&#125;let mySearchFunction: foo = function (src, sub) &#123;return src.search(sub) &gt; -1;&#125;; Indexable Types1234567891011121314151617181920interface StringArray &#123;[index: number]: string;&#125;let myArray: StringArray = [&#x27;text1&#x27;, &#x27;text2&#x27;];let text1 = myArray[0];interface NumberDictionary &#123;[index: string]: number;length: number;name: string; // error&#125;interface ReadonlyStringArray &#123;readonly [index: number]: string;&#125;let readonly: ReadonlyStringArray = [&#x27;text1&#x27;, &#x27;text2&#x27;];readonly[2] = &#x27;change&#x27;; // error Class Types12345678910111213141516interface ClockInterface &#123;currentTime: Date;setTime(d: Date);&#125;class Clock implements ClockInterface &#123;constructor(h: number, m: number) &#123;&#125;currentTime: Date;setTime(d: Date) &#123;this.currentTime = d;&#125;&#125; Static sides of class1234567891011121314151617181920212223242526272829303132interface ClockInterface &#123;tick();&#125;interface ClockConstructor &#123;new(hour: number, minute: number): ClockInterface;&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123;constructor(h: number, m: number) &#123;&#125;tick() &#123;console.log(&#x27;tick&#x27;);&#125;&#125;class AnalogClock implements ClockInterface &#123;constructor(h: number, m: number) &#123;&#125;tick() &#123;console.log(&#x27;tick22222&#x27;);&#125;&#125;let digital = createClock(DigitalClock, 12, 0);let analog = createClock(AnalogClock, 12, 1); Extending Interfaces12345678910111213141516interface A &#123;color: string;&#125;interface B &#123;width: number;&#125;interface Square extends A, B &#123;sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = &#x27;white&#x27;;square.width = 2;square.sideLength = 4; Hybrid Types1234567891011121314151617181920212223interface Counter &#123;(start: number): string;interval: number;reset(): void;&#125;function getCounter(): Counter &#123;let counter = (function (start: number) &#123;// some thing&#125;) as Counter;counter.interval = 20;counter.reset = function () &#123;// some thing&#125;;return counter;&#125;let counter = getCounter();counter(10);counter.reset();counter.interval = 10; Interface Extending Classes123456789101112131415161718192021222324252627class Control &#123;private state: any;&#125;interface SelectableControl extends Control &#123;select(): void;&#125;class Button extends Control implements SelectableControl &#123; // subclass of Control &amp; implement the interfaceselect(): void &#123; // from the interface// some thing&#125;&#125;class TextBox extends Control &#123; // subclass of Controlselect(): void &#123; // custom function// some thing&#125;&#125;class Image implements SelectableControl &#123; // just implement the interface, but not the subclass of Controlprivate state: any; // need to add.select(): void &#123;// some thing&#125;&#125;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript 初探","path":"/2020/02/25/TypeScript-初探/","content":"基本类型 boolean:1let done: boolean = true; number:1let count: number = 20; string:1let name = &#x27;Edward Wang&#x27;; array:12let list1: number[] = [1, 2, 3];let list2: Array&lt;number&gt; = [1, 2, 3]; tuple:1let x: [string, number] = [&#x27;test&#x27;, 2]; enum:12345678 enum NUMBER &#123; ONE, TWO, THREE &#125;let a = NUMBER.TWO;let title: string = NUMBER[3]; any: 1234 let x: any = 4; x = &#x27;string&#x27;;let list: any[] = [1, true, &#x27;stirng&#x27;]; void:表示没有返回类型，只能被赋予 null 和 undefined。 1234function warning(): void &#123;console.log(&#x27;warning&#x27;);&#125;let unusable: void = undefined; null &amp; undefined:默认情况下 null 和 undefined 是所有类型的子类型。如果使用了--strictNullChecks标记,null、undefined、void 只能赋值给他们自己。 12let u: undefined = undefined;let n: null = null; never:表示永不存在值的类型。 123function error(message: string): never &#123;throw new Error(message);&#125; object:除 number、string、boolean、symbol、null 或 undefined 之外的类型。 类型断言 &lt;&gt;断言12let text: any = &#x27;some text&#x27;;let strLength = (&lt;string&gt;text).length; as 断言12let text: any = &#x27;some text&#x27;;let strLength = (text as string).length;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"Trump一番话影响经济市场","path":"/2020/01/09/Trump一番话影响经济市场/","content":"川普不对伊朗动武 美股涨 金价回落 油价跳水伊朗袭击美军驻伊拉克基地后，美国总统川普表示将升级经济制裁取代付诸武力。市场乐观情绪上扬，美股上涨，金价回落，油价则大跳水。 川普 1 月 8 日在白宫发表谈话，伊朗袭击并未伤害到任何美国人，称伊朗有所退让，暗示不会对伊朗动武，伊朗外交部长也称该国不寻求升级事态，这些消息都缓解了投资人对美伊局势的不安。 8 日美国股市上涨，道琼工业指数收涨 161.41 点或 0.56%，报 28745.09 点。标普 500 指数收涨 15.87 点或 0.49%，报 3253.05 点。那斯达克指数收涨 60.66 点或 0.67%，报 9129.24 点。费城半导体指数上涨 0.31 点或 0.02%，报 1867.59 点。 那斯达克指数创收盘新高，道琼工业指数、标普 500 指数、费城半导体指数徘回历史次高位。 亚洲股市 9 日也普遍回涨，衡量 6 种主要货币对美元的美元指数上涨 0.33%至 97.01。 而黄金价格原本因市场的避险情绪，8 日一度升穿每英两 1,600 美元，为近七年来首见，但川普总统演讲缓解市场疑虑后，金价迅速回落。 黄金现货下跌近 1%，报每英两 1,559.22 美元，盘中触及 2013 年以来最高的 1,610.90 美元。美国黄金期货收跌 0.9%，结算价报每英两 1,560.20 美元。 OANDA 高级市场分析师 Edward Moya 表示：「可能不会爆发战争，金价因此走低，但其余推动走势的催化剂仍在，黄金价格短期内上看每盎英两 1,640 美元」。 国际油价则在 8 日重挫逾 4%。原本盘中一度飙升至近四个月高点，但中东紧张局势出现缓解迹象，且美国原油库存意外增加，油价随之跳水。 布兰特原油期货下跌 2.83 美元或 4.2%，结算价报每桶 65.44 美元；西德州原油期货下跌 3.09 美元或 4.9%，结算价报每桶 59.61 美元。 美国能源资讯署（EIA）表示，上周原油库存增加 120 万桶，高于市场预期的减少 260 万桶，也高于美国石油协会（API）公布的减少 590 万桶。 BTC 同样也受影响 一小时内下跌$2401&#x2F;8&#x2F;2020 23:49 UTC+8 时间，BTC 价格为$8335.19。1&#x2F;9&#x2F;2020 00:55 UTC+8 时间，BTC 价格为$8095.46。1&#x2F;9&#x2F;2020 03:50 UTC+8 时间，BTC 跌破**$8000，价格为$7992.02。1&#x2F;9&#x2F;2020 04:25 UTC+8 时间，BTC 跌破$7900**，价格为$7887.35。 到日间有所回暖，但随后又开始下跌。","tags":["雜談"]},{"title":"美国确认空袭导致伊朗将军苏莱曼尼死亡","path":"/2020/01/03/美国确认空袭导致伊朗将军苏莱曼尼死亡/","content":"《纽约时报》美国当地时间 1 月 2 日报道说，美国官员确认，在美军对巴格达的一次空袭中，伊朗伊斯兰革命卫队特种部队“圣城旅”部队指挥官卡西姆·苏莱曼尼将军死亡。 《纽约时报》报道，伊朗官方媒体确认了，伊拉克当地时间 3 日，伊朗将军卡西姆·苏莱曼尼在美军对巴格达国际机场一处目标的空袭中死亡。苏莱曼尼是伊朗革命卫队中的重要官员。美国国防部声明表示，美国发动了空袭。 “苏莱曼尼将军积极筹划了对美国在伊拉克及地区的外交官和服务人员的攻击。苏莱曼尼将军和‘圣城旅’需要为美军和联军数百人死亡、数千人受伤负起责任。” 伊朗誓言为苏莱曼尼将军之死报复美国伊朗伊斯兰革命卫队（伊朗武装力量组成部分）前总司令、伊朗确定国家利益委员会秘书长穆赫辛·雷扎伊称，伊朗将为在巴格达死于火箭弹袭击的伊斯兰革命卫队圣城旅指挥官卡西姆·苏莱曼尼将军复仇。 雷扎伊在推特上写道： “殉难的卡西姆·苏莱曼尼去找他的兄弟们了。我们会狠狠报复美国。” 伊斯兰革命卫队圣城旅指挥官卡西姆·苏莱曼尼将军 2 日晚上在巴格达的火箭弹袭击中被炸死，伊拉克什叶派民兵武装“人民动员组织”(Al-Hashd al-Shaabi)的几位高级别成员也一同丧生，12 名伊拉克士兵受伤。 五角大楼称系按照美国总统川普的命令开展对苏莱曼尼的行动。五角大楼称，此次打击旨在预防伊朗方面的袭击，而苏莱曼尼本人涉嫌参与袭击联盟基地和美国驻伊拉克大使馆。","tags":["history"]},{"title":"Telegram批量邀请成员进组","path":"/2019/12/25/Telegram批量邀请成员进组/","content":"TG（目前）最大的需求–宣传前几天在 TG，有个人问我如何实现一个 TG 批量拉人入某个 group。找了找资料发现真的可以实现。 测试了似乎单次最多只能邀请 30 人进组，并且一个人邀请太多人会被禁止单项邀请。TG 还能不进群，直接拉进去，直接获取某个群组的所有 mamber，太 BUG 了 有类似想法的可以联系我，与我交流。","tags":["雜談","Telegram"],"categories":["Telegram"]},{"title":"CNN: 比特币是过去十年最好投资","path":"/2019/12/20/CNN-比特币是过去十年最好投资/","content":"The best investment of the decade turned $1 into $90,000The decade is almost over — and one incredibly volatile investment stood out from all the rest as the best of the 2010s. Want to guess what it was? Bitcoin According to a recent report by Bank of America Securities, if you invested $1 in bitcoin at the start of the decade, it would now be worth more than $90,000. A bitcoin is currently valued at about $7,000. While that’s still significantly below its peak price of just under $20,000 two years ago, it’s substantially higher than the fractions of a penny that one bitcoin cost at the beginning of the Twenty-Teens. Bitcoin remains a highly speculative investment, but it has soared during the past decade as it emerged as the most-popular and widely accepted cryptocurrency. More retailers are accepting bitcoin as a form of payment, and several investment firms and exchanges have launched futures trading for bitcoin, a move that helped legitimize it. And Facebook’s planned launch of the Libra digital currency initiative has also further validated bitcoin and other crytpocurrencies in the minds of many investors. The BofA report lists several other fun facts about what’s been a wild decade for the markets — one that has seen stocks recover from the depths of the Great Recession and hit new highs despite a trade war between the United States and China, attacks on the Federal Reserve by President Trump, Brexit concerns and a slowdown in Europe as well as continued malaise in Japan. Go USA! But hope you avoided Myanmar and GreeceAlthough bitcoin has been the star investment of the 2010s, anybody stuck with a spare kyat — the local currency of Myanmar — won’t be too happy. Ethnic conflicts, violence and instability in the nation formerly known as Burma have left a dollar invested in a kyat at the beginning of the decade worth just 4 tenths of one US cent today. Turning to stocks, Greece was not the word. The Mediterranean nation continued to struggle in the wake of its debt crisis. BofA investment strategists Michael Hartnett and Tommy Ricketts noted in the report that $1 dollar invested in the Greek equity market in 2010 is now worth only 7 cents. The United States was the best stock market in the world, with $1 in American stocks now valued at about $3.46. That’s a gain of nearly 250%. US bonds were also the best performers in fixed income. A 30-year Treasury that was worth $1 in 2010 is now valued at about $2.08. But Greece’s neighbor Turkey had the worst bond of the decade. A dollar in benchmark Turkish bonds at the beginning of 2010 is now worth only 61 cents. And many bonds no longer generate any income for investors at all. Negative interest rates have been good for gold. But oil has languishedSeveral central banks around the globe have slashed interest rates to below zero to try and jumpstart sluggish economies. As a result, BofA said that 2019 had $17 trillion’s worth of sovereign debt sporting a negative yield. In 2010, no bonds had negative yields. Speaking of central banks, it may seem like US Fed chairs Ben Bernanke, Janet Yellen and Jerome Powell have moved interest rates a lot during the past decade. But they have nothing on Brazil. The Brazilian central bank was the most active — with 25 rate cuts and 24 rate hikes since 2010. The Bank of Japan was the quietest central bank. It lowered rates once in the past ten years — to negative territory in 2016. As interest rates have fallen, investors have flocked to gold, which was the top commodity of the 2010s. $1 of gold in 2010 is now worth $1.34. But crude oil was the worst commodity. A dollar’s worth of oil is now valued at just 74 cents. The drop in oil prices, in part because of sluggish demand and more supply from more American shale producers, is a key reason why energy stocks were among the biggest dogs in the S&amp;P 500 during the past decade as well.","categories":["Digital currency"]},{"title":"复旦大学修改章程","path":"/2019/12/18/复旦大学修改章程/","content":"教育部关于同意复旦大学章程部分条款修改的批复 教政法函〔2019〕18 号重点修改如下： 序言第一段“国人自主创办”改为“中国人自主创办”。 序言第二段删去“学校的办学理念是其校歌所传颂的……思想自由……强调以学术精神滋养师生，坚守价值，治学严谨，为学有恒。学校始终秉持团结、服务与牺牲的精神，强调学校、师生的社会责任和国家使命。”增加“敦行爱国奉献……海纳百川、追求卓越。学校倡导‘文明、健康、团结、奋发’的校风和‘刻苦、严谨、求实、创新’的学风，强调坚持理想、探究真理、正谊明道、守护文明。” 序言第三段新增“学校坚持中国共产党的领导，全面贯彻党的教育方针，坚持马克思主义指导地位和社会主义办学方向，扎根中国大地办大学，始终为人民服务，为中国共产党治国理政服务，为巩固和发展中国特色社会主义制度服务，为改革开放和社会主义现代化建设服务。立足中国特色社会主义新时代，学校落实立德树人根本任务，全面履行人才培养、科学研究、社会服务、文化传承创新、国际交流合作的使命……致力于培养德智体美劳全面发展的社会主义建设者和接班人，在实现中华民族伟大复兴的历史进程中建设中国特色世界顶尖大学”。 原章程第四条删去“师生治学、民主管理”，新增“实行中国共产党复旦大学委员会（以下简称党委）领导下的校长负责制”。 原章程第六条“师生依法独立自主开展学术研究”改为“鼓励师生依法自主开展学术研究”；新增“学校营造人心聚学的氛围”。 原章程第八条“独立自主办学”修改为：“自主办学”。 原章程第九条删去“学校实行中国共产党复旦大学委员会（简称学校党委）领导下的校长负责制”，“统一领导学校工作”改为“全面领导学校工作”，“校长独立负责地行使职权”改为“校长依法负责地行使职权”。 原章程第九条（一）新增“（校长）贯彻执行党的教育方针……依靠全校师生员工推动学校科学发展，培养德智体美劳全面发展的社会主义建设者和接班人”。 （二）删去“（支持校长）审定学校基本管理制度”。 （三）新增“坚持党管干部原则，按照干部管理权限负责干部的选拔、教育、培养、考核和监督，讨论决定学校内部组织机构的设置及其负责人的人选，依照有关程序推荐校级领导干部和优秀年轻干部人选，做好老干部工作”。 （四）新增“坚持党管人才原则，讨论决定学校人才工作规划和重大人才政策，创新人才工作体制机制，优化人才成长环境，统筹推进学校教师队伍及其他各类人才队伍建设”。 （五）新增“坚持用习近平新时代中国特色社会主义思想武装师生员工头脑，在师生员工中培育和践行社会主义核心价值观，牢牢掌握学校意识形态工作的领导权、管理权、话语权，维护学校安全稳定，促进和谐校园建设”。 （七）新增“加强学校党委自身建设，加强对学院(系)等基层党组织的领导，做好发展党员和党员教育、管理、服务工作，扩大党内基层民主，充分发挥基层党组织的战斗堡垒作用和党员的先锋模范作用”。 （八）新增“落实全面从严治党主体责任，领导学校党的纪律检查工作，推进惩治和预防腐败体系建设”。 （九）新增“向党委报告重大决议执行情况，向教职工代表大会报告工作，组织处理教职工代表大会、学生（研究生）代表大会、工会会员代表大会和团员代表大会有关行政工作的提案，支持学校各级党组织、民主党派基层组织、群众组织和学术组织开展工作”。 其他 新增“党委全体会议……主要对事关学校改革发展稳定和师生员工切身利益及党的建设等全局性重大问题作出决策。常务委员会……主要对学校改革发展稳定和教学、科研、行政管理及党的建设等方面的重要事项作出决定，按照干部管理权限和有关程序推荐、提名、决定任免干部。党委常委会由党委全委会选举产生……党委书记主持党委全面工作”。 复旦大学纪律检查委员会……根据相关规定履行职责”改为“依据党的章程和党内法规履行职责”。 原章程第十条新增“（校长）在学校党委领导下，贯彻党的教育方针，组织实施学校党委有关决议，行使高等教育法等规定的各项职权”。 原章程第十一条删去“学校党政领导不参加学术委员会”；新增“依据民主集中制产生（学术委员会）”。 原章程第十二条（二）新增“在国家授权范围内（审议学科专业）”。 其他新增“依据民主集中制产生（学位评定委员会）……连任一般不超过两届”。 原章程第十三条“教学指导委员会委员……由校长聘任”改为“依照民主集中制原则产生”。新增“院系教学指导分委员会，组成人员依照民主集中制原则产生”。 原章程第十四条删除“校务委员会领导下设各专门咨询委员会”以及专门咨询委员会的全部章程。 新增一条第十四条“学校设置教材委员会。教材委员会在学校党委领导下，对学校教材建设、使用与管理工作进行指导、审议和监督……主要职责是：（一）贯彻党和国家关于教材工作的方针政策，指导和统筹全校教材工作……”。 原章程第十五条教职工代表大会“评议学校各级党政负责人”改为“参与评议”。新增“（共青团复旦大学委员会）指导学生会和研究生会，指导和管理学生社团工作”。 原章程第十七条删去“学校是以学术为核心的共同体”。 原章程第二十条新增“学校构建以思想政治教育为根本……的教育教学体系”。 原章程第二十一条自主设置与境外高校联合学位项目”改为“授予名誉博士学位须报国务院学位委员会批准”。 原章程第二十四条新增“学院……落实立德树人根本任务”。 原章程第二十六条“学校确定一名副校长兼任上海医学院院长”，改为“上海医学院党政主要领导由校领导兼任”。 新增第二十八条“学院（系）直属学校的实体研究机构设立党的组织，发挥政治核心作用，负责党的建设和思想政治工作，保证监督本单位贯彻落实党的路线方针政策及学校决定，支持行政班子在其职责范围内负责地开展工作。”第二十九条：“学院（系）依照有关规定通过党政联席会议，研究决定本单位重大事项，健全集体领导、党政分工合作、协调运行的工作机制。涉及办学方向、教师队伍建设、师生员工切身利益等重大事项，由党组织先研究再提交党政联席会议决定。”。 原章程第三十二条教师的专职新增“教育”，从“教学科研”变为“教育教学科研”；“代表性成果为核心的晋升制度”修改为：“有基本标准要求与代表性成果相结合的评价制度”。 原章程第三十五条加入增加第一款“（教职员工负有义务）忠诚于党的教育事业，学习贯彻党和国家的教育方针，坚持立德树人根本任务，践行社会主义核心价值观”（此条直接引用），“为人师表，爱护学生、立德树人”修改为：“恪守师德规范，履行育人职责，为人师表，敬业爱生，引领学生健康成长”。 第三十一条 原章程第四十三条（现第四十五条）学生在校，应当以学习为要务。”修改为：“学生在校，应当以学习为要务，注重价值观、知识和能力的全面协调发展，不断提升综合素养。”。 第三十三条 原章程第四十八条（现第五十条）“学生群体内部事务，原则上由学生自主管理、自我完善”修改为：“学生群体应不断提高自我教育、自我管理、自我服务、自我监督的意识和能力”。 新增一条第三十七条“学校根据需要，按照国家法律、法规和学校有关规定聘请外籍教师。外籍教师应遵守中国的法律、法规及学校的规章制度和纪律，对华友好，尊重中国的社会公德和风俗习惯，享有相应权利，履行相关义务。”。 原章程第四十八条删去“复旦大学学生会……是学生自我服务、自我管理、自我教育、自我监督的组织”。复旦大学学生会以及研究生会……是全校本（专）科学生以及研究生参与学生事务的最高权力机关”，改为“是全校本（专）科学生以及研究生参与学生事务的重要形式”。 新增一条第五十二条“学校招收外国留学生，提供学历教育和非学历教育，依照国家有关法律、法规和学校的规章制度对外国留学生进行教育和管理。外国留学生应遵守中国的法律、法规及学校的规章制度和纪律，尊重中国的社会公德和风俗习惯，享有相应权利，履行相关义务”。 原章程第五十九条“（学校董事会旨在）健全监督机制”改为“共商共促学校发展”。 复旦大学校歌刘大白 词丰子恺 曲歌词：复旦复旦旦复旦，巍巍学府文章焕，学术独立思想自由，政罗教网无羁绊，无羁绊前程远，向前，向前，向前进展。复旦复旦旦复旦，日月光华同灿烂。复旦复旦旦复旦，师生一德精神贯，巩固学校维护国家，先忧后乐交相勉，交相勉前程远，向前，向前，向前进展。复旦复旦旦复旦，日月光华同灿烂。复旦复旦旦复旦，沪滨屹立东南冠，作育国士恢廓学风，震欧铄美声名满，声名满前程远，向前，向前，向前进展。复旦复旦旦复旦，日月光华同灿烂。 百度百科复旦大学校歌_百度百科","tags":["history"]},{"title":"区块链项目需要注意哪些司法新动向","path":"/2019/12/17/区块链项目需要注意哪些司法新动向/","content":"警方虚拟币法律知识的更新继沿海几座大城市的网警朋友积极学习区块链技术（存证等方面）和相关法律知识之后，内陆的经济警察也开始相关法律知识的更新。 我们发现，浙江某市的区块链内部研讨会议和技术复盘会议中，也出现了警察叔叔参与讨论，而且其对技术本身的研究颇深，出乎大家意料。这与两年前在人民大学与公检法朋友们沟通时的情况（彼时他们对区块链的陌生）形成了鲜明的对比。 这充分说明，已经有案子出现了，并且呈现一定活跃态势，司法机关严阵以待，提前用相关法律知识武装自己，以便更好地适应或许会出现的涉币案件潮。 反观链圈，几乎每一个区块链项目方都有“发币”的冲动，虽然我们理解“激励机制”对项目自身的作用，然而，一旦发币 ICO，在我国现有法律框架下会被定性为“非法的公开融资行为”，涉嫌非法集资类犯罪或非法经营罪等。 懂币圈的人越来越多曾几何时，我们以为坐在对面的检察官朋友对币圈不甚了解，近期发现，并非如此。为了办案准确，他们深入调研，甚至暗访；对于 token 的价值，并不是全盘否定，而是认为如果 token 对应有权益等，则 token 自身是有价值的，不能把发行代币的行为认定为“诈骗”，在实务中，也做出了“不批捕”的决定。 同时，在认定是否涉嫌非法吸收公众存款罪的问题上，检方对于“投资者特定与否”的认定相对严格，如果确实“私募”，那么，不构成刑法第 176 条非法吸收公众存款罪。但是，不一定会按照无罪处理，而是有可能选择计算机类犯罪予以补白。 对于“境外发币，境内无实质销售”的行为，当下，司法机关采取的方式还是相对宽容的，基本不会主动“穿透式审判”，而是“等子弹再飞一会儿”。因此，类似的项目方暂时可以喘息，记住千万不要回国内进行“路演”等销售活动，以免遭遇刑事风险。 组织领导传销罪，浮出水面与飒姐同在一所高校任职兼职硕导的资深检察官，谈到其学生在某区按摩店门口窥见一群老人家认真听课：什么是区块链什么是虚拟币及如何投资。 这不禁让我们联想起数年前的 P2P 线下推广，十几年前的纳米技术线下推广，新瓶装旧酒，还是那个配方：传销行为。 诚然，传销行为本身只是违法行为，不构成犯罪。但是，我们必须说明，组织者和领导者是构成犯罪的。其中，读者需要特别注意的是，传销活动中的“讲师”应归属于“组织者领导者”的范围之内，应当受到刑法第 224 条之一组织领导传销罪的处理。 目前，在内陆一些城市拿区块链技术蒙骗投资者的不法活动有所抬头，相信办案机关不会坐视不管，传说中的“剿匪”工作势在必行，务必保护好老百姓的钱袋子。在此，飒姐也提醒诸位读者，不要轻信项目方的忽悠，您看中的是“回报”，人家看上的是您的“本金”。 写在最后目前法律的态度非常坚决，发币是非法公开融资，涉币交易所不允许在境内存在，一旦发现立刻取缔。同时，针对区块链项目的备案，已经如火如荼进行中，但备案不是许可，并不能因此获得“法律金钟罩”，如果涉嫌违法犯罪，该处理的时候绝不会手软。 本文来源于 肖飒 lawyer","categories":["Digital currency"]},{"title":"全球央行数字货币进展调研","path":"/2019/12/16/全球央行数字货币进展调研/","content":"Overview随着消费者支付习惯的改变，现金的存在作用在不断弱化。无现金交易将成为下一个支付前沿。目前多国央行在筹备发行数字货币，数字货币的稳定性和安全性，是各国央行研发的重中之重。 Report多家央行准备发行数字货币IBM 和国际货币金融机构（OMFIF）联合发布的最新调查报告显示，首个央行数字货币（CBDC）预计将在未来五年内发行。 报告显示，多国央行考虑开发和发行央行数字货币（CBDC），未来五年内可能会有面向消费者的 CBDC 推出，而面向消费者的 CBDC 可能需要某种形式的公司合作。CBDC 是由中央银行发行的一种用来支付和结算的数字资产。央行数字货币预计分为两种：零售型和批发型。零售型主要供社会大众和公司使用，目的或将替代现有的法定货币 M0；批发型则用于银行间结算服务，这将有效提高支付效率，并降低与现有支付系统相关的成本和复杂性。 IBM 和 OMFIF 还根据调查得出结论，首个 CBDC 预计在未来五年内从一个小经济体中产生，并以明确的用途响应一个特定的政策目标。这个调查，从 2019 年 7 月开始，历时三个月，调查对象涉及 13 个发达经济体和 10 个新兴市场的央行官员。其中 73% 的受访者表示支持 CBDC，认为某些情况下，CBDC 将是现金的良好替代品。 中国中国目前走在数字货币发行的前沿。据《财经》报道，由人民银行牵头，工、农、中、建四大国有商业银行，中国移动、中国电信、中国联通三大电信运营商共同参与的央行法定数字货币试点项目有望在深圳、苏州等地落地。 这距离首次法定数字货币试行间隔近三年，相较于上次试点，本次央行法定数字货币试点将走出央行系统，进入交通、教育、医疗等服务场景，触及 C 端用户，进入频繁应用阶段，试点银行可根据自身条件进行场景选择。该试点项目由央行货币金银局牵头，数字货币研究所具体落实。去年年底，央行货币金银局下的防伪处改为数字货币与防伪管理处，作为央行数字货币唯一的官方权威处室。 并且，法定数字货币的相关标准以及支付系统接入等测试工作也在同步推进中。 美国10 月，美联储一份名为《数字货币、稳定币以及不断发展的支付格局》的报告中提到，央行数字货币可以是一种灵活的中央银行发行的货币形式，甚至可能有助于解决美元面临的特里芬困境。 但根据彭博社报道，美国财长 Steven Mnuchin 在众议院金融服务委员会的听证会上称，五年内美联储没有发行数字货币的必要，也不反对 Facebook 创建数字货币，但 Facebook 的数字货币 Libra 需要完全遵守银行保密和反洗钱规定，并且绝不能用于资助恐怖主义。 目前而言，美国对发行央行数字货币还持有一种观望状态。 欧洲有消息称，如果欧洲内部支付成本仍然居高不下，私有支付系统不能解决支付成本问题，欧洲央行将推出数字货币用于内部支付结算，并称现金使用减少的迹象也将加速数字货币的实施。 法国外媒称，法兰西银行行长宣布，法国将于 2020 年开始试验一种提供给金融机构的央行数字货币。并称将在 2020 年第一季度结束之前，开始试验并发布项目信息。并且有报道称，法国央行支付监督和市场基础设施局将改名为基础设施、创新和支付局。新的机构将负责央行在数字货币、支付和基础设施方面的创新。 印度在距离印度央行下令禁止银行、电子钱包和支付网关提供商为加密货币交易所和其他与加密货币交易相关业务提供支持 18 个月后，其态度似乎在转变。印度央行已计划开发央行数字货币（CBDC），但尚未公布具体实施计划和时间。印度央行行长 Shaktikanta Das 表示随着技术发展，印度储备银行将在适当时候认真对待央行数字货币，但目前还处于起步阶段。 泰国2019 年 5 月，泰国中央银行和香港金融管理局签署了谅解备忘录，并表示香港和泰国的货币当局准备推出两层结构的数字货币，这是使用金融技术或金融科技为两个经济体之间的跨境资金转移创建原型的过程的一部分。 原型的第一层，称为 LionRock-Inathanon 项目。这将涉及到向参与试点计划的香港银行发行数字货币。香港金融管理局发言人称，第二层涉及银行将数字货币分发给其企业客户，以便与其他银行或其他公司进行批发付款。 这项计划的主要目的是，以研究「央行数字货币」在跨境支付领域里的应用，从而促进香港与泰国两地银行之间的双币种外汇交易同步交付，预计有关的联合报告将会于 2020 年第一季公布。该项「央行数字货币计划」与中国人民银行正在开发的数字货币相比，是不同的使用案例。央行专注于替换流通中的现金，而 LionRock 项目的重点则是简化银行与公司之间的跨境转账和付款。 突尼斯突尼斯已经宣布推出本国货币 Dinar 的数字版本「E-Dinar」，这个北非小国成为全国第一个发行中央银行数字货币（CBDC）的国家。突尼斯已经与俄罗斯公司 Universa 建立合作，通过 Universa 的区块链平台发行 E-Dinar。在上线时，突尼斯中央银行行长 Marouane EI Abassi 与国际货币基金组织（IMF）的代表之间象征性的进行了一次转账。 Conclusion全世界各国都对央行数字货币（CBDC）表现出了兴趣，但目前尚未出现有决定意义的央行数字货币。随着技术的进步，以及科技金融在整体金融框架中所占地位越来越重，央行数字货币的出现，将会对货币政策和金融系统稳定性产生重大影响。央行数字货币的发行除了需要技术的辅助，也需要有足够的框架来确保治理和风险管理，才能保证其健康稳定的发展。 本文来自：全球央行数字货币进展调研｜标准共识","categories":["Digital currency"]},{"title":"美国参议院一致通过《香港人权与民主法案》","path":"/2019/11/20/美国参议院一致通过《香港人权与民主法案》/","content":"Hong Kong Human Rights and Democracy Act","tags":["history"]},{"title":"策略模式","path":"/2019/07/15/策略模式/","content":"状态模式123456789101112131415161718192021222324252627let ResultState = (() =&gt; &#123; let States = &#123; state0: function () &#123; console.log(&#x27;state0&#x27;) &#125;, state1: function () &#123; console.log(&#x27;state1&#x27;) &#125;, state2: function () &#123; console.log(&#x27;state2&#x27;) &#125;, state3: function () &#123; console.log(&#x27;state3&#x27;) &#125;, &#125; function show(result) &#123; States[&#x27;state&#x27; + result] &amp;&amp; States[&#x27;state&#x27; + result]() &#125; return &#123; show, &#125;&#125;)()// for testResultState.show(3) 策略模式123456789101112131415let Price = (() =&gt; &#123; let obj = &#123; return30: (price) =&gt; +price + parseInt(price / 100) * 30, return50: (price) =&gt; +price + parseInt(price / 100) * 50, percent90: (price) =&gt; (price * 100 * 90) / 10000, percent80: (price) =&gt; (price * 100 * 80) / 10000, &#125; return (algorithm, price) =&gt; &#123; return obj[algorithm] &amp;&amp; obj[algorithm](price) &#125;&#125;)()// for testlet price = Price(&#x27;return50&#x27;, 321.13)console.log(price)","tags":["学习"]},{"title":"装饰器","path":"/2019/07/14/装饰器/","content":"装饰器123456789101112131415161718192021222324252627282930313233/** * 为dom元素添加事件 * @param &#123;&#125; dom * @param &#123;*&#125; type * @param &#123;*&#125; fn */function addEvent(dom, type, fn) &#123; if (dom.addEventListener) &#123; dom.addEventListener(type, fn, false) &#125; else if (dom.attachEvent) &#123; dom.attachEvent(&#x27;on&#x27; + type, fn) &#125; else &#123; dom[&#x27;on&#x27; + type] = fn &#125;&#125;/** * 装饰已有对象 * @param &#123;*&#125; id * @param &#123;*&#125; fn */function decorator(id, fn) &#123; let obj = document.querySelector(id) if (typeof id.onclick === &#x27;function&#x27;) &#123; let oldFn = id.onclick id.onclick = function () &#123; oldFn() fn() &#125; &#125; else &#123; obj.onclick = fn &#125;&#125; 观察者模式12345678910111213141516171819202122232425262728293031323334353637let Observer = (() =&gt; &#123; let _message = &#123;&#125; return &#123; regist: function (type, fn) &#123; if (typeof _message[type] === &#x27;undefined&#x27;) &#123; _message[type] = [fn] &#125; else &#123; _message[type].push(fn) &#125; &#125;, fire: function (type, args) &#123; if (!_message[type]) &#123; return &#125; let events = &#123; type, args: args || &#123;&#125;, &#125; for (let i = 0, len = _message[type].length; i &lt; len; i++) &#123; _message[type][i].call(this, events) &#125; &#125;, remove: function (type, fn) &#123; if (_message[type] instanceof Array) &#123; for (let i = _message[type].length - 1; i &gt;= 0; i--) &#123; _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1) &#125; &#125; &#125;, &#125;&#125;)()Observer.regist(&#x27;test&#x27;, function (e) &#123; // register console.log(e.type, e.args.msg)&#125;)Observer.fire(&#x27;test&#x27;, &#123; msg: &#x27;this is some test message&#x27; &#125;) // send","tags":["学习"]},{"title":"惰性单例","path":"/2019/07/12/惰性单例/","content":"惰性单例12345678910111213141516171819let LazySingle = (() =&gt; &#123; let instance = null function Single() &#123; return &#123; Method: function () &#123; console.log(&#x27;public method&#x27;) &#125;, Prototype: &#x27;some message&#x27;, &#125; &#125; return () =&gt; &#123; if (!instance) instance = Single() return instance &#125;&#125;)()// for testconsole.log(LazySingle().Prototype)LazySingle().Method()","tags":["学习"]},{"title":"原型模式","path":"/2019/07/11/原型模式/","content":"原型模式1234567891011121314151617181920212223242526let LoopImages = function (imageArr, container) &#123; this.imageArr = imageArr this.container = container&#125;LoopImages.prototype = &#123; createImage: function () &#123; console.log(&#x27;create image&#x27;) &#125;, changeImage: function () &#123; console.log(&#x27;change image&#x27;) &#125;,&#125;let SlideLoopImg = function (imageArr, container) &#123; LoopImages.call(this, imageArr, container)&#125;SlideLoopImg.prototype = new LoopImages() // 继承SlideLoopImg.prototype.changeImage = () =&gt; &#123; // 重写 console.log(&#x27;slide loop change image&#x27;)&#125;// for testlet slideImage = new SlideLoopImg([&#x27;1.jpg&#x27;, &#x27;2.jpg&#x27;], &#x27;slide&#x27;)console.log(slideImage.container)slideImage.changeImage() 原型继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * copy object */function prototypeExtend() &#123; let F = function () &#123;&#125; // let F = new Function() for (let i = 0; i &lt; arguments.length; i++) &#123; for (let j in arguments[i]) &#123; F.prototype[j] = arguments[i][j] &#125; &#125; return new F()&#125;// for testlet car = prototypeExtend( &#123; speed: 20, fast: function () &#123; this.speed++ console.log(&#x27;is faster&#x27;) &#125;, &#125;, &#123; slow: function () &#123; this.speed-- console.log(&#x27;is slower&#x27;) &#125;, &#125;, &#123; stop: function () &#123; this.speed = 0 console.log(&#x27;is stop&#x27;) &#125;, &#125;, &#123; currentSpeed: function () &#123; console.log(this.speed) &#125;, &#125;,)car.fast()car.fast()car.fast()car.fast()car.currentSpeed()car.stop()car.currentSpeed()","tags":["学习"]},{"title":"Builder 模式","path":"/2019/07/10/Builder-模式/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let Human = function (param) &#123; this.skill = (param &amp;&amp; param.skill) || &#x27;null&#x27; this.hobby = (param &amp;&amp; param.skill) || &#x27;null&#x27;&#125;Human.prototype = &#123; getSkill: function () &#123; return this.skill &#125;, getHobby: function () &#123; return this.hobby &#125;,&#125;let Named = function (name) &#123; let _this = this ;((name, _this) =&gt; &#123; this.wholeName = name if (name.indexOf(&#x27; &#x27;) &gt; -1) &#123; _this.FirstName = name.slice(0, name.indexOf(&#x27; &#x27;)) _this.LastName = name.slice(name.indexOf(&#x27; &#x27;)) &#125; &#125;)(name, _this)&#125;let Work = function (work) &#123; let _this = this ;((work, _this) =&gt; &#123; switch (work) &#123; case &#x27;code&#x27;: this.work = &#x27;developer&#x27; break case &#x27;design&#x27;: this.work = &#x27;designer&#x27; break default: this.work = work &#125; &#125;)(work, _this)&#125;Work.prototype.changeWork = function (work) &#123; this.work = work&#125;/** * to create a Person * @param &#123;*&#125; name * @param &#123;*&#125; work */let Person = function (name, work) &#123; let _person = new Human() _person.name = new Named(name) _person.work = new Work(work) return _person&#125;// for testlet person = new Person(&#x27;Jack Edward&#x27;, &#x27;design&#x27;)console.log(person.work)console.log(person.name)person.work.changeWork(&#x27;code&#x27;)console.log(person.work)","tags":["学习"]},{"title":"工厂模式","path":"/2019/07/09/工厂模式/","content":"工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let Basketball = function () &#123; this.name = &#x27;basketball&#x27;&#125;Basketball.prototype = &#123; getMember: function () &#123; console.log(5) &#125;, getBallSize: function () &#123; console.log(&#x27;big&#x27;) &#125;,&#125;let FootBall = function () &#123; this.name = &#x27;football&#x27;&#125;FootBall.prototype = &#123; getMember: function () &#123; console.log(11) &#125;, getBallSize: function () &#123; console.log(&#x27;big&#x27;) &#125;,&#125;let Tennis = function () &#123; this.name = &#x27;tennis&#x27;&#125;Tennis.prototype = &#123; getMember: function () &#123; console.log(1) &#125;, getBallSize: function () &#123; console.log(&#x27;small&#x27;) &#125;,&#125;let SportFactory = function (name) &#123; switch (name) &#123; case &#x27;basketball&#x27;: return new Basketball() case &#x27;football&#x27;: return new FootBall() case &#x27;tennis&#x27;: return new Tennis() &#125;&#125;let footBall = new SportFactory(&#x27;football&#x27;)footBall.getMember() 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Product base attributeinterface Product &#123; operation(): string&#125;class ConcreteProduct1 implements Product &#123; public operation(): string &#123; return &#x27;This is Product1&#x27; &#125;&#125;class ConcreteProduct2 implements Product &#123; public operation(): string &#123; return &#x27;This is Product2&#x27; &#125;&#125;abstract class Creator &#123; public abstract factoryMethod(): Product public operation(): string &#123; const product = this.factoryMethod() return product.operation() &#125;&#125;class ConcreteCreator1 extends Creator &#123; public factoryMethod(): Product &#123; return new ConcreteProduct1() &#125;&#125;class ConcreteCreator2 extends Creator &#123; public factoryMethod(): Product &#123; return new ConcreteProduct2() &#125;&#125;// usagefunction clientCode(creator: Creator) &#123; console.log(creator.operation())&#125;clientCode(new ConcreteCreator1())clientCode(new ConcreteCreator2()) 安全工厂123456789101112131415161718192021222324252627282930let Factory = function (type, content) &#123; if (this instanceof Factory) &#123; // check if is instance Factory return new this[type](content) &#125; else &#123; return new Factory(type, content) &#125;&#125;Factory.prototype = &#123; Java: function (content) &#123; console.log(content) &#125;, JavaScript: function (content) &#123; console.log(content) &#125;,&#125;let data = [ &#123; type: &#x27;Java&#x27;, content: &#x27;This is Java&#x27;, &#125;, &#123; type: &#x27;JavaScript&#x27;, content: &#x27;This is JavaScript&#x27;, &#125;,]// for testfor (let i = 0; i &lt; data.length; i++) Factory(data[i].type, data[i].content) 抽象工厂12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * to extend superType * @param &#123;*&#125; subType * @param &#123;*&#125; superType */let VehicleFactory = (subType, superType) =&gt; &#123; if (typeof VehicleFactory[superType] === &#x27;function&#x27;) &#123; function F() &#123;&#125; F.prototype = new VehicleFactory[superType]() subType.constuctor = subType subType.prototype = new F() &#125; else &#123; throw new Error(&quot;don&#x27; not have this abstract class&quot;) &#125;&#125;// create base classVehicleFactory.Car = function () &#123; this.type = &#x27;car&#x27;&#125;VehicleFactory.Car.prototype = &#123; getPrice: function () &#123; return new Error(&#x27;abstract&#x27;) &#125;, getSpeed: function () &#123; return new Error(&#x27;abstract&#x27;) &#125;,&#125;let BMW = function (price, speed) &#123; this.price = price this.speed = speed&#125;VehicleFactory(BMW, &#x27;Car&#x27;) // interfaceBMW.prototype = &#123; getPrice: function () &#123; return this.price &#125;, getSpeed: function () &#123; return this.speed &#125;,&#125;// for testlet myBmw = new BMW(10000, 100)console.log(myBmw.getPrice()) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// product interfaceinterface AbstractProductA &#123; functionA(): string&#125;interface AbstractProductB &#123; /** * base operation * @return &#123;string&#125; */ functionA(): string /** * inject some operation * @param &#123;AbstractProductA&#125; product * @return &#123;string&#125; */ functionB(product: AbstractProductA): string&#125;// concrete productionclass ConcreteProductA1 implements AbstractProductA &#123; functionA(): string &#123; return &#x27;This is functionA from ProductA1&#x27; &#125;&#125;class ConcreteProductA2 implements AbstractProductA &#123; functionA(): string &#123; return &#x27;This is functionA from ProductA2&#x27; &#125;&#125;class ConcreteProductB1 implements AbstractProductB &#123; functionA(): string &#123; return &#x27;This is functionA from ProductB1&#x27; &#125; functionB(product: AbstractProductA): string &#123; return &#x27;Function B2: &#x27; + product.functionA() &#125;&#125;class ConcreteProductB2 implements AbstractProductB &#123; functionA(): string &#123; return &#x27;This is functionA from ProductB2&#x27; &#125; functionB(product: AbstractProductA): string &#123; return &#x27;Function B2: &#x27; + product.functionA() &#125;&#125;// factory interfaceinterface AbstractFactory &#123; createProductA(): AbstractProductA createProductB(): AbstractProductB&#125;// concrete factoryclass ConcreteFactory1 implements AbstractFactory &#123; createProductA(): AbstractProductA &#123; return new ConcreteProductA1() &#125; createProductB(): AbstractProductB &#123; return new ConcreteProductB1() &#125;&#125;class ConcreteFactory2 implements AbstractFactory &#123; createProductA(): AbstractProductA &#123; return new ConcreteProductA2() &#125; createProductB(): AbstractProductB &#123; return new ConcreteProductB2() &#125;&#125;// usage/** * use with different facotry. * @param &#123;AbstractFactory&#125; factory */function clientCode(factory: AbstractFactory) &#123; const productA = factory.createProductA() const productB = factory.createProductB() console.log(productB.functionA()) console.log(productB.functionB(productA))&#125;clientCode(new ConcreteFactory1())clientCode(new ConcreteFactory2())","tags":["学习"]},{"title":"继承","path":"/2019/07/09/继承/","content":"子类的原型对象-类式继承123456789101112131415161718192021// 类式继承// parentfunction SuperClass() &#123; this.superValue = true&#125;SuperClass.prototype.getSuperValue = function () &#123; return this.superValue&#125;// childfunction SubClass() &#123; this.subValue = false&#125;SubClass.prototype = new SuperClass()SubClass.prototype.getSubValue = function () &#123; return this.subValue&#125;let child = new SubClass()console.log(child.getSuperValue()) // trueconsole.log(child.getSubValue()) // false 创建即继承-构造函数继承1234567891011121314151617181920212223// parentfunction SuperClass(id) &#123; this.books = [&#x27;JavaScript&#x27;, &#x27;html&#x27;, &#x27;css&#x27;] this.id = id&#125;SuperClass.prototype.showBooks = function () &#123; console.log(this.books)&#125;// childfunction SubClass(id) &#123; SuperClass.call(this, id)&#125;var instance1 = new SubClass(10)var instance2 = new SubClass(20)instance1.books.push(&#x27;test&#x27;)instance2.books.shift()console.log(instance1.books)console.log(instance2.books)// instance1.showBooks(); // Type Error 组合继承12345678910111213141516171819202122// parentfunction SuperClass(name) &#123; this.name = name this.books = [&#x27;JavaScript&#x27;, &#x27;html&#x27;, &#x27;css&#x27;]&#125;SuperClass.prototype.getName = function () &#123; console.log(this.name)&#125;// childfunction SubClass(name, time) &#123; SuperClass.call(this, name) this.time = time&#125;SubClass.prototype = new SuperClass()SubClass.prototype.getTime = function () &#123; console.log(this.time)&#125;var instance1 = new SubClass(&#x27;js book&#x27;, 1998)var instance2 = new SubClass(&#x27;css book&#x27;, 2003)instance1.getName() 原型式继承1234567891011121314151617181920function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;var book = &#123; name: &#x27;JavaScript&#x27;, alikeBook: [&#x27;css book&#x27;, &#x27;html&#x27;],&#125;var newBook = inheritObject(book)newBook.name = &#x27;ajax&#x27;newBook.alikeBook.push(&#x27;xml&#x27;)var otherBook = inheritObject(book)otherBook.name = &#x27;flash&#x27;otherBook.alikeBook.push(&#x27;as&#x27;)console.log(newBook.name)console.log(newBook.alikeBook) // 引用类型的属性共享 寄生式继承1234567891011121314151617181920212223function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;// base objectvar book = &#123; name: &#x27;js&#x27;, alikeBook: [&#x27;css&#x27;, &#x27;html&#x27;],&#125;function createBook(obj) &#123; var o = inheritObject(obj) o.getName = function () &#123; console.log(this.name) &#125; return o&#125;let books = createBook(book)books.getName() 寄生组合式继承1234567891011121314151617181920212223242526272829303132333435function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(subClass, superClass) &#123; var p = inheritObject(superClass.prototype) p.constuctor = subClass subClass.prototype = p&#125;// for testfunction SuperClass(name) &#123; this.name = name this.nums = [1, 2, 3]&#125;SuperClass.prototype.getName = function () &#123; console.log(this.name)&#125;function SubClass(name, time) &#123; SuperClass.call(this, name) this.time = time&#125;inheritPrototype(SubClass, SuperClass)SubClass.prototype.getTime = function () &#123; console.log(this.time)&#125;var instance1 = new SubClass(&#x27;js book&#x27;, 202)instance1.nums.push(30)var instance2 = new SubClass(&#x27;css book&#x27;, 222)console.log(instance1.nums)console.log(instance2.nums) 多继承123456789101112131415161718192021Object.prototype.mix = function () &#123; let len = arguments.length for (let i = 0; i &lt; len; i++) &#123; let arg = arguments[i] for (let property in arg) &#123; this[property] = arg[property] &#125; &#125;&#125;let book1 = &#123; name: &#x27;JavaScript&#x27;,&#125;let book2 = &#123; price: 34,&#125;let book3 = &#123; foo: &#x27;haha&#x27;,&#125;book3.mix(book1, book2)console.log(book3)","tags":["学习"],"categories":["ECMAScript"]},{"title":"HTTP cookies","path":"/2019/05/27/HTTP-cookies/","content":"set-cookie1Set-cookie: value[; expires=date][; domain=domain][; path=path][; secure] 每个选项都是用分号和空格来分开，每个选项都制定了 cookie 在什么情况下会发送给服务器 过期时间选项 expires: 指定了 cookie 最长存储时间，过期后会被浏览器删除。值是一个 date ，格式为 WDY, DD-mm-YYYY HH:MM:SS GMT。 没有设置 expires 选项时，默认为当前会话，所设置的 cookie 在关闭浏览器时会被删除。 1Set-cookie: name=Jack; expires=Tue, 28 May 2019 22:33:22 GMT domain 选项 domain: 指定了 cookie 将要被发给哪个域中。 默认情况下会被设置为当前域。 值必须是消息头主机的一部分，不合法的 domain 会直接被忽略。 1Set-cookie: name=Jack; domain=baidu.com path 选项 path: 指定了请求资源的 URL 中存在指定路径时，才会发送 cookie。 只有对 domain 匹配成功后才会开始匹配 path 部分。 1Set-cookie: name=Jack; domain=baidu.com; path=/ secure 选项 secure: 只是一个标记，当请求通过 SSL 或者 HTTPS 创建时，包含 secure 的 cookie 才会被发送至服务器。 默认情况下， HTTPS 上传输的 cookie 都会被自动加上 secure 选项。 1Set-cookie: name=Jack; secure HTTPOnly 选项 HttpOnly: 禁止浏览器通过 JavaScript 来获取 cookie ，防止 XSS 攻击。 这个属性也不能通过 JavaScript 来设置。 1Set-cookie: name=Jack; HttpOnly cookie 自动删除 会话结束。 超过过期时间。 cookie 数量达到限制，删除部分 cookie 以便为新创建的 cookie 腾出空间。 JavaScript 读取 cookie可以使用document.cookie来读取 cookie 的值。","tags":["整理","HTTP"],"categories":["Network"]},{"title":"Linux通信机制 作业","path":"/2019/05/26/Linux通信机制-作业/","content":"要求 程序 1 从串口读取信息，然后发到消息队列中。使用 2 个终端运行程序 1，创建出 2 个可从串口读取数据的进程，串口可以使用 Windows 中的虚拟串口，使用串口助手输入信息。 程序 2 从消息队列中读取消息，然后在屏幕上将消息内容显示出来。 提交形式 代码 运行结果截图、串口助手截图 Code1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define BUFFER_SIZE 512typedef struct _message &#123; long msg_type; char msg_text[BUFFER_SIZE];&#125; message; 12345678910111213141516171819202122#include &quot;common.h&quot;int main() &#123; int qid; key_t key; message msg; key = ftok(&quot;.&quot;, &#x27;a&#x27;); qid = msgget(key, IPC_CREAT | 0666); do &#123; memset(msg.msg_text, 0, BUFFER_SIZE); msgrcv(qid, (void*)&amp;msg, BUFFER_SIZE, 0, 0); printf(&quot;%s&quot;, msg.msg_text); &#125; while (1); msgctl(qid, IPC_RMID, NULL); exit(0);&#125; 1234567891011121314151617181920212223242526272829303132333435363738#include &quot;common.h&quot;int main() &#123; int qid, fd; key_t key; message msg; char buff[BUFFER_SIZE]; key = ftok(&quot;.&quot;, &#x27;a&#x27;); if (key == -1) &#123; perror(&quot;ftok error&quot;); exit(1); &#125; qid = msgget(key, IPC_CREAT | 0666); if (qid == -1) &#123; perror(&quot;msgget error.&quot;); exit(1); &#125; fd = open(&quot;/dev/ttyS1&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open error.&quot;); exit(1); &#125; read(fd, buff, BUFFER_SIZE); strncpy(msg.msg_text, buff, strlen(buff)); msg.msg_type = getpid(); int size = msgsnd(qid, &amp;msg, strlen(msg.msg_text), 0); if (size &lt; 0) &#123; perror(&quot;message posted.&quot;); exit(1); &#125; exit(0);&#125;","tags":["Linux","IPC","消息队列"],"categories":["Linux"]},{"title":"6.006 - 9","path":"/2019/05/22/6-006-9/","content":"Rabin-Karp1234567891011121314151617181920212223242526272829303132333435363738394041class Rabin_Karp &#123; constructor(str) &#123; this._origin = str.split(&#x27;&#x27;) this._len = str.length &#125; matchResult(str) &#123; let result = [], hash = this._hash(str), strLen = str.split(&#x27;&#x27;).length console.log(strLen) for (let i = 0, len = this._len - strLen + 1; i &lt; len; i++) &#123; let tmp = this._origin.slice(i, i + strLen).join(&#x27;&#x27;) if (hash === this._hash(tmp) &amp;&amp; this._compare(str, tmp)) &#123; result.push(i) &#125; &#125; return result &#125; _hash(string) &#123; // DJB hash let hash = 5381 string .toString() .split(&#x27;&#x27;) .map((i) =&gt; (hash = (hash &lt;&lt; 5) + hash + i.charCodeAt(0))) return hash &#125; _compare(arr1, arr2) &#123; for (let i = 0, len = arr1.length; i &lt; len; i++) &#123; if (arr1[i] != arr2[i]) return false &#125; return true &#125;&#125;let matching = new Rabin_Karp(&#x27;tetesteestfdjklsajtest2tese3trtessstest&#x27;)console.log(matching.matchResult(&#x27;test&#x27;)) result: 1Array(3) [2, 18, 35]","tags":["算法"]},{"title":"6.006 - 8","path":"/2019/05/22/6-006-8/","content":"Hash Table - Table Doubling123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Hash_Table &#123; constructor(size = 8) &#123; this.data = [] this._count = 0 this._size = size &#125; _hash(str, num) &#123; let hash = 0 str.split(&#x27;&#x27;).map((i) =&gt; &#123; hash = (hash &lt;&lt; 5) + i.charCodeAt(0) hash = (hash &amp; hash) % num &#125;) return hash &#125; insert(key, value) &#123; let index = this._hash(key, this._size), modify = false, blank = this.data[index] if (!blank) this.data[index] = blank = [] blank.map((i) =&gt; &#123; if (i[0] === key) &#123; i[1] === value modify = true &#125; &#125;) if (!modify) &#123; blank.push([key, value]) this._count++ if (this._count &gt; this.size * 0.75) &#123; this.resize(this.size * 2) &#125; &#125; &#125; _resize(newSize) &#123; let oldData = this.data this._size = newSize this._count = 0 this.data = [] oldData.map((i) =&gt; &#123; if (!i) return for (let j = 0; j &lt; i.length; j++) &#123; this.insert(i[j][0], i[j][1]) &#125; &#125;) &#125; remove(key) &#123; let index = this._hash(key, this._size) let current = this.data[index] if (!current) return null current.map((i, index) =&gt; &#123; if (i[0] === key) &#123; current.splice(index, 1) this._count-- if (this._count &lt; this._size * 0.25) &#123; this._resize(this._size / 2) &#125; return i[1] &#125; &#125;) &#125; traverse(key) &#123; let index = this._hash(key, this._size), current = this.data[index] if (!current) return null let result = current.filter((i) =&gt; i[0] == key)[0] return result === undefined ? null : result[1] &#125; traverseALl() &#123; console.log(this.data) &#125;&#125;var addressBook = new Hash_Table()addressBook.insert(&#x27;Wendy&#x27;, &#x27;220-02-33&#x27;)addressBook.insert(&#x27;GilesYvette&#x27;, &#x27;746-71-84&#x27;)addressBook.insert(&#x27;Pollitt&#x27;, &#x27;374-34-48&#x27;)addressBook.insert(&#x27;AbeLinda&#x27;, &#x27;040-17-82&#x27;)addressBook.insert(&#x27;StracheyPayne&#x27;, &#x27;129-35-33&#x27;)addressBook.insert(&#x27;JonahIrene&#x27;, &#x27;709-98-46&#x27;)addressBook.insert(&#x27;DorisAngela&#x27;, &#x27;205-74-43&#x27;)addressBook.insert(&#x27;ThoreauTess&#x27;, &#x27;946-62-95&#x27;)addressBook.insert(&#x27;HaggaiFanny&#x27;, &#x27;147-68-09&#x27;)addressBook.insert(&#x27;KentCuritis&#x27;, &#x27;095-94-11&#x27;)addressBook.insert(&#x27;CecilliaFrederica&#x27;, &#x27;273-72-73&#x27;)addressBook.insert(&#x27;HazlittFranklin&#x27;, &#x27;107-49-37&#x27;)addressBook.remove(&#x27;AbeLinda&#x27;)addressBook.remove(&#x27;Pollitt&#x27;)addressBook.traverseALl()console.log(addressBook.traverse(&#x27;CecilliaFrederica&#x27;))console.log(addressBook.traverse(&#x27;Pollitt&#x27;))console.log(addressBook.traverse(&#x27;HaggaiFanny&#x27;))console.log(addressBook.traverse(&#x27;ThoreauTess&#x27;))console.log(addressBook.traverse(&#x27;DorisAngela&#x27;)) result: 123456Array(7) […, Array(4), …, Array(2), Array(0), Array(3), Array(1)]273-72-73null147-68-09946-62-95205-74-43","tags":["算法"]},{"title":"6.006 - 7","path":"/2019/05/21/6-006-7/","content":"Hash Table - Hashing with ChainingIncredibly, the Array.prototype.fill will fill each item with the same Object. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Node &#123; constructor(value) &#123; this.next = null this.value = value &#125;&#125;class Hash_Table &#123; constructor(size = 16) &#123; this.size = size this.data = new Array(this.size) // this.data.fill(&#123; next: null &#125;); for (let i = 0; i &lt; this.size; i++) &#123; this.data[i] = &#123; next: null &#125; &#125; &#125; _hash(string) &#123; // DJB hash let hash = 5381 string .toString() .split(&#x27;&#x27;) .map((i) =&gt; (hash = (hash &lt;&lt; 5) + hash + i.charCodeAt(0))) return hash &#125; insert(key, value) &#123; let pointer = this.data[this._hash(key) % this.size] if (!pointer.next) &#123; pointer.next = new Node(value) &#125; else &#123; while (pointer.next) &#123; pointer = pointer.next if (pointer.value === value) return &#125; pointer.next = new Node(value) &#125; &#125; get(key) &#123; let pointer = this.data[this._hash(key) % this.size], result = [] if (!pointer.next) return new Error(&quot;Doesn&#x27;t exist.&quot;) else &#123; do &#123; pointer = pointer.next result.push(pointer.value) &#125; while (pointer.next) return result &#125; &#125; delete(key) &#123; this.data[this._hash(key) % this.size] = &#123; next: null &#125; &#125;&#125;let hash = new Hash_Table()hash.insert(&#x27;test&#x27;, 3)hash.insert(&#x27;test&#x27;, 5)hash.insert(&#x27;test&#x27;, 5)hash.insert(&#x27;test&#x27;, 6)hash.insert(12, 44)hash.insert(11, 3)hash.insert(10, 3)console.log(hash.get(&#x27;test&#x27;))hash.delete(12)console.log(hash.get(12)) result: 12Array(3) [3, 5, 6]Error: Doesn&#x27;t exist.","tags":["算法"]},{"title":"6.006 - 6","path":"/2019/05/21/6-006-6/","content":"Simplify Hash Table1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node &#123; constructor(value) &#123; this.next = null this.value = value &#125;&#125;class Hash_Table &#123; constructor() &#123; this.size = 1024 this.data = new Array(this.size) &#125; _hash(string) &#123; // DJB hash let hash = 5381 string .toString() .split(&#x27;&#x27;) .map((i) =&gt; (hash = (hash &lt;&lt; 5) + hash + i.charCodeAt(0))) return hash &#125; insert(key, value) &#123; this.data[this._hash(key) % this.size] = value &#125; get(key) &#123; let value = this.data[this._hash(key) % this.size] return value === undefined ? new Error(&quot;Doesn&#x27;t exist.&quot;) : value &#125; delete(key) &#123; this.data[this._hash(key) % this.size] = undefined &#125;&#125;let hash = new Hash_Table()hash.insert(&#x27;test&#x27;, 3)console.log(hash.get(&#x27;test&#x27;))hash.delete(&#x27;test&#x27;)console.log(hash.get(&#x27;test&#x27;))hash.insert(12, 44)console.log(hash.get(12)) result: 1233Error: Doesn&#x27;t exist.44","tags":["算法"]},{"title":"6.006 - 5","path":"/2019/05/20/6-006-5/","content":"AVL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175class Node &#123; constructor(key) &#123; this.key = key this.leftChild = null this.rightChild = null &#125;&#125;class AVL &#123; constructor() &#123; this.root = null this.parent = null this.deleted = null &#125; getRoot() &#123; return this.root &#125; _heightNode(node) &#123; return node === null ? -1 : Math.max( this._heightNode(node.leftChild), this._heightNode(node.rightChild), ) + 1 &#125; _rotationLeftLeft(node) &#123; let tmp = node.leftChild node.leftChild = tmp.rightChild tmp.rightChild = node return tmp &#125; _rotationRightRight(node) &#123; let tmp = node.rightChild node.rightChild = tmp.leftChild tmp.leftChild = node return tmp &#125; _rotationLeftRight(node) &#123; node.leftChild = this._rotationRightRight(node.leftChild) return this._rotationLeftLeft(node) &#125; _rotationRightLeft(node) &#123; node.rightChild = this._rotationLeftLeft(node.rightChild) return this._rotationRightRight(node) &#125; _insertNode(node, value) &#123; if (node === null) &#123; node = new Node(value) // put the node &#125; else if (value &lt; node.key) &#123; node.leftChild = this._insertNode(node.leftChild, value) if (node.leftChild !== null) &#123; if ( this._heightNode(node.leftChild) - this._heightNode(node.rightChild) &gt; 1 ) &#123; // check the height if (value &lt; node.leftChild.key) &#123; node = this._rotationLeftLeft(node) &#125; else &#123; node = this._rotationLeftRight(node) &#125; &#125; &#125; &#125; else if (value &gt; node.key) &#123; node.rightChild = this._insertNode(node.rightChild, value) if (node.rightChild !== null) &#123; if ( this._heightNode(node.rightChild) - this._heightNode(node.leftChild) &gt; 1 ) &#123; // check the height if (value &gt; node.rightChild.key) &#123; node = this._rotationRightRight(node) &#125; else &#123; node = this._rotationRightLeft(node) &#125; &#125; &#125; &#125; return node &#125; insert(value) &#123; this.root = this._insertNode(this.root, value) &#125; _removeNode(node, value) &#123; if (node === null) return node this.parent = node if (value &lt; node.key) &#123; node.leftChild = _removeNode(node.leftChild, value) &#125; else &#123; this.deleted = node node.rightChild = _removeNode(node.rightChild, value) &#125; if (node === this.parent) &#123; if (this.deleted !== null &amp;&amp; value === this.deleted.key) &#123; if (this.deleted === this.parent) &#123; node = node.leftChild &#125; else &#123; ;[this.deleted.key, this.parent.key] = [ this.parent.key, this.deleted.key, ] node = node.rightChild &#125; &#125; &#125; else &#123; if ( this._heightNode(node.leftChild) - this._heightNode(node.rightChild) === 2 ) &#123; if (value &lt; node.leftChild.key) &#123; node = this._rotationLeftRight(node) &#125; else &#123; node = this._rotationLeftLeft(node) &#125; &#125; if ( this._heightNode(node.rightChild) - this._heightNode(node.leftChild) === 2 ) &#123; if (value &gt; node.rightChild.key) &#123; node = this._rotationRightLeft(node) &#125; else &#123; node = this._rotationRightRight(node) &#125; &#125; &#125; return node &#125; remove(value) &#123; this.parent = null this.deleted = null this.root = this._removeNode(this.root, value) &#125; inOrderTraverse() &#123; this._inOrderTraverse(this.root) &#125; _inOrderTraverse(node) &#123; if (node) &#123; this._inOrderTraverse(node.leftChild) console.log(node.key) this._inOrderTraverse(node.rightChild) &#125; &#125;&#125;let avl = new AVL()avl.insert(6)avl.insert(7)avl.insert(14)avl.insert(15)avl.insert(13)console.log(avl.getRoot())avl.inOrderTraverse() result: 123456Node &#123;key: 7, leftChild: Node, rightChild: Node&#125;67131415","tags":["算法"]},{"title":"Some Lists","path":"/2019/05/20/Some-Lists/","content":"TV series Game of Thrones WestWorld Chernobyl Fantasmagorias Love, Death &amp; Robots Music King Boomba’s Crew - Edison Chen&#x2F;MC Hotdog Woman27 - MC Hotdog 贫民百万歌星 - MC Hotdog 差不多先生 - MC Hotdog 毒 - MC Hotdog 嘿嘿 Taxi - MC Hotdog 十三号天使 - MC Hotdog 轻熟女 27 - MC Hotdog 烦死人 - MC Hotdog 1999 - Charli XCX&#x2F;Troye Sivan Nothing on you - Bruno Mars&#x2F;B.o.B Mr.Sandman - Edison Chen Salute - Edsion Chen 金翅鸟 2012 - MC 仁 Stuttering - Fefe Dobson Friend Like Me(End Title) - Will Smith&#x2F;DJ Khaled Prince Ali - Will Smith 少女的祈祷 - 杨千嬅 浪子回头 - 茄子蛋 年少有为 - 李荣浩 Movies Aladdin - 2019","tags":["整理"],"categories":["生活"]},{"title":"Linux进程通信 作业","path":"/2019/05/20/Linux进程通信-作业/","content":"有名管道 父进程创建一个有名管道，然后创建 1 个子进程，父进程阻塞的方式等待有名管道的信息，当读取到信息之后，在屏幕上打印出来；当从有名管道中读取到“QUIT”之后，父进程终止。 子进程 1 使用定时器，每 5 秒钟向有名管道输入“this is process 1”；当收到信号 SIGQUIT 时，向有名管道输出“QUIT”，并在屏幕上输出“process 1 exit”之后，进程终止。 提交形式 代码 运行结果截图 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;signal.h&gt;#define FIFO &quot;/tmp/fifo&quot;#define MAX_BUFFER_SIZE PIPE_BUFpid_t pid, pr;char buff[MAX_BUFFER_SIZE];void child_func(int sign_no) &#123; if (sign_no == SIGALRM) &#123; int fdChild = open(FIFO, O_WRONLY); if (fdChild == -1) &#123; printf(&quot;Open fifo file error &quot;); exit(1); &#125; sscanf(&quot;this is progress 1 &quot;, &quot;%[^ ]&quot;, buff); write(fdChild, buff, MAX_BUFFER_SIZE); close(fdChild); &#125; else if (sign_no == SIGQUIT) &#123; int fdChild = open(FIFO, O_WRONLY); if (fdChild == -1) &#123; printf(&quot;Open fifo file error &quot;); exit(1); &#125; sscanf(&quot;QUIT &quot;, &quot;%[^ ]&quot;, buff); write(fdChild, buff, MAX_BUFFER_SIZE); close(fdChild); printf(&quot;process 1 exit. &quot;); exit(0); &#125;&#125;int main() &#123; pid = fork(); if (pid &lt; 0) &#123; printf(&quot;Fork error &quot;); exit(1); &#125; else if (pid == 0) &#123; // child thread signal(SIGALRM, child_func); // handle SIG_ALARM signal(SIGQUIT, child_func); // handle SIGQUIT while (1) &#123; alarm(5); // ALARM SIGN sleep(5); &#125; &#125; else &#123; // parent thread if (access(FIFO, F_OK) == -1) &#123; // if unexist then create if ((mkfifo(FIFO, 0666) &lt; 0) &amp;&amp; errno != EEXIST) &#123; printf(&quot;Cannot create fifo file &quot;); exit(1); &#125; &#125; int fdParent = open(FIFO, O_RDONLY); if (fdParent == -1) &#123; printf(&quot;Open fifo file error &quot;); exit(1); &#125; do &#123; signal(SIGQUIT, child_func); // handle the SIGQUIT from parent thread pr = waitpid(pid, NULL, WNOHANG); memset(buff, 0, sizeof(buff)); // reset the buff read(fdParent, buff, MAX_BUFFER_SIZE); // read buff if (strcmp(&quot;&quot;, buff) == 0) continue; if (strcmp(&quot;QUIT&quot;, buff) == 0) exit(0); // if buff equals &quot;QUIT&quot; then quit printf(&quot;%s &quot;, buff); sleep(1); &#125; while (pr == 0); close(fdParent); &#125; exit(0);&#125; 信号量机制 一个海底隧道中只有一个车道，规定同一个方向的可以连续过隧道；某方向有列车过隧道时，另一个方向的列车就要等待，现在东岸和西岸都有列车要过隧道，如果把每个过隧道的列车看作一个进程，为保证安全，使用信号量机制实现正确管理。 使用屏幕输出信息，来表示列车通行情况。 提交形式 代码 运行结果截图 Code12345678910111213141516171819202122232425262728293031323334#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; pid_t A; int sem_id; sem_id = semget(ftok(&quot;.&quot;, &#x27;a&#x27;), 1, 0666 | IPC_CREAT); init_sem(sem_id, 1); A = fork(); if (A == -1) &#123; perror(&quot;Fork error &quot;); exit(1); &#125; else if (A == 0) &#123; while (1) &#123; sem_p(sem_id); printf(&quot;A -&gt; B &quot;); sem_v(sem_id); &#125; &#125; else &#123; while (1) &#123; sem_p(sem_id); printf(&quot;B -&gt; A &quot;); sem_v(sem_id); &#125; &#125; del_sem(sem_id); exit(0);&#125; 12345union semun &#123; int val; struct semid_ds* buf; unsigned short* array;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;sem_com.h&quot;#include &lt;sys/sem.h&gt;int init_sem(int sem_id, int init_value) &#123; union semun sem_union; sem_union.val = init_value; if (semctl(sem_id, 0, SETVAL, sem_union) == -1) &#123; perror(&quot;Initialize semaphore&quot;); return -1; &#125; return 0;&#125;int del_sem(int sem_id) &#123; union semun sem_union; if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1) &#123; perror(&quot;Delete semaphore&quot;); return -1; &#125; return 0;&#125;int sem_p(int sem_id) &#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P operation&quot;); return -1; &#125; return 0;&#125;int sem_v(int sem_id) &#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;V operation&quot;); return -1; &#125; return 0;&#125;","tags":["Linux","进程通信"],"categories":["Linux"]},{"title":"Linux多线程 作业","path":"/2019/05/20/Linux多线程-作业/","content":"要求父进程创建 3 个进程，父进程等待子进程 2 运行完成之后，自行退出；其中子进程 1 运行系统命令“cp &#x2F;bin&#x2F;ls &#x2F;tmp”；等待 2 秒后退出；子进程 2 使用标准 I&#x2F;O 函数打开文件 src_file，向其内写入“this is process 2 ”，之后等待 5 秒后退出；子进程 3 处理为守护进程，每隔 5 秒向日志文件&#x2F;var&#x2F;log&#x2F;messages 写入“this is process 3 ” 提交形式 代码 运行结果截图 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t child, child1, child2, daemon; int i, fd, sid; char* message1 = &quot;this is a process 2. &quot;; char* message2 = &quot;this is a process 3. &quot;; child1 = fork(); if (child1 &lt; 0) &#123; printf(&quot;Child1 fork error. &quot;); exit(1); &#125; else if (child1 == 0) &#123; // child1 thread if (execlp(&quot;cp&quot;, &quot;cp&quot;, &quot;/bin/ls&quot;, &quot;/tmp&quot;, NULL) &lt; 0) &#123; printf(&quot;Child1&quot;); &#125; sleep(2); exit(0); &#125; else &#123; // father thread child2 = fork(); if (child2 == -1) &#123; printf(&quot;Child2 fork error. &quot;); exit(1); &#125; else if (child2 == 0) &#123; // child2 thread if ((fd = open(&quot;./src_file&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; printf(&quot;Open file error. &quot;); exit(1); &#125; write(fd, message1, strlen(message1) + 1); sleep(5); exit(0); &#125; do &#123; child = waitpid(child1, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child1 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); do &#123; child = waitpid(child2, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child2 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); daemon = fork(); // fork daemon openlog(&quot;test_syslog&quot;, LOG_PID, LOG_DAEMON); // open syslog if (daemon &lt; 0) &#123; printf(&quot;Daemon fork error. &quot;); exit(1); &#125; else if (daemon &gt; 0) &#123; exit(0); // father thread exit &#125; if ((sid = setsid()) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;setsid&quot;); exit(1); &#125; if ((sid = chdir(&quot;/&quot;)) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;chdir&quot;); exit(1); &#125; // start make daemon thread umask(0); for (i = 0; i &lt; getdtablesize(); i++) &#123; close(i); &#125; while (1) &#123; // start run daemon thread if ((fd = open(&quot;/var/log/message&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; // get the fildes syslog(LOG_ERR, &quot;open&quot;); exit(1); &#125; write(fd, message2, strlen(message2) + 1); close(fd); sleep(5); &#125; closelog(); exit(0); &#125; exit(0);&#125;","tags":["Linux","多线程"],"categories":["Linux"]},{"title":"6.006 - 4","path":"/2019/05/15/6-006-4/","content":"BST123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145class Node &#123; constructor(value) &#123; this.data = value this.leftChild = null this.rightChild = null &#125;&#125;class BST &#123; constructor() &#123; this.root = null &#125; insert(value) &#123; let node = new Node(value) if (!this.root) &#123; this.root = node return &#125; this._insertNode(this.root, node) &#125; min() &#123; return this._findMin(this.root) &#125; _findMin(node) &#123; if (!node) return null while (node.leftChild) node = node.leftChild return node &#125; max() &#123; return this._findMax(this.root) &#125; _findMax(node) &#123; if (!node) return null while (node.rightChild) node = node.rightChild return node &#125; remove(data) &#123; this.root = this._remove(this.root, data) &#125; _remove(node, key) &#123; if (!node) return null if (key &lt; node.data) &#123; node.leftChild = this._remove(node.leftChild, key) return node &#125; else if (key &gt; node.data) &#123; node.rightChild = this._remove(node.rightChild, key) return node &#125; else &#123; if (node.leftChild === null &amp;&amp; node.rightChild === null) &#123; node = null return node &#125; else if (node.rightChild === null) &#123; node = node.leftChild return node &#125; else if (node.leftChild === null) &#123; node = node.rightChild return node &#125; let min = this._findMin(node.rightChild) node.data = min.data node.rightChild = this._remove(node.rightChild, min.data) return node &#125; &#125; _insertNode(node, newNode) &#123; if (newNode.data &lt; node.data) &#123; if (node.leftChild === null) node.leftChild = newNode else this._insertNode(node.leftChild, newNode) &#125; else &#123; if (node.rightChild === null) node.rightChild = newNode else this._insertNode(node.rightChild, newNode) &#125; &#125; preOrderTraverseTree() &#123; this._preOrderTraverse(this.root) &#125; _preOrderTraverse(node) &#123; if (node) &#123; console.log(node.data) this._preOrderTraverse(node.leftChild) this._preOrderTraverse(node.rightChild) &#125; &#125; inOrderTraverseTree() &#123; this._inOrderTraverse(this.root) &#125; _inOrderTraverse(node) &#123; if (node) &#123; this._inOrderTraverse(node.leftChild) console.log(node.data) this._inOrderTraverse(node.rightChild) &#125; &#125; postOrderTraverseTree() &#123; this._postOrderTraverse(this.root) &#125; _postOrderTraverse(node) &#123; if (node) &#123; this._postOrderTraverse(node.leftChild) this._postOrderTraverse(node.rightChild) console.log(node.data) &#125; &#125;&#125;let bst = new BST()bst.insert(2)bst.insert(3)bst.insert(1)bst.insert(-1)bst.insert(5)bst.insert(-2)// bst.preOrderTraverseTree();bst.inOrderTraverseTree()// bst.postOrderTraverseTree();console.log(bst.min())console.log(bst.max())bst.remove(2)bst.inOrderTraverseTree() result: 123456789101112-2-1125Node &#123;data: -2, leftChild: null, rightChild: null&#125;Node &#123;data: 5, leftChild: null, rightChild: null&#125;-2-1135","tags":["算法"]},{"title":"6.006 - 3","path":"/2019/05/15/6-006-3/","content":"about the heap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Heap &#123; constructor(arr) &#123; this.data = arr.reduce((arr, elem) =&gt; &#123; arr.push(elem) return arr &#125;, []) this.size = this.data.length &#125; isEmpty() &#123; return this.size === 0 &#125; build_max_heap() &#123; if (this.size &lt;= 1) return for (let i = Math.floor(this.size / 2); i &gt;= 0; i--) &#123; // start from the n / 2 because of the elem after n / 2 are all leaves this.max_heapify(i) &#125; &#125; sort() &#123; let result = [] while (!this.isEmpty()) &#123; result.push(this.data.shift()) // pop the max this.size-- this.build_max_heap() // rebuild the heap &#125; this.data = result this.size = result.length &#125; add(value) &#123; this.data.push(value) this.size++ this.build_max_heap() &#125; max_heapify(current) &#123; let left = 2 * current, // get the left child right = 2 * current + 1, // get the right child largest = current // get the max node if (left &lt; this.size &amp;&amp; this.data[left] &gt; this.data[largest]) largest = left // left child is max if (right &lt; this.size &amp;&amp; this.data[right] &gt; this.data[largest]) largest = right // right child is max if (largest !== current) &#123; // if the max node is not the current node ;[this.data[largest], this.data[current]] = [ this.data[current], this.data[largest], ] // swap the value this.max_heapify(largest) // recursive to check the modify child heap if is max heapify &#125; &#125; print() &#123; let str = &#x27;&#x27; this.data.map((i) =&gt; (str += i + &#x27; &#x27;)) console.log(str) &#125;&#125;let heap = new Heap([1, 2, 3, 6, 4, 5, 9, 8, 11, 14])heap.build_max_heap()heap.print()heap.sort()heap.print()heap.add(30)heap.add(12)heap.print()heap.sort()heap.print() result: 123414 11 5 9 4 1 6 8 3 214 11 9 8 6 5 4 3 2 130 14 12 8 6 11 4 3 2 1 5 930 14 12 11 9 8 6 5 4 3 2 1","tags":["算法"]},{"title":"6.006 - 2","path":"/2019/05/15/6-006-2/","content":"sort123456789101112131415161718192021/** * sort array * @param &#123;Array&lt;number&gt;&#125; arr * @returns &#123;Array&lt;number&gt;&#125; */let sort = (arr) =&gt; &#123; for (let i = 1, len = arr.length; i &lt; len; i++) &#123; let j = i while (arr[j] &lt; arr[j - 1]) &#123; ;[arr[j], arr[j - 1]] = [arr[j - 1], arr[j]] if (j == 1) break j-- &#125; &#125; return arr&#125;let arr = [5, 2, 4, 6, 1, 3]console.log(sort(arr)) result:1 2 3 4 5 6","tags":["算法"]},{"title":"6.006 - 1","path":"/2019/05/14/6-006-1/","content":"find the peak.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Find the peek 1D * @param &#123;Array&lt;number&gt;&#125; arr arr * @param &#123;number&#125; i the index to start * @param &#123;number&#125; j the index to end * @returns &#123;number&#125; the peak */let findThePeak = (arr, i, j) =&gt; &#123; let current = parseInt((i + j) / 2) if (arr[current] &lt; arr[current + 1]) return findThePeak(arr, current, j) else if (arr[current] &lt; arr[current - 1]) return findThePeak(arr, i, current) else return arr[current]&#125;/** * Find the peak 2D * @param &#123;Array&lt;Array&lt;number&gt;&gt;&#125; arr the Number[][] array * @param &#123;number&#125; start start row * @param &#123;number&#125; end end row * @returns &#123;number&#125; the peak of the array */let findThePeak2 = (arr, start, end) =&gt; &#123; let current = parseInt((start + end) / 2) let rowMax = findThePeak(arr[current], 0, arr[current].length) // get the index of column // let i = arr[current].indexOf(rowMax) let i = arr[current] .map((i, index) =&gt; i === rowMax &amp;&amp; index) .filter((i) =&gt; i !== false)[0] if (current - 1 &gt;= 0 &amp;&amp; arr[current][i] &lt; arr[current - 1][i]) &#123; // check the left part return findThePeak2(arr, start, current) &#125; else if (current &lt; end - 1 &amp;&amp; arr[current][i] &lt; arr[current + 1][i]) &#123; // check the right part return findThePeak2(arr, current, end) &#125; else &#123; return rowMax &#125;&#125;let arr = [5, 4, 3, 2, 4, 5, 6]let arr2 = [ [6, 3, 8], [3, 2, 1], [4, 6, 1],]console.log(findThePeak(arr, 0, arr.length))console.log(findThePeak2(arr2, 0, arr2.length)) result:6 8","tags":["算法"]},{"title":"document.cookie","path":"/2019/05/06/document-cookie/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041/** * set the cookie * @param &#123;String&#125; name * @param &#123;String&#125; value * @param &#123;Number&#125; day */let setCookie = (name, value, day) =&gt; &#123; let date = new Date() date.setDate(date.getDate() + day) document.cookie = name + &#x27;=&#x27; + value + &#x27;;expires=&#x27; + date&#125;/** * get the cookie by name * @param &#123;String&#125; name */let getCookie = (name) =&gt; &#123; let str = document.cookie.split(&#x27;; &#x27;).filter((i) =&gt; &#123; let result = i.split(&#x27;=&#x27;) return result[0] == name &#125;) return str.length ? str[0].split(&#x27;=&#x27;)[1] : &#x27;&#x27;&#125;/** * check user */let checkCookie = () =&gt; &#123; let username = document.cookie ? getCookie(&#x27;username&#x27;) : &#x27;&#x27; if (username != &#x27;&#x27;) &#123; alert(&#x27;Welcome &#x27; + username) &#125; else &#123; username = prompt(&#x27;please input your username&#x27;) if (username &amp;&amp; username != &#x27;&#x27;) &#123; setCookie(&#x27;username&#x27;, username, 7) &#125; &#125;&#125;checkCookie()console.log(getCookie(&#x27;username&#x27;))","tags":["整理"]},{"title":"Linux基本命令","path":"/2019/04/23/Linux基本命令/","content":"Linux 常用命令 man: an interface to the on-line reference manuals su [options] [username]: change user ID or become superuser useradd [options] LOGIN: create a new user or update default new user information userdel [options] LOGIN: delete a user account and related files passwd [options] [LOGIN]: change user password ps [options]: report a snapshot of the current process. kill [options] […]: send a signal to a process fdisk [options] device: manipulate disk partition table mount: mount a filesystem chown [OPTION] … [OWNER]:[GROUP]] FILE …: change file owner and group chgrp [OPTION] … GROUP FILE …: change group ownership chmod [OPTION] … MODE[,MODE] … FILE …: change file mode bits grep [OPTION] PATTERN [FILE…]: print lines matching a pattern find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point…] [expression]: search for files in a directory hierarchy ln: make links between files gzip, gunzip, zcat: compress or expand files tar: an archiving utility diff [OPTION] … FILES: compare files line by line patch -pnum &lt; patchfile: apply a diff file to an original ifconfig: configure a network interface","tags":["整理","Linux"],"categories":["Linux"]},{"title":"Haskell 命令行参数","path":"/2019/04/22/Haskell-命令行参数/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344import System.Environmentimport System.Directoryimport System.IOimport Data.Listmain = do (command:args) &lt;- getArgs -- get the command let (Just action) = lookup command dispatch -- find the command action args -- do somethingadd :: [String] -&gt; IO ()add [fileName, todoItem] = appendFile fileName (todoItem ++ &quot; &quot;) -- add the todoItemview :: [String] -&gt; IO ()view [fileName] = do -- match the filename contents &lt;- readFile fileName -- read the file let todoTasks = lines contents -- get the contents numberedTasks = zipWith ( line -&gt; show n ++ &quot;: &quot; ++ line) [0..] todoTasks putStrLn $ unlines numberedTasks -- show the itemsremove :: [String] -&gt; IO ()remove [fileName, numberString] = do -- get the filename and the line number handle &lt;- openFile fileName ReadMode (tempName, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; -- create a temp file contents &lt;- hGetContents handle -- get contents from the handle let number = read numberString -- read the String to Number todoTasks = lines contents newTodoTasks = delete (todoTasks !! number) todoTasks -- remove the line of the number hPutStr tempHandle $ unlines newTodoTasks -- putStr into the tempfile hClose handle -- close handles hClose tempHandle removeFile fileName renameFile tempName fileNamedispatch :: [(String, [String] -&gt; IO ())]dispatch = [ (&quot;add&quot;, add), (&quot;view&quot;, view), (&quot;remove&quot;, remove) ]-- runhaskell arags-test.hs view newData.txt-- runhaskell args-test.hs add newData.txt &quot;Say Hello&quot;-- runhaskell args-test.hs remove newData.txt 4","tags":["整理","haskell"],"categories":["Haskell"]},{"title":"Linux文件及文件系统","path":"/2019/04/22/Linux文件及文件系统/","content":"文件类型 普通文件 目录文件 链接文件：类似 Windows 的快捷方式，分软链接和硬链接 设备文件：一般在&#x2F;dev 目录下，一种是块设备文件，一种是字符设备文件 文件属性-rwxrwxrwx r: read w: write x: execute 第一个字符： - : 普通文件 d : 目录文件 l : 链接文件 c : 字符设备 b : 块设备 p : 命名管道，如 FIFO f : 堆栈文件，如 LIFO s : 套接字 之后的三个三位字符组： 第一组代表文件拥有者(u)对该文件的权限 第二组代表文件用户组(g)对该文件的权限 第三组代表系统其它用户(o)对该文件的权限 文件系统类型 ext2 &amp; ext3：ext3 是 ext2 的升级版本 swap：交换分区使用 vfat：DOS 中的系统（FAT12、FAT16 和 FAT32 等） NFS：网络文件系统 ISO9660：光盘文件系统 Red Hat 目录结构 &#x2F;bin: Linux 常用操作命令的执行文件（mv、ls、mkdir），有时与&#x2F;usr&#x2F;bin 一样，放置一般用户执行文件 &#x2F;boot: 操作系统启动时所用到的程序，如&#x2F;boot&#x2F;grub &#x2F;dev: Linux 系统中使用的外部设备，逻辑地址 &#x2F;etc: 系统管理时用到的配置文件和子目录（网络配置文件、文件系统、设备配置信息、设置用户信息等） &#x2F;etc&#x2F;rc.d: Linux 启用和关闭时用到的脚本文件 &#x2F;etc&#x2F;rc.d&#x2F;init: Linux 服务默认启动的脚本（可能用到&#x2F;etc&#x2F;xinetd.d 下的内容） &#x2F;home: Linux 默认的用户工作目录 &#x2F;lib: 系统动态链接共享库 &#x2F;lost+found: 系统遗失的片段存放在此目录 &#x2F;media: 光驱和软驱的挂载点 &#x2F;misc: 从 DOS 下安装的 tools &#x2F;mnt: 光驱、软驱、硬盘的挂载点。也可挂载临时文件 &#x2F;proc: 系统核心与执行程序的信息 &#x2F;root: su 用户登录的主目录 &#x2F;sbin: su 用户常用的系统管理程序 &#x2F;tmp: 临时文件 &#x2F;usr: 类似 Windows 的 Program Files &#x2F;usr&#x2F;bin: 系统用户使用的程序 &#x2F;usr&#x2F;sbin: su 用户使用的管理程序和守护程序 &#x2F;usr&#x2F;src: 内核源码默认放置目录 &#x2F;srv: 存放服务启动后需要提取的数据 &#x2F;var: 服务日志信息 Linux C 编程exec 函数组：执行后，如果出错才会返回-1，否则会取代进程。多进程例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t child, child1, child2, daemon; int i, fd, sid; char* message1 = &quot;this is a process 2. &quot;; char* message2 = &quot;this is a process 3. &quot;; child1 = fork(); if (child1 &lt; 0) &#123; printf(&quot;Child1 fork error. &quot;); exit(1); &#125; else if (child1 == 0) &#123; // child1 thread if (execlp(&quot;cp&quot;, &quot;cp&quot;, &quot;/bin/ls&quot;, &quot;/tmp&quot;, NULL) &lt; 0) &#123; printf(&quot;Child1&quot;); &#125; sleep(2); exit(0); &#125; else &#123; // father thread child2 = fork(); if (child2 == -1) &#123; printf(&quot;Child2 fork error. &quot;); exit(1); &#125; else if (child2 == 0) &#123; // child2 thread if ((fd = open(&quot;./src_file&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; printf(&quot;Open file error. &quot;); exit(1); &#125; write(fd, message1, strlen(message1) + 1); sleep(5); exit(0); &#125; do &#123; child = waitpid(child1, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child1 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); do &#123; child = waitpid(child2, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child2 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); daemon = fork(); // fork daemon openlog(&quot;test_syslog&quot;, LOG_PID, LOG_DAEMON); // open syslog if (daemon &lt; 0) &#123; printf(&quot;Daemon fork error. &quot;); exit(1); &#125; else if (daemon &gt; 0) &#123; exit(0); // father thread exit &#125; if ((sid = setsid()) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;setsid&quot;); exit(1); &#125; if ((sid = chdir(&quot;/&quot;)) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;chdir&quot;); exit(1); &#125; // start make daemon thread umask(0); for (i = 0; i &lt; getdtablesize(); i++) &#123; close(i); &#125; while (1) &#123; // start run daemon thread if ((fd = open(&quot;/var/log/message&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; // get the fildes syslog(LOG_ERR, &quot;open&quot;); exit(1); &#125; write(fd, message2, strlen(message2) + 1); close(fd); sleep(5); &#125; closelog(); exit(0); &#125; exit(0);&#125;","tags":["整理","Linux"],"categories":["Linux"]},{"title":"Block-level function","path":"/2019/04/17/Block-level-function/","content":"在某个论坛有人问了下面的一段代码123456789101112function f() &#123; console.log(&#x27;outside&#x27;)&#125;function a() &#123; f() &#123; function f() &#123; console.log(&#x27;inside&#x27;) &#125; &#125;&#125;a() 问的是为什么在浏览器中是f is not a function。这个问题其实很好回答，存在函数提升，但是仔细想想又不对，因为函数提升是把整个函数都提升到当前作用域，所以按理来说 f 并不会是undefined。如果按照函数提升的话，结果应该是像这样： 12345678910111213function f() &#123; console.log(&#x27;outside&#x27;)&#125;function a() &#123; function f() &#123; console.log(&#x27;inside&#x27;) &#125; f() &#123; &#125;&#125;a() 所以结果应该是inside才对，用 IE7 可以发现结果确实是 inside。那这里为什么是 undefined 呢？后面那位兄弟说在阮一峰的《ES6 入门》中说道，ES6 规定块级作用域中的函数定义规定为函数表达式。如果是定义为函数表达式的话，那就会像这样： 1234567891011121314function f() &#123; console.log(&#x27;outside&#x27;)&#125;function a() &#123; var f f() &#123; var f = function f() &#123; console.log(&#x27;inside&#x27;) &#125; &#125;&#125;a() 这么一来这个undefined就可以解释了，因为只存在变量提升，而还未定义，所以就会出现undefined。但是那本书后还加了一句，浏览器并未遵循实现。后面在 starkoverflow 上找到了一个老哥的回答，他的解释为这是因为strict &amp; non-strict mode的不同。 let 和 const 在两种模式下行为一样 function 在两种模式下的行为就不是一样的，因为浏览器会扩展非严格模式，从而兼容老代码。 所以，在strict mode中，第一段代码输出的是outside，non-strict mode中就会报错，因为会变成下面这样： 123456789101112131415function f() &#123; console.log(&#x27;outside&#x27;)&#125;function a() &#123; var f // function-scoped f() &#123; let f1 = function () &#123; console.log(&#x27;inside&#x27;) &#125; // block-scoped f = f1 &#125;&#125;a() MDN 中关于Block-level functions in non-strict code的也只有一句话： Don&#39;t.","tags":["整理"]},{"title":"巴黎圣母院大火","path":"/2019/04/16/巴黎圣母院大火/","content":"又一次的见证历史。 卡西莫多失去了他心爱的姑娘，也失去了他心爱的钟楼。 废墟中的十字架依旧闪发着光芒 PS： 看到一条推，说你看大火都没有把十字架给损毁，难道你还不相信上帝吗？下面回：因为金的熔点比木高很多。XD","tags":["history"]},{"title":"随便聊聊","path":"/2019/04/15/随便聊聊/","content":"一篇文章昨天晚上看了某乎的一篇文章，叫《比 996 更该死的那些人》，里面的开头： 这几年真的觉得这个世界真的已经变得不可救药了勤劳和奋斗不仅不再被传颂和赞扬，竟然成了被鄙视，被视作愚蠢的品质。而享乐，投机取巧成这些在过去难以启齿的行为，成了光明正大，人人争相炫耀的东西。 虽然这篇文章我开了开头就没看了，但是还是让我感触颇深，我不赞同第二句，但是第三句我是非常赞同的。在以前我是不会羡慕别人的，不知道从什么时候开始，我会越来越羡慕那些比我强、过的比我好、智商比我高的人。是欲望变了吗？我觉得是的。那个无欲无求的日子，我是不想去回忆的，因为对我来说，和坐牢一样。 从不会去鄙视那些勤劳和奋斗的人，因为他们不知道什么时候就已经追上你并且超过你了，学如逆水行舟，不进则退，但是我实在无法理解的是，投机取巧，为什么在某些人眼里成了政治正确。炫耀享乐，这个我还是可以理解的，毕竟大部分的人还是喜欢被别夸，被别人羡慕嫉妒，当然也有真正是为了分享快乐。 投机取巧的话，不知道是否是因为圈子不同，我觉得我周围认为投机取巧的人是正确的人还不少，甚至于在学校加大监管的情况下，组队进行“帮助”，并且在成绩还可以的时候，去蛊惑那些认真考试但成绩不佳的同学，试图拉他们下水。实在是不能理解那些人心里的想法，是为了让别人顺从自己从而获得心里的快感吗？我不太懂。似乎各大高校都有这种人的存在，这到底是为什么呢？ 一张图片已经很久没有这样让人舒适的天气了，温度刚好，湿度刚好，风力刚好，阴天，简直完美。上一次让我有这种感觉的时候，还是在高一，也许是高二，青涩懵懂的高中时代，已经过去三年了。高中阶段，可以说是我目前最快乐的阶段，没有学习压力，没有生活压力，一个人住，晚上想出来溜达就出来溜达。 一件事情同样是某乎上的一件事，《如何看待杭州一女子月薪 4K，买两万元名牌包被丈夫指责这一事件？》： 林海觉得，妻子和其他的女人不一样，不会想要买这个买那个，不贪慕虚荣。 然而，就在前几天，妻子收到一个包裹，打开以后，是一个包装精美的奢侈品包包。据妻子解释，是她找人代购的，花了四个月工资。“一瞬间感觉我已经不认识眼前的这个女人了。四个月的工资就买个包吗？那她跟其他那些爱慕虚荣的女人有什么区别呢？我现在事业刚刚有点起步，我们家的收入状况比起刚结婚时，是好了一些。但离“土豪”的程度还很远啊！” 据林海介绍，夫妻两人都是工薪阶层。妻子每个月工资拿到手五千不到，而自己的收入全看绩效，每个月并不稳定。这让他很无奈：“房贷大部分是我还的，都不知道要还多少年。这下好了，小半年，都要靠我一个人了。”两人现在还没有孩子，但对孩子的态度，他也有了改观：“没孩子也好，有了孩子，又是一笔支出。养孩子要买奶粉钱，还要买包，那能花得过来吗？” 妻子回复：心寒。他根本没有看到我这几年为家里的付出。我想不明白，我用我自己的积蓄，用我自己的钱，给自己买了人生当中第一个奢侈品，有问题吗？我三十多岁了，跟他谈恋爱到结婚已经八年了。没伸手问他要过一分钱，他也从来没有送过我一个超过 700 元的礼物。那天我闺蜜要跟他老公去法国旅行，问我有什么想要带的吗？我也是狠狠心，让她帮我带了这个包包回来。这个包我在网上已经反反复复看了大半年了，我都没有勇气跟老公提出来说，老公能不能把这个包送给我？我自己刷卡买的！ 这件事下的回答，很有趣，我也看了很多。有的人，是从家庭的观点出发的；有的人，是从女人的角度出发的；还有的人，是从男人的角度出发的。 对于一个家庭来说，我觉得很少有哪个家庭，会为了买一个不必要的东西而花费一个人四个月的积蓄。可能是自身家庭的原因，我觉得一个家庭，积蓄的多少决定了可以承担的风险有多大，因为你不知道明天和意外哪个先来，如果出了意外的话，家里的积蓄可以让你不那么艰难。所以，对于一个家庭来说，我觉得花费一个人四个月的积蓄，去买一个包，这是非常不正确的，奢侈品不是人人都需要的，也不是必要的，也许是虚荣心，一时眼红买了一个包，这是冲动，但人和动物的区别，就是可以克制自己。也像有的评论说的那样，你穿的很差，背着一个很好的包，谁都觉得背的是 A 货，但是如果你穿的很好，背着一个 A 货，大家肯定都认为你背的是正品，这样看来，买这个包也没什么必要了。而且，婚后的收入是共有的，你的开销，实际上有你伴侣的一半，所以较大的开销我觉得可以双方商量一下，再考虑是买还是不买。还有的评论说，在买的情况为 0%的时候，为什么要商量？这就好比不管你同不同意我都要买，这不是耍无赖吗？不考虑别的感受，私自做决定，我觉得会对双方关系造成很大的影响。 对于一个男人来说，自己辛苦挣钱还房贷，常年吃不到一顿好的，在这种情况下，自己的老婆花将近半年的钱去买一个包，你心里会怎么想？如果照着女方的观念，我花的是我自己的钱，凭什么管，那男方完全也可以进行一下这种操作，贷款两人平分，其他开支各付个的，但是这样的话，就会有某些人跳出来说：那老娘还结婚干什么。我觉得有个评论说的很对，妻子的不幸，不是丈夫造成的： 妻子的不幸，不是丈夫造成的。妻子的不幸是商家，媒体，给妻子提供了看上去精美，却实质有毒的思想和生活。丈夫的不幸是商家，媒体，用有毒的思想改造了他妻子，让他失去了最后的依靠。大众只要接受了商家的教育，媒体的洗脑，ta 们这辈子注定活得悲惨，没有价值。当无产阶级省吃俭用，存钱半年，甚至一年，买入人生第一件奢侈品。这恰恰不是她们获得幸福和希望的起点，而是走向悲惨和痛苦的开端。在资产阶级的残酷压迫下，无产阶级的相互扶持，从来就不是鸟语花香，风轻云淡。在家庭竭力抵御社会压迫时，任何一方的软弱和逃离，都只会让脆弱敏感的联盟走向瓦解。 我不知道多少人，每天在微博和抖音上混着，我也不知道他们到底是经济基础太好，整天不上班，还是太懒，整天不想上班。微博和抖音，可以说我特别讨厌这两个东西，一个是给人洗脑，一个是消费碎片时间。简单来说，有人问为什么现在的男生&#x2F;女生质量那么差？也许是因为他们的标准太高了，整天在微博上看别人的男朋友女朋友，然后当做自己的择偶目标，也不是说不行，但是你得先看看自己有没有这个实力去匹配这类目标。都说门当户对是旧社会，但是，门当户对确实还挺重要的，经济基础好的人和经济基础差的人，消费观是不一样的。你让一个月平均消费 1k 的人，去消费一个 20k 的东西，而且还是一个不必要的东西，我觉得他是绝对不会去消费的，但是你让一个月均消费 10k 的人，20k 对他来说就是两个月而已。 所以，现实中找不到对的人，就期待去网上寻找自己的真爱，就会出现“见光死”，被骗财骗色等等情况，然后又去微博上，继续看着他们心目中的男神&#x2F;女神。看得越多，商家媒体就越高兴，这都是流量啊，然后找男神&#x2F;女神代言个什么产品，就会有很多人去买，流量转化为利益，男神&#x2F;女神也开心，然后购买了产品的人也觉得自己和男神&#x2F;女神用同款，所以自己也开心，皆大欢喜，质量和性价比什么的，滚一边去。这就直接导致了为什么现在这么多自媒体，为什么这么多人想红，我觉得原因都在这。 再就是抖音，简直是谋杀。你的时间不知不觉中就会被它吃掉，而且你丝毫不会察觉，短视频，刷了一时爽，一直刷一直爽。年轻人，不应该使用这两个东西，当然也不应该使用某乎，以前某乎上确实有许多干货，但最近看来，还是不用去碰了，到处都是无营养的帖子，评论玩段子，偷换概念。年轻人嘛，就应该多学习，多看看新闻，了解下还有许多水深火热的底层人民等着你们去拯救，而不是和某乎一样，人人 985 月薪 30k。 对于一个女人来说，丈夫这么多年来没有送过自己一个礼物，我也会觉得这个丈夫心里没有我。自己从一穷二白的时候就决定要跟他，到现在都不能用自己的积蓄去买自己喜欢的东西，看着别人和自己的爱人到处旅游，也是很羡慕嫉妒的。所以，自己偷偷攒了半年，给自己买了一个心爱的礼物，我觉得没有任何不妥。女人化妆大部分时候不是为了给男人看的，而是为了给其他女人看，不能让自己被其他女人比下去，这样想的话，一个好的包似乎也成为有必要的了。 对于这件事，我觉得双方都有错，但都在情理之中。作为丈夫，妻子这么多年的陪伴连件小礼物都没有，换做是我我也会内疚，所以我们应时不时的给点小惊喜（但是前提是得有自己的小金库），有空的时候多交流，多想想对方需要什么，自己能否做到，尽自己可能的去做，这才是个称职的丈夫。作为妻子，不应该把家庭和丈夫绑在一起，可以看出妻子每个月 4k 还可以攒出小金库，说明这个家的房贷大部分是靠丈夫来支撑的，所以或许她的观念是，丈夫的钱他自己用了，所以我的钱我自己用没什么不妥，但是家庭是需要每个人付出的，如果你的钱大部分拿来还房贷，他花一两万去买个表，相信也会心里憋屈。夫妻双方应多沟通，特别是这种算是比较大的事情，一定要双方达成共识，如果瞒着一方，这就算欺骗。 一些年纪 人总是会回忆过去的，但不能待在过去 不知道多少岁： 听奶奶说我从桌子上摔地上了，头着地，有个很大的包。 大概一岁吧，不知道有没有一岁，我只记得父亲用抓了只蜻蜓放在名片盒里让我玩，母亲在喂我吃饭，那时我的脸还挺肥的。 大概是三四岁？记不太清：开始上学前班了，记不得多少这时候的事情，只记得父亲给我买了一个熊的面包，我很喜欢。或许这段记忆也是梦里的。 五岁，一年级：在明珠学校读的，学校进门有个小店，那个老板在玩红警，我现在都记得。也许是那时候对电脑产生了兴趣。开学，父亲带我去教室，因为没有带水杯，所以用矿泉水瓶去给我接热水，当然了，矿泉水瓶怎么可以接开水，一碰就瘪了，所以就没有喝。到了教室，父亲只说了句，坐着啊，我走了。然后我就看着他走了，我还是挺害怕的，但是周围同学都在那坐着，我也就好好坐着了。 六岁，二年级：开始自己走路上学，其实也不远，和父母上班的地方也近，但是每天起的比较早，就自己去上学了。学校有一栋建筑物后面是一片草地，上面有三叶草（只记得形状是三篇叶子），同学说是甜的，我也尝了尝，三叶草不难吃，反而有清香的味道。做过两件事，第一件趴校车车底，第二件和同学打弹珠忘记回家。也不知道当时为啥趴校车车底，如果车子开动了，不敢想会有什么样的结果。哦，还有从后山翻进学校，被蚊子叮的很多包。还碰见了一个从外地来的同学，应该是家境不怎么好吧，学校帮了很多。那时候最喜欢的事就是，站在楼底，然后抬头望着天空，那时候天还很蓝，楼也没有那么多反光的玻璃，看着云就好像楼要压到我身上，或者楼要往那边倒了一样，很奇妙，经常看的忘记时间，看久了脖子痛（当时为什么不躺着呢）。当时似乎班上还有个家境很好的同学，跟着他有辣条吃，于是天天基本就跟在他后面玩。 七岁，三年级：转学了，应该是育英学校，因为父母工作的地方换了。吃不到辣条了，但是会偶尔从家里拿一两块钱，冬天的时候去校门口买油炸火腿肠。校门口还有画糖画的，似乎我还在学校吃食堂吃过一段日子。班上同学我就认识一两个，现在只记得一个姓赵的了。记得那时候中午快迟到了，跑步上课，然后撞到了一个一年级的，导致门牙坏了，拔了四颗牙齿，和吸血鬼一样。学校后门有一种花，上次在广州也见着了，橘黄色的，长条。也是同学跟我说是甜的，我也摘了从后面吮吸，还真是甜的。学了画画，但是实在是没有天分。还记得那时候查发热，每个人进校门都要被红外线温度计测一下，我似乎有点症状，然后就被领到保安亭了，后面趁着没人就跑出来了，天生就不喜欢去医院。 八岁，四年级：转学，去锦华实验了，从那时候起有校车坐了，因为是住在奶奶家。应该也是在食堂吃饭的，依稀记得撞了个高年级的然后被骂了，饭菜一般。那时候有课外活动了，想选计算机来着，可惜人满了，所以一开始选了葫芦丝，后面又去学毛笔了。还在校庆的时候上台表演了一下葫芦丝，现在应该是不会了，只记得那几个唱名是怎么放的。偶尔下大雨的时候校车也会来，然后通知我们回去，不用上课，那时候我就会在家待着干点其他的。后面跑去学毛笔字，也是没学多久就不学了，因为没兴趣，只记得高年级的同学总是叫我们低年级的去洗砚台，我觉得自己的砚台就应该自己洗。比较开心的事是坐校车，因为可以看见外面，尽管没什么风景，但是我每次都是在最后那站，所以后面都是一个人在一辆车里，吹着风。 九岁，五年级：转学，去龙丰学校了，听说原来的班主任还来我家问我为什么没来上课，因为学费涨了负担不起，所以只能转学读一个学费低一点的学校，班主任说我的成绩可以和学校申请减免学费，但是还是没有回去。是一个不太好的学校，这年学会了进网吧，学校后山是一个部队，和同学进去想游泳，结果被撵出来了，还被不知道什么蚂蚁咬了肿了很大一块。我弟弟妹妹也在我这个学校读学前班，所以放学的时候都是我把他们带回来。刚报道的时候，不知道是哪个班级，就随便进了一个，那个老师把我安排在了最后面，周围都是看起来不善的同学，他们下课就打牌，上课吃零食。后面又换了一个班，那个班还不错，同学都比较友善。记得上音乐课，老师放《土耳其进行曲》给我们听，然后说里面有三种片段，要我们听了之后把片段写出来，我写的 ABCBAB，但是其他同学都没有最后的 B 片段，最后老师说班上只有我一个人是正确的，我很开心。那时候还认识了一个好朋友，但那时也没有什么联系方式，所以就断了。 十岁，六年级：转学，回老家了，我小学六年读了五个学校，但是我很少跟人提起过。这五年其实也挨了不少的打，也拿了不少的奖，但都不太值得回忆，就不打算写了。奖状的话，似乎有一两斤重。一开始去那个学校，还要给我做一个测试题，不得不说，老家的教育水平和深圳还是有很大差距的，他们六年级学的东西我四五年级就学完了。但是不知为什么，我还是得去完成小升初的考试，所以就读了六年级。六年级就认识了比较多的同学朋友了，但是唯一让我不爽的是，每天七节课，只有语文数学和英语，偶尔说有体育课，其实就是让我们去拔杂草。忘记哪个周末，和班里的同学约好下课去网吧，结果有个同学没来，跑去告老师了，然后第二天我们就在办公室站了一上午。数学老师很严，其他老师没什么印象，只记得数学老师严，上学第一天就把我的数学书给撕了，因为他上午说带草稿本，而我没带，因为我上午根本就还没来班上，也不听你解释，直接撕，估计是杀鸡儆猴吧。我最讨厌那些不让别人说话，自己判断的人。似乎那年我还学过一点奥数，不太记得了，小房间，幼儿园的那种桌椅，写字十分不舒服。后面听说那个以前玩的好的同学还找我，听说我回老家了，一直在等我什么时候回来。 十一岁，初一：升初中了，开始住老师家了。似乎就是这个阶段我是无欲无求的，每天两点一线，吃饭，睡觉，上课，没有什么其他的事情。老师还不错，化学老师是班上一个同学的爷爷，物理老师是班上一个同学的父亲，语文老师的女儿后面也来我们学校了，后面听说物理老师当了副校长，化学老师不知道退休了没有，老曾，怀念，还有英语老师，那次回去在路上看见了，可惜我在车里，她在路上，还有在路上碰见同学去上课，还能认出我，那都是高中时候的事情了。初一没什么特别的事情，大家都安安分分的上课，同学们也都相互认识，班长是个女生，现在成绩也不错，令我很敬佩的女生，如果现在碰见她，还是会叫一声老班长。 十二岁，初二：分班了，有些成绩差的同学都出去了，就留下了大概五六十个人，和深圳的标准一班四十人不同，老家多的有八九十人，少的才四五十人。教室也换了，在校长办公室楼上，偶尔下楼会碰见校长。和我们一起的就十八班，在隔壁。平平淡淡，上课想听就听一下，不想听就看点杂志，困了就睡一下，还参加了一个歌唱比赛，似乎拿了奖。那年学校有计算机课了，我还记得开机是七喜电脑，还有长虹电脑，我们在那学 flash 动画，那时候觉得很难，然后有个示例动画，好像是熊猫人，很流畅，还有剧情，虽然只有短短的五分钟。似乎是这年，我每天中午不想在住的地方待着，我就选择去学校睡，不记得是不是被老师跟踪过了，可能是，也可能不是。初二物理竞赛还拿了二等奖。 十三岁，初三：又搬到初一那栋楼了，听说校长那个已经是危房，不能住了。老师们那年到临川一中学习，回来之后马上给我们教室的喇叭装了一个开关，这样中午放学如果拖课，就可以把喇叭关了，这样就听不见那嘈杂的音乐了。那年老曾来班上了，我们这是初三才学化学，如果有人上课凳子坏了掉地上了，他还会从办公室拿锤子过来给我们修凳子。生物老师是个很奇特的东西，初一的时候他教我们地理，初二的时候他教我们生物，初三的时候看见他在别的班当体育老师，他脾气很暴躁，但是教的确实很好，如果我们不学习也是会真的生气，但是他从不打人，只打多媒体的桌子，铁皮的，有时候一巴掌可以打凹进去。英语老师很好玩，也跟我们讲她儿子在国外上大学的趣事，一直也想回去看看他们。有天晚上，我睡觉，然后看着窗外，然后突然有个橘黄色的圆环从我眼前飞过，我爬起来却看不见了，我觉得那是外星人的飞船吧。记得那时还得考个物理化学实验，物理实验因为做过很多次了，所以比较快，但是化学的话，由于从没摸过试管烧杯什么的，手滴定的时候一直在抖，旁边老师都看笑了，还好没什么大碍。 十四岁，高一：我似乎是班上唯一一个来临川一中的，但是我不是班上成绩最好的。临川一中教会了我很多东西。高一的时候入学还要个分班考试，也不知道是不是真的会看，因为考试的人比较多，两三千号人，而且考完过几天就分班了，所以我觉得是没有看的。学校还有社团，通过社团和贴吧认识了好大波的朋友，高一的时候还是很愉快的。虽然也是住在别人家，但是管的不是很严，所以晚上可以晚点回去，在外面吃点东西。班主任是黄老师，教数学的，挺搞笑的一个人，后面分班之后跑去教文 A 班了，今年招不到学生的时候还让我帮他招一些学生。政治历史老师没什么印象，因为从来不听课，语文老师倒是印象挺深的，他不怎么讲课，没激情，经常上课的时候跑去他班上管事，因为他觉得他班上太吵了。后面申请换了个语文老师，新老师太有激情了，导致一节课下来很累。夏天，有一天狂风骤雨，然后有爆炸声，似乎是某个烟花厂被雷电给打了，起火爆炸了。 十五岁，高二：文理分班，从六楼去二楼了。这一年，撒贝宁来了，去做了个志愿者；这一年，饶 boss 还是 boss；这一年，朋友们都还没毕业。班主任换成了老吴，我回去看他时还和他聊起同学们，他说：天天关照的同学没有一个回来看我的，反而是你们这些整天被我骂的人回来看我们。这年结束的时候，很多朋友都毕业了，贴吧没了他们也冷清了，就连学校我都觉得少了点熟悉的感觉。但是认识了新的同学，龙兄、谢老板、隔壁老王、隔壁老吴和小焯等。我们这几个算是班上最调皮捣蛋的了，但是这么多年过去了，我们几个似乎混的也还不错，有早早去工作的了，也有准备考研的，一直也没机会聚一聚，只能到某个地方，就去见某个人。龙兄和谢老板在班上还有个外号叫“天龙八部”，因为两个人一起被没收了八部手机。 十六岁，高三：八月中就开始补课了，高三正式开始。校长也退休了，新校长上任三把火，治理了一波不学习的同学，也包括我。可能是对学科没多大的兴趣吧，所以不怎么想学，所以在老师眼里就是那种不学习，整天不知道在干什么的孩子。那年买了第一本的编程书，是关于 PHP 的，但是由于没有电脑实际操作，所以看不了多少。当时班上有一个同学，高一就开始自学信安了，当他在看密码学，XSS，这种书籍时，我才刚开始接触这东西；人家在高中毕业就经济独立了，而我还不知道我的明天在哪。也是从那时开始，我羡慕别人有技术，失去了纯真。当时与父母谈过这个问题，他们还是劝我说读个大学更重要，现在想想，他们是对的，如果我当时不去念大学而是去学技术，万一技术没学好，我连后路都没有了。这一年，有的朋友也回去高考了，他们是贵州的，来我们学校学习，然后回去考贵州卷，记得当时我们全国一卷，分数线是全国最高的。毕业那天，以前的传统是撕书嘛，那天不知道谁偷偷运了个烟花进来，有幸欣赏了一波烟花秀。毕业那天，我们去喝酒，但是最后，也是我们这几个平常不怎么学习的人去陪着老师走了最后的一段路，聊了很多，老师也跟我们说，其实你们不是智商低，你们只是不愿学，以后努力吧，毕竟上了大学，就没有老师可以管你们了。直到现在，我们也会有时间就去一起去看看曾经的老师，曾经的学校，看看曾经的人，曾经的物。 FIREWORKS SHOW 到了大学，学到了自己喜欢的学科，我觉得很荣幸。 终于可以开心的码代码，算是完成了一个梦想吧。","tags":["雜談"]},{"title":"归纳法","path":"/2019/04/14/归纳法/","content":"自然数上的一般归纳原理假设$P$是自然数上的一个性质，则如果 $P(0)$成立 – base case 对所有的自然数$k$，$P(k)$蕴涵$P(k+1)$ – induction step 则$P(n)$对所有自然数$n$成立 $$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ [P(k)]\\\\frac{P(0)\\ P(k+1)}{P(n)}$$ $[P(k)]$为归纳假设，$k$不能出现在$P(k + 1)$的任何假设中 定理：每个自然是要么是偶数，要么是奇数。用归纳法来证明： 0 是偶数 -&gt; 0 是偶数或奇数 假设 k 是偶数或奇数，证明 k + 1 是奇数或偶数： k 是偶数，则 k + 1 是奇数 k 是奇数，则 k + 1 是偶数 得证 自然数上的完全归纳原理假设$P$是自然数上的一个性质，则：如果对每个自然数$k$，假定$P(i)$对所有自然数$i(i &lt; k)$成立，则可以证明$P(k)$成立 $$[\\forall i &lt; k.P(i)]\\\\frac{P(k)}{P(n)}$$ $k$不能出现在其他前提条件的其他假设中 定理：所有$n \\geq 2$的自然数都可以写成素数的乘积$n &#x3D; p_1…p_k$对$n$进行完全归纳： $n$是素数，那么$n &#x3D; n$ $n$不是素数，则$\\exists\\ n % m &#x3D; 0(1 &lt; m &lt; n)$所以$n &#x3D; m * \\frac{n}{m}$，对$m$和$\\frac{n}{m}$再次归纳，得$m &#x3D; p_1…p_k$且$\\frac{n}{m} &#x3D; q_1…q_k$得$$n &#x3D; m * \\frac{n}{m} &#x3D; p_1…p_kq_1…q_k$$ 得证 字典序归纳原理假设$P$是自然数序对上的一个性质，则：如果对每个自然数序对$(m, n)$，假定$P(m’, n’)$对所有的$(m’, n’) &lt; (m, n)$成立，则可以证明$P(m, n)$成立 结构归纳法形式 1假设$P$是某个文法产生的任一表达式$e$上的一个性质，则： 对每个原子表达式$e$，证明$P(e)$为真 对直接子表达式为$e_1,…,e_k$的任何复合表达式$e$，证明如果$P(e_i)(i &#x3D; 1, …, k)$都为真，则$P(e)$也为真 形式 2假设$P$是某个文法产生的任一表达式$e$上的一个性质，则： 对每个原子表达式$e$，证明$P(e)$为真 对任何表达式$e$的任何子表达式$e’$，证明如果$P(e’)$都为真，则$P(e)$也为真 表的结构归纳法假设 P 是元素类型为$\\tau$的表(list)上的一个性质，则： $P([])$, []表示空表 对类型为$\\tau$的所有元素$y$以及类型为$\\tau$ list 的表$ys$都有$P(ys)$蕴涵$P(y::ys)$，则$P(xs)$对所有类型为$\\tau$ list 的表$xs$成立$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ [P(ys)]\\\\frac{P([])\\ P(y::ys)}{P(xs)}$$$y$和$ys$不能出现在$P(y::ys)$的其他假设中 定理：所有的表都不等于自己的表尾对$xs$结构归纳： $\\forall x.[x] eq []$，两个表是相等的当且仅当它们具有相同的长度且对应的元素也相等 假定$\\forall x.x::ys eq ys$成立，并对于任意的$y$和$ys$证明$\\forall x.x::(y::ys) eq y::ys$，所以只要证明两边表尾不相等：即证明$y::ys eq ys$不适用于无穷表，$[n, n, …]$等于它自己的表尾 定理：对于所有的表 xs 和 ys，有$len(xs@ys) &#x3D; len\\ xs + len\\ ys$（@连接运算）对 xs 结构归纳： $len([]@ys) &#x3D; len[] + len\\ ys$成立 假定$len(xs\\ @\\ ys) &#x3D; len\\ xs + len\\ ys$成立，那么我们可以证明对于所有的$x$和$xs$，有$len((x::xs)\\ @\\ ys) &#x3D; len(x::xs) + len\\ ys$也成立$$len((x::xs)@ys) &#x3D; len(x::(xs@ys))\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; 1 + len(xs@ys)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; 1 + (len\\ xs + len\\ ys)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; (1 + len\\ xs) + len\\ ys\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; len(x::xs) + len\\ ys$$ 树的结构归纳法假设 P 是类型$\\tau$ tree 的树的一个性质，则： $P(empty)$ 对于所有类型为$\\tau$的元素$x$以及类型为$\\tau$ tree 的树$t_1$和$t_2$都有，$P(t_1)$和$P(t_2)$蕴涵$P(node(x, t_1, t_2))$$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ [P(t_1), P(t_2)]\\\\frac{P(empty)\\ P(node(x, t_1, t_2))}{P(t)}$$$x$、$t_1$和$t_2$不能出现在$P(node(x, t_1, t_2))$的其他假设中 证明上的归纳假设一个公式可以证明的，那么：推理规则：若一组公式可证，则另一个公式也证$\\frac{A_1…A_n}{B}$，如果$A_1,…,A_n$（前提）都可证，那么 B（结论）也可证 相等性的自反公理： $e &#x3D; e$ 相等性的传递规则：$\\frac{e_1 &#x3D; e_2\\ e_2 &#x3D; e_3}{e_1 &#x3D; e_3}$ 所以一个证明可以定义为一个公式序列，该序列中的每个公式都是公理或是由先前的公式通过一条推理规则得到的结论。可以有两个方法来归纳： 对公式序列的长度进行自然数归纳法 把证明看成树，所用的公理看叶节点，推理规则看成内部节点，由对$A_1, …, A_n$的证明来构造对$B$的证明 在某个证明系统中，证明对每个证明$\\alpha$，$P(\\alpha)$为真： 对该系统中的每个公理，证明$P$成立 假定对$\\alpha_1,…,\\alpha_k$，$P$都成立，证明$P(\\alpha)$也成立，则$\\alpha$是$\\alpha_1,…,\\alpha_k$延伸出的一个证明 证明系统的可靠性：在公式的某种特定解释下，每个可证的公式都为真。","tags":["学习"],"categories":["Math"]},{"title":"等式公理","path":"/2019/04/14/等式公理/","content":"公式: $$P{Q}R\\ ({P}Q{R})$$P 和 R 都是一阶公式, 如果前提条件 P 在执行 Q 前成立, 则执行后得到满足条件 R 的状态部分正确性断言: 如果 P 在 Q 执行前为真, 那么, 如果 Q 的执行终止,则终止在使 R 为真的某个状态终止性断言:如果 P 在 Q 执行前为真, 那么 Q 将终止在使 R 为真的某个状态赋值公理: $$\\vdash P_0 {x:&#x3D;f} P$$ 推理规则的表示$$\\frac{premise -&gt; f_0, f_1, …, f_n}{conclusion -&gt; f_0}$$ 推理规则 Rules of Consequence:$$\\frac{P{Q}R,\\ R\\rightarrow S}{P{Q}S}\\ \\ \\ \\ \\ \\frac{P{Q}R,\\ S\\rightarrow P}{S{Q}R}$$ Rule of Composition:$$\\frac{P{Q_1}R_1,\\ R_1{Q_2}R}{P{Q_1, Q_2}R}$$ Rules of Iteration:$$\\frac{P\\ &amp;\\ B{S}P}{P\\ {while\\ B\\ do\\ S}\\ eg B \\ &amp;\\ P}$$ 等式公理 代换: $[N&#x2F;x]M$ 表示表示 M 中的自由变元 x 用 N 代换的结果, N 中的自由变元代换后不能成为约束变元 约束变元改名: $\\lambda x:\\sigma .M &#x3D; \\lambda y:\\sigma.[y&#x2F;x]M$ 例如:$\\lambda x:\\sigma.x + y &#x3D; \\lambda z:\\sigma .z+y$ 等价公理: 计算函数实际就是在函数中使用实在变元替换形式变元, $(\\lambda x:\\sigma.M)N &#x3D; [N&#x2F;x]M$ 同余性规则: 相等的函数作用于相等的变元产生相等的结果, $\\frac{M_1&#x3D;M_2,\\ N_1&#x3D;N_2}{M_1N_1&#x3D;M_2N_2}$","tags":["学习","type theory"]},{"title":"简陋VDOM","path":"/2019/04/11/简陋VDOM/","content":"一个简陋的 VDOM希望以后会慢慢完善吧… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970let data = &#123; tag: &#x27;div&#x27;, children: [ &#123; tag: &#x27;span&#x27;, children: [ &#123; tag: &#x27;#text&#x27;, content: &#x27;hello world&#x27;, &#125;, ], &#125;, &#123; tag: &#x27;p&#x27;, children: [ &#123; tag: &#x27;#text&#x27;, content: &#x27;This is a paragraph!&#x27;, &#125;, &#123; tag: &#x27;h1&#x27;, children: [ &#123; tag: &#x27;#text&#x27;, content: &#x27;This is a H1 tag&#x27;, &#125;, ], &#125;, &#123; tag: &#x27;h6&#x27;, children: [ &#123; tag: &#x27;#text&#x27;, content: &quot;and I&#x27;m h6&quot;, &#125;, ], &#125;, ], &#125;, ],&#125;class VDOM &#123; constructor(data) &#123; this.tag = data.tag this.children = data.children this.content = data.content &#125; static render(data) &#123; let _this = new VDOM(data) if (_this.tag === &#x27;#text&#x27;) &#123; return document.createTextNode(_this.content) &#125; let node = document.createElement(_this.tag) _this.children.map((child) =&gt; node.appendChild(VDOM.render(child))) return node &#125;&#125;let diff = (root, oldV, newV, current = 0) =&gt; &#123; if (!oldV) root.appendChild(newV) else if (!newV) root.removeChild(root.childNodes[current]) else if (newV.tag !== oldV.tag || newV.content !== oldV.content) root.replaceChild(new VDOM(newV).render(), root.childNodes[current]) // 递归判断 else for (let i = 0; i &lt; newV.children.length || i &lt; oldV.children.length; i++) diff(root.childNodes[i], oldV.children[i], newV.children[i], i)&#125;document.querySelector(&#x27;#root&#x27;).appendChild(VDOM.render(data)) 结构为: 12345678910&lt;div id=&quot;root&quot;&gt; &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;p&gt; This is a paragraph! &lt;h1&gt;This is a H1 tag&lt;/h1&gt; &lt;h6&gt;and I&#x27;m h6&lt;/h6&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;","tags":["整理"]},{"title":"首张黑洞照片","path":"/2019/04/10/首张黑洞照片/","content":"见证历史爱因斯坦是正确的!","tags":["history"]},{"title":"Maybe","path":"/2019/03/29/Maybe/","content":"ContainerLet’s create a normal container first. 1234567891011class Container &#123; constructor(x) &#123; this._value = x &#125; // use the of to create the container static of(x) &#123; return new Container(x) &#125;&#125;Container.of(2) // Container &#123; _value: 2 &#125;Container.of(&#123; name: &#x27;jack&#x27; &#125;) // Container &#123; _value: &#123; name: &#x27;jack&#x27; &#125; &#125; But we should not directly manipulate the data in the container. We need a function to do this. 123456// Container.prototype.map :: (a -&gt; b) -&gt; Container a -&gt; Container bContainer.prototype.map = function (f) &#123; return Container.of(f(this._value))&#125;let six = Container.of(2).map((x) =&gt; x * 3) // Container &#123; _value: 6 &#125;six.map((x) =&gt; x.toString()).map((x) =&gt; &#x27;number: &#x27; + x + &#x27;!&#x27;) // Container &#123; _value: &#x27;number: 6!&#x27; &#125; After passing the values in the Container to the map function, we can let them manipulate it; after the operation is completed, in order to prevent accidents, put them back into the Container they belong to. The result is that we can call the map continuously, running any function we want to run.And the Functor is a container type that implements the map function and adheres to certain rules. MaybeIn Haskell, the Maybe type is defined as follow: 1data Maybe a = Just a | Nothing Maybe will check if its value is empty before calling the passed function. So let’s create a simple one. 12345678910111213141516171819class Maybe &#123; constructor(x) &#123; this._value = x &#125; static of(x) &#123; return new Maybe(x) &#125; isNothing() &#123; return this._value === null || this._value === undefined &#125; // map :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b map(f) &#123; return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this._value)) &#125;&#125;Maybe.of(&#x27;hello world&#x27;).map(match(/o/gi)) // Maybe &#123; _value: [ &#x27;o&#x27;, &#x27;o&#x27; ] &#125;Maybe.of(&#123; name: &#x27;jack&#x27; &#125;) .map($.prop(&#x27;age&#x27;)) .map((x) =&gt; x + 10) // Maybe &#123; _value: null &#125; Error handlingThere is a class called Either in scala that represents the value of one of two possible types. Instances of Either are either an instance of Left or Right.Now we need to create the Left and the Right. 12345678910111213141516171819202122232425class Left &#123; constructor(x) &#123; this._value = x &#125; static of(x) &#123; return new Left(x) &#125; // do nothing map(f) &#123; return this &#125;&#125;class Right &#123; constructor(x) &#123; this._value = x &#125; static of(x) &#123; return new Right(x) &#125; map(f) &#123; return Right.of(f(this._value)) &#125;&#125;Left.of(2).map((x) =&gt; x + 2) // Left &#123; _value: 2 &#125;Right.of(2).map((x) =&gt; x + 2) //Right &#123; _value: 4 &#125; Use it: 12345678910111213141516171819202122232425262728// getChange :: a -&gt; b -&gt; Either(String, Number)let getChange = curry((a, b) =&gt; &#123; if (a &lt; b) return Left.of(&#x27;You need to give more money.&#x27;) return Right.of(a - b)&#125;)getChange(10, 8) // Right &#123; _value: &#x27;Get the change: 2&#x27; &#125;getChange(10, 15) // Left &#123; _value: &#x27;You need to give more money.&#x27; &#125;// eigher :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; cvar either = curry((f, g, e) =&gt; &#123; switch (e.constructor) &#123; case Left: return f(e._value) case Right: return g(e._value) &#125;&#125;)// faild :: a -&gt; avar faild = (x) =&gt; x// success :: a -&gt; bvar success = (x) =&gt; &#123; return &#x27;get change: &#x27; + x&#125;// foo :: a -&gt; a -&gt; cvar foo = $.compose(either(faild, success), getChange)foo(0, 2) // You need to give more money.foo(4, 2) // get change: 2","tags":["整理","JavaScript"],"categories":["ECMAScript"]},{"title":"The composition","path":"/2019/03/28/The-Composition/","content":"Function CompositionIn computer science, function composition is an act or mechanism to combine simple functions to build more complicated ones. Like the usual composition of functions in mathematics, the result of each function is passed as the argument of the next, and the result of the last one is the result of the whole. -- Wikipedia Example: 123456var compose = (f, g) =&gt; (x) =&gt; f(g(x))var head = (x) =&gt; x[0]var reverse = reduce((a, x) =&gt; [x].concat(a), [])var last = compose(head, reverse)last([&#x27;first&#x27;, &#x27;second&#x27;, &#x27;last&#x27;]) // &#x27;last&#x27; In the definition of compose, g will be executed before f, thus creating a right-to-left data stream. This is much more readable than nesting a bunch of function calls. AssociativityLike many other functional programming concepts, associativity is derived from math.It is an expression in which the order of evaluation does not affect the end result provided the sequence of the operands does not get changed. -- JOSEPH REX Example: 122 + (3 + 4) === 2 + 3 + 4 // true2 * (3 * 4) === 2 * 3 * 4 // true Because of the grouping of calls to compose is not important, so the result is the same. This also gives us the ability to write a variadic compose.Like this: 12345678910var last = compose(head, reverse)last([&#x27;first&#x27;, &#x27;second&#x27;, &#x27;last&#x27;]) // &#x27;last&#x27;var upperLast = compose(head, reverse, toUppercase)upperLast([&#x27;first&#x27;, &#x27;second&#x27;, &#x27;last&#x27;]) // &#x27;LAST&#x27;var mediaUrl = _.compose(_.prop(&#x27;m&#x27;), _.prop(&#x27;media&#x27;))// var images = _.compose(_.map(img), _.map(mediaUrl), _.prop(&#x27;items&#x27;));// use the associativityvar images = _.compose(_.map(_.compose(img, mediaUrl)), _.prop(&#x27;items&#x27;)) There is no standard answer on how to composition, just make it more reusable. Tacit programmingTacit programming, also called point-free style, is a programming paradigm in which function definitions do not identify the arguments (or &quot;points&quot;) on which they operate. -- Wikipedia 1234567891011var head = (x) =&gt; x[0]var toUppercase = (x) =&gt; x.toUpperCase()// not pointfree// it used the namevar foo1 = (name) =&gt; name.split(&#x27; &#x27;).map(compose(toUppercase, head)).join(&#x27;.&#x27;)foo1(&#x27;Edward Wang&#x27;) // E.W// pointfreevar foo2 = compose(join(&#x27;.&#x27;), map(compose(toUppercase, head)), split(&#x27; &#x27;))foo2(&#x27;Edward Wang&#x27;) // E.W some practiceUse compose in rambda. 1234567891011121314151617181920212223242526272829303132333435// test datavar dragons = [ &#123; name: &#x27;thiny dragon&#x27;, height: 600, price: 700, sold: true &#125;, &#123; name: &#x27;tall dragon&#x27;, height: 6600, price: 1700, sold: false &#125;, &#123; name: &#x27;dangerous dragon&#x27;, height: 5200, price: 700, sold: false &#125;, &#123; name: &#x27;small dragon&#x27;, height: 200, price: 1300, sold: false &#125;, &#123; name: &#x27;fat dragon&#x27;, height: 400, price: 900, sold: true &#125;, &#123; name: &#x27;gold dragon&#x27;, height: 500, price: 2000, sold: false &#125;,]// 1. rewrite the following with the compose. Tip: the prop is curry function.// var isLastSold = xs =&gt; &#123;// var x = $.last(xs);// return $.prop(&#x27;sold&#x27;, x);// &#125;var isLastSold = $.compose($.prop(&#x27;sold&#x27;), $.last)isLastSold(dragons) // false// 2. use the compose, prop and head to get the name of first dragon.var nameOfFirst = $.compose($.prop(&#x27;name&#x27;), $.head)nameOfFirst(dragons) // &#x27;thiny dragon&#x27;// 3. refactoring the averagePrice with the average to make it composition.var _average = (xs) =&gt; reduce(add, 0, xs) / xs.length// var averagePrice = xs =&gt; &#123;// var p = map(x =&gt; x.price, xs);// return _average(p);// &#125;var averagePrice = $.compose(_average, map($.prop(&#x27;price&#x27;)))averagePrice(dragons) // 1216.6666666666667// 4. write a function that =&gt; &#x27;gold dragon&#x27; =&gt; &#x27;GOLD_DRAGON&#x27;var replaceSpace = replace(/\\W+/g, &#x27;_&#x27;)var changeName = $.map($.compose(replaceSpace, toUppercase, $.prop(&#x27;name&#x27;)))changeName(dragons) //[ &#x27;THINY_DRAGON&#x27;, &#x27;TALL_DRAGON&#x27;, &#x27;DANGEROUS_DRAGON&#x27;, &#x27;SMALL_DRAGON&#x27;, &#x27;FAT_DRAGON&#x27;, &#x27;GOLD_DRAGON&#x27; ] Test Application123456789101112131415161718192021222324252627282930requirejs.config(&#123; paths: &#123; ramda: &#x27;https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min&#x27;, jquery: &#x27;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min&#x27;, &#125;,&#125;)require([&#x27;ramda&#x27;, &#x27;jquery&#x27;], (_, $) =&gt; &#123; var log = _.curry((tag, x) =&gt; &#123; console.log(tag, x) return x &#125;) var url = (term) =&gt; &#x27;https://api.flickr.com/services/feeds/photos_public.gne?tags=&#x27; + term + &#x27;&amp;format=json&amp;jsoncallback=?&#x27; var img = (url) =&gt; $(&#x27;&lt;img /&gt;&#x27;, &#123; src: url &#125;) var setHtml = _.curry((tag, html) =&gt; $(tag).html(html)) var getJSON = _.curry((callback, url) =&gt; $.getJSON(url, callback)) var mediaUrl = _.compose(_.prop(&#x27;m&#x27;), _.prop(&#x27;media&#x27;)) var mediaToImg = _.compose(img, mediaUrl) var images = _.compose(_.map(mediaToImg), _.prop(&#x27;items&#x27;)) var renderImages = _.compose(setHtml(&#x27;body&#x27;), images) var app = _.compose(getJSON(renderImages), url) app(&#x27;car&#x27;)&#125;)","tags":["学习","函数式编程"],"categories":["Function Programming"]},{"title":"The Currying","path":"/2019/03/27/The-currying/","content":"What is curryingCurrying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument. -- WikipediaIt mean this: 12345let add = (x) =&gt; (y) =&gt; x + ylet addOne = add(1)let addTwo = add(2)addOne(11) // 12addTwo(11) // 13 In order to define functions more easily, we need the loadsh, it will help us to currying the function. make some using thing12345678910111213var _ = require(&#x27;loadsh&#x27;).curryvar match = _((regex, str) =&gt; str.match(regex))var replace = _((regex, replacement, str) =&gt; str.replace(regex, replacement))var filter = _((f, array) =&gt; array.filter(f))match(/\\s+/g, &#x27;test Message&#x27;) // [&#x27; &#x27;]match(/\\s+/g)(&#x27;test Message&#x27;) // [&#x27; &#x27;]var hasSpace = match(/\\s+/g)hasSpace(&#x27;testMessage&#x27;) // nullfilter(hasSpace, [&#x27;testMessage1&#x27;, &#x27;test Message2&#x27;, &#x27;test Message 3&#x27;]) // [&#x27;test Message2&#x27;, &#x27;test Message 3&#x27;]var noA = replace(/[Aa]+/g, &#x27;*&#x27;)noA(&#x27;aaaabbbAAAc&#x27;) // &#x27;*bbb*c&#x27; some practiceUse curry in rambda. 123456789101112131415161718192021222324252627282930313233343536// support functionslet curry = require(&#x27;rambda&#x27;).currylet compose = require(&#x27;rambda&#x27;).composelet add = curry((a, b) =&gt; a + b)let match = curry((regex, str) =&gt; str.match(regex))let replace = curry((regex, replacement, str) =&gt; str.replace(regex, replacement),)let filter = curry((f, arr) =&gt; arr.filter(f))let map = curry((f, arr) =&gt; arr.map(f))let split = curry((symbol, str) =&gt; str.split(symbol))let reduce = curry((f, arr, x) =&gt; x.reduce(f, arr))let join = curry((symbol, arr) =&gt; arr.join(symbol))let toUppercase = curry((str) =&gt; str.toUpperCase())let toLowercase = curry((str) =&gt; str.toLowerCase())// 1. remove all the arguments// var words = str =&gt; split(&#x27; &#x27;, str);var words = split(&#x27; &#x27;)words(&#x27;hello world !&#x27;) // [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;!&#x27;]// 2. create a new words function with map to enable mainpulation of string arrayvar theWords = map(words)theWords([&#x27;first message&#x27;, &#x27;seconde message&#x27;]) // [[&#x27;first&#x27;, &#x27;message&#x27;], [&#x27;second&#x27;, &#x27;message&#x27;]]// 3. remove all the arguments// var filterQString = xs =&gt; filter(x =&gt; match(/q/i, x), xs);var filterAString = filter(match(/a/i))filterAString([&#x27;quick&#x27;, &#x27;queue&#x27;, &#x27;apple&#x27;, &#x27;two&#x27;]) // [&#x27;apple&#x27;]// 4. Refactor max with the help function _max to make it a curry functionvar _max = (a, b) =&gt; (a &gt;= b ? a : b)// var max = xs =&gt; reduce((account, x) =&gt; _max(account, x), -Infinity, xs);var max = reduce(_max, -Infinity)max([1, 2, 3, 4]) // 4 Currying add12345678910111213141516function add(x) &#123; let sum = x function f(y) &#123; sum += y return f &#125; f.end = function () &#123; return sum &#125; return f&#125;console.log(add(0)(1)(2).end())","tags":["学习","JavaScript","currying"],"categories":["Functional Programming"]},{"title":"What is the Pure Function","path":"/2019/03/27/whatIsPureFunction/","content":"Functionfunction has special rules: It must work for every possible input value And it has only one relationship for each input value Although each input will only have one output, but for different inputs may have the same output. Pure functionGiven all these, pure functions have a big set of advantages. They are easier to read and understand, as they do one thing. There is no need to look outside the function code and check for variables. There is no need to think how changing the value of the variable will affect other functions. No mutations in other functions will affect the result of the pure function for a specific input.Pure functions are easier to test, as all dependencies are in the function definition and they do one thing.For Example: 12345678910var arr = [1, 2, 3];// Purearr.slice(0, 2); // [1, 2]arr.slice(0, 2); // [1, 2]arr.slice(2, 3); // [3]// Impurearr.splice(0, 2); // [1, 2]arr.splice(0, 2); // [3] Another Example: 1234567891011// Impurevar sign = 3;// The return value depends on the system statusvar isBigger = num =&gt; num &gt; 3;// Purevar isBigger = num =&gt; &#123;var sign = 3;return num &gt; sign;&#125;","tags":["学习"]},{"title":"Start learning FP","path":"/2019/03/27/初涉FP/","content":"Functional Programming经过这几天的了解，越觉得 FP 十分有趣给个例子: 12345678// a simple functionfunction add(a, b) &#123;return a + b;&#125;/// the same aslet add = function (a, b) &#123;return a + b;&#125; 在 ES6 中，存在着箭头函数。所以上面的函数可以写成这个形式： 1let add = (a, b) =&gt; a + b; 构造另一个 function现在写一个新的 function : 1let multipy = (x, y) =&gt; x \\* y Let’s start现在我们用上面两个例子计算下 2 * 3 + 2 * 4： 12let result = add(multipy(2, 3), multipy(2, 4));result // 14 试试 2 + (2 + 3) == (2 + 2) + 3是正确的吗： 12345let result1 = add(2, add(2, 3));let result2 = add(add(2, 2), 3);result1 === result2; // true// 可以看出 add(a, add(b, c)) === add(add(a, b), c) 再试试 2 * 3 + 2 * 4 === (2 + 4) * 2： 1234let result1 = add(multipy(2, 3), multipy(2, 4));let result2 = multipy(add(3, 4), 2);result1 === result2; // true// Nice Job add 的链式调用12345678910function add(n) &#123; if (n === undefined) &#123; return add.result &#125; else &#123; add.result += n return add &#125;&#125;add.result = 0console.log(add(1)(1)(1)()) result: 13","tags":["学习"]},{"title":"自用vscode插件","path":"/2019/03/27/自用vscode插件/","content":"background: 背景的可爱萌妹子, 当然可以自定义背景 beautify: 代码格式化 Dracula Official: 颜色主题 Haskell Syntax Highlighting: Haskell 语法高亮 HTML Snippets: HTML 自动补全 HTML CSS Support JavaScript (ES6) code snippets: JS 自动补全 Markdown PDF: 神器, 但是默认会装一个 Chromium npm Intellisense: 自动导入模块 Path Intellisense: 自动补全文件名 Quokka.js: 方便 debug Vetur vscode-icons: vscode 文件图标 Vue 2 Snippets yddict(npm): 查词, 非常方便, 安装:sudo npm i yddict -g, 用法: yd hello http-server(npm)","tags":["整理"]},{"title":"01背包问题","path":"/2019/03/19/01背包问题/","content":"问题描述背包： 总重 M物品数量： S物品： 重量 thingM ，价值 thingT需求：在背包能够承受的重量下，装下价值大的物品输入格式第一行为 2 个数字，分别为背包的总重 M 和物品的数量 S接下来的 M 行为每个物品的重量 thingM 以及物品的价值 thingTM &lt;&#x3D; 100 且 S &lt;&#x3D; 1000输出格式一个整数，代表能拿到的最大的价值 样例数据 123470 371 10069 11 2 分析问题01 背包问题就在于一个物品，只有两种情况：拿或者不拿。这时就可以进行判断： 重量允许的情况下，拿价值高的方案 重量不允许则不拿 实现1234567891011121314Scanner input = new Scanner(System.in);int dp[][] = new int[101][1001];int M = input.nextInt(),S = input.nextInt();for (int i = 1; i &lt;= S; i++) &#123;int thingM = input.nextInt(),thingT = input.nextInt();for (int j = 1; j &lt;= M; j++) &#123;if (j &gt;= thingM) &#123; // 可以拿dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - thingM] + thingT);&#125; else dp[i][j] = dp[i - 1][j]; // 不拿&#125;&#125;System.out.println(dp[S][M]); 输出3 例题 2一辆车，总共可以装 M 质量的物品，有 N 件物品，每件物品重 thingM 。能装的都装完后，还能剩下多少质量？输入格式第一行为一个整数，代表车的容量 M 。第二行为一个整数，代表物品数量 N 。接下来的 N 行，代表每个物品的重量。0 &lt;&#x3D; M &lt;&#x3D; 20000 且 0 &lt;&#x3D; N &lt;&#x3D; 20输出格式一个整数，代表剩余容量。样例数据 123456782468312797 代码12345678910111213int dp[][] = new int[31][20001];Scanner input = new Scanner(System.in);int V = input.nextInt(),Len = input.nextInt();for (int i = 1; i &lt;= Len; i++) &#123;int thingS = input.nextInt();for (int j = 1; j &lt;= V; j++) &#123;if (j &gt;= thingS) &#123;dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - thingS] + thingS);&#125; else dp[i][j] = dp[i - 1][j];&#125;&#125;System.out.println(V - dp[Len][V]); 输出0","tags":["算法"]},{"title":"动态规划","path":"/2019/03/14/动态规划/","content":"思想通过把问题分解成子问题，再根据子问题的解得出原问题的解。例如：1+1+1 = 3，1+1+1+2 = 5。因为(1+1+1)+2 = 3 + 2 = 5。这时我们可以把每次计算过的值给存起来，这样下次计算时就不用重新计算。 用最少的东西拿需求的重量假设有个包，现在有1, 3, 3, 4四样东西，如何在规定的重量内拿到最少的物品。假设需要拿6重量的东西，如果用贪心就会拿到[4, 1, 1]，但是显然我们需要的是[3, 3]，这时就需要使用到上面的思想。 如果拿1重量的东西，需要[1] 如果拿3重量的东西，需要[3] 如果拿4重量的东西，需要[4] 如果拿5重量的东西，需要[4, 1] 如果拿6重量的东西，有[3, 3]和[4, 1, 1]两种解法，这时就需判是否有更优解。 代码： 1234567891011121314151617181920212223242526272829303132333435print = (key) =&gt; console.log(key);class Package &#123;constructor(things) &#123;this.things = things; // 存放物品的数组this.cache = &#123;&#125;; // 用于缓存&#125; pick(weight) &#123; if (weight == 0) return []; let minWeight = []; // 查询缓存 if (this.cache[weight]) return this.cache[weight]; for (let i = 0, len = this.things.length; i &lt; len; i++) &#123; // 除去当前重量 let leftWeight = weight - this.things[i], newMinWeight; if (leftWeight &gt;= 0) &#123; // 用剩下的重量去查询 newMinWeight = this.pick(leftWeight); // 如果查询到的比现在的数组长度更短，更换数组 if (newMinWeight.length &lt; minWeight.length || minWeight.length == 0) minWeight = [this.things[i]].concat(newMinWeight); &#125; &#125; // 存放至缓存中 return this.cache[weight] = minWeight; &#125;&#125; 测试： 123var package = new Package([1, 3, 3, 4])print(package.pick(6)); // [3, 3]print(package.pick(10)); // [4, 3, 3]","tags":["整理"]},{"title":"图的邻接表表示法","path":"/2019/03/14/图的邻接表表示法/","content":"邻接表存储方式：表头存放节点，相邻节点存放于之后的链表中。** 使用 Map 模拟 ** 123456789101112131415161718192021222324class Graph &#123;constructor() &#123;this.point = [];this.map = new Map();&#125; addPoint(point) &#123; this.point.push(point); this.map.set(point, []); &#125; // 无向 addEdge(pointA, pointB) &#123; this.map.get(pointA).push(pointB); this.map.get(pointB).push(pointA); &#125; print() &#123; for (let item of this.point) &#123; console.log(item + &#x27; -&gt; &#x27; + this.map.get(item).join(&#x27;,&#x27;)); &#125; &#125;&#125; Test123456789101112131415var graph = new Graph()var topArr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;]for (let item of topArr) &#123;graph.addPoint(item);&#125;graph.addEdge(&#x27;A&#x27;, &#x27;B&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;E&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;H&#x27;);graph.addEdge(&#x27;F&#x27;, &#x27;G&#x27;);graph.addEdge(&#x27;I&#x27;, &#x27;B&#x27;);graph.addEdge(&#x27;I&#x27;, &#x27;C&#x27;);graph.print();","tags":["整理"]},{"title":"BST","path":"/2019/03/14/BST/","content":"Binary Search Tree 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。 若右子树不空，则右子树上所有结点的值均大于它的根结点的值。 左、右子树也分别为二叉排序树。 没有键值相等的节点。 实现Node： 12345678let print = (key) =&gt; console.log(key);class Node &#123;constructor(key) &#123;this.key = key;this.left = null;this.right = null;&#125;&#125; Tree： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146class BinarySearchTree &#123;constructor() &#123;this.root = null;&#125; insert(key) &#123; const node = new Node(key); if (this.root == null) &#123; this.root = node; &#125; else &#123; insertNode(this.root, node); &#125; function insertNode(parent, node) &#123; if (parent.key &gt; node.key) &#123; if (parent.left == null) &#123; parent.left = node; &#125; else &#123; insertNode(parent.left, node); &#125; &#125; else &#123; if (parent.right == null) &#123; parent.right = node; &#125; else &#123; insertNode(parent.right, node); &#125; &#125; &#125; &#125; inOrderTraverse() &#123; // 中序遍历 inOrderTraverse(this.root); function inOrderTraverse(node) &#123; if (node) &#123; inOrderTraverse(node.left); print(node.key); inOrderTraverse(node.right); &#125; &#125; &#125; preOrderTraverse() &#123; // 先序遍历 preOrderTraverse(this.root); function preOrderTraverse(node) &#123; print(node.key); preOrderTraverse(node.left); preOrderTraverse(node.right); &#125; &#125; postOrderTraverse() &#123; // 后序遍历 postOrderTraverse(this.root); function postOrderTraverse(node) &#123; postOrderTraverse(node.left); postOrderTraverse(node.right); print(node.key); &#125; &#125; max() &#123; let maxNode = &#123;&#125;; function getMax(node) &#123; if (node &amp;&amp; node.right) &#123; maxNode = node; getMax(node.right); &#125; &#125; getMax(this.root); return maxNode.key; &#125; min() &#123; let minNode = &#123;&#125;; function getMin(node) &#123; if (node &amp;&amp; node.left) &#123; minNode = node; getMin(node.left); &#125; &#125; getMin(this.root); return minNode.key; &#125; search(key) &#123; function findNode(node) &#123; if (!node) return false; if (key &gt; node.key) &#123; return findNode(node.right); &#125; else if (key &lt; node.key) &#123; return findNode(node.left); &#125; return node; &#125; return findNode(this.root); &#125; remove(key) &#123; if (!this.search(key)) return; // 调整二叉树 function adjustNode(current, key) &#123; if (key &lt; current.key) &#123; current.left = adjustNode(current.left, key); return current; &#125; else if (key &gt; current.key) &#123; current.right = adjustNode(current.right, key); return current; &#125; else &#123; // 左右都空直接删除 if (current.left === null &amp;&amp; current.right === null) &#123; return current = null; &#125; else if (current.right === null) &#123; // 处理左边不空 let temp = current.left; current = null; return temp; &#125; else if (current.left === null) &#123; // 处理右边不空 let temp = current.right; current = null; return temp; &#125; // 从需要删除的节点的右边寻找一个最小的节点，放置当前位置 current.key = minNode(current.right); // 调整后处理那个节点 current.right = adjustNode(current.right, current.key); return current; &#125; &#125; function minNode(node) &#123; if (node.left) return minNode(node.left); return node; &#125; adjustNode(this.root, key) &#125;&#125; ** Test ** 12345678910111213var tree = new BinarySearchTree()for (let i = 5; i &lt; 15; i++) &#123;tree.insert(i);&#125;for (let i = 30; i &gt; 15; i--) &#123;tree.insert(i);&#125;print(tree.search(6));tree.remove(15);tree.remove(10);tree.remove(29);tree.inOrderTraverse();","tags":["算法"]},{"title":"并查集","path":"/2019/03/13/并查集/","content":"并查集用集合中的某个元素来代表这个集合，该元素称为集合的代表元。一个集合内的所有元素组织成以代表元为根的树形结构。对于每一个元素parent[x]指向 x 在树形结构上的父亲节点。如果 x 是根节点，则令parent[x] = x。对于查找操作，假设需要确定 x 所在的的集合，也就是确定集合的代表元。可以沿着parent[x]不断在树形结构中向上移动，直到到达根节点。 节点表示： 1234var maxSize = 1000000;var parent = []; // 父亲节点数组var rank = []; // 深度数组var data = []; // 数据数组 初始化时都设置 parent 为自己的标号： 1234function makeSet(i) &#123;parent[i] = i;rank[i] = 0;&#125; 查找： 12345function findSet(i) &#123;if (parent[i] == i)return parent[i];return findSet(parent[i]);&#125; 合并： 123456789101112function union(i, j) &#123;i = findSet(i);j = findSet(j);if (i == j)return;if (rank[i] &gt; rank[j]) &#123;parent[j] = i;&#125; else &#123;if (rank[i] == rank[j]) rank[j]++;parent[i] = j;&#125;&#125;","tags":["整理"]},{"title":"广度优先搜索","path":"/2019/03/13/广度优先搜索/","content":"广度优先搜索在 N * M 的网格中，从 start 走到 end 。广度解法：需要一个队列，从 start 节点开始，当一个节点抛出时，将它周围的节点入队，直至抛出的节点是 end 节点。模拟网格： 12345678910var map = [ // map[x][y][0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0],[0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 2],];find(map); 算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function find(map) &#123;var maxX = map.length - 1, // 最大 x 坐标maxY, // 最大 y 坐标queue = [], // 寻路队列start_x = -1, // 起始位置 x 坐标start_y = -1, // 起始位置 y 坐标end_x = -1, // 结束位置 x 坐标end_y = -1, // 结束位置 y 坐标unpassed = []; // 用于判断是否经过的数组 // 如果数组长度为0，返回 if (maxX &gt;= 0) &#123; maxY = map[0].length - 1; &#125; else &#123; return; &#125; // 寻找起始坐标和终止坐标 for (let i = 0, len = map.length; i &lt; len; i++) &#123; for (let j = 0, innerLen = map[i].length; j &lt; innerLen; j++) &#123; if (map[i][j] == 1) &#123; start_x = i; start_y = j; &#125; if (map[i][j] == 2) &#123; end_x = i; end_y = j; &#125; &#125; if (start_x != -1 &amp;&amp; end_x != -1) break; &#125; // 缺少起始位置或者结束位置 if (start_x == -1 || end_x == -1) &#123; console.log(&#x27;地图有误&#x27;); return; &#125; // 初始化路径数组 for (let i = 0, len = map.length; i &lt; len; i++) &#123; var result = []; for (let j = 0, innerLen = map[i].length; j &lt; innerLen; j++) &#123; result.push(true); &#125; unpassed.push(result); &#125; // 起始位置进入队列 queue.push([start_x, start_y]); do &#123; // 取出当前位置 var [current_x, current_y] = queue.shift(); // 判断是否经过 if (unpassed[current_x][current_y]) &#123; unpassed[current_x][current_y] = false; &#125; else &#123; continue; &#125; // 打印路径数组 show(unpassed); // 到达终点 if (current_x == end_x &amp;&amp; current_y == end_y) break; else &#123; // 上方位置入队 if (current_x &gt; 0) &#123; queue.push([current_x - 1, current_y]); &#125; // 右方位置入队 if (current_y &lt; maxY) &#123; queue.push([current_x, current_y + 1]); &#125; // 下方位置入队 if (current_x &lt; maxX) &#123; queue.push([current_x + 1, current_y]); &#125; // 左方位置入队 if (current_y &gt; 0) &#123; queue.push([current_x, current_y - 1]); &#125; &#125; &#125; while (true);&#125;function show(map) &#123;for (let i = 0, len = map.length; i &lt; len; i++) &#123;var str = &#x27;&#x27;;for (let j = 0, innerLen = map[i].length; j &lt; innerLen; j++) &#123;if (!map[i][j]) &#123;str += &#x27;\\*&#x27;;&#125; else str += &#x27;0&#x27;;&#125;console.log(str);&#125;console.log(&#x27;------&#x27;);&#125;","tags":["算法"]},{"title":"CSS垂直居中","path":"/2019/03/12/CSS垂直居中/","content":"HTML 框架12345678910111213141516&lt;style&gt; #box &#123; width: 300px; height: 300px; background-color: #ddd; &#125; #child &#123; width: 200px; height: 100px; background-color: orange; &#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt;target&lt;/div&gt;&lt;/div&gt; 绝对定位 + 负外边距 112345678#box &#123; position: relative;&#125;#child &#123; position: absolute; top: 50%; margin: -50px 0 0 0;&#125; 缺点：需要知道目标元素的高度 绝对定位 + 负外边距 2123456789#box &#123; position: relative;&#125;#child &#123; height: 30%; position: absolute; top: 50%; margin: -15% 0 0 0;&#125; 绝对定位 + transform12345678#box &#123; position: relative;&#125;#child &#123; position: absolute; top: 50%; transform: translate(0, -50%);&#125; 绝对定位 + margin: auto12345678910#box &#123; position: relative;&#125;#child &#123; position: absolute; top: 0; bottom: 0; margin: auto; line-height: 100px;&#125; flex1234#box &#123; display: flex; align-items: center;&#125;","tags":["整理"]},{"title":"前后端通信","path":"/2019/03/12/前后端通信/","content":"同源策略 同源策略（MDN 解释）：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 源：协议、域名、端口。 限制：无法获取 Cookie 、 LocalStorage 和 IndexDB ，无法操作 dom ，不能发送 Ajax 。 前后端通信方式 Ajax：不支持跨域。 WebSocket：支持跨域。 CORS：支持跨域。 onreadystatechange 事件readyState： 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求完成，响应就绪 触发顺序： xhr.onreadystatechange xhr.onloadstart xhr.upload.onloadstart xhr.upload.onprogress xhr.upload.onload xhr.upload.onloaded xhr.onprogress xhr.onload xhr.onloaded Ajax 请求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var ajax = function (param) &#123; // 兼容性处理 var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;) var type = (param.type || &#x27;get&#x27;).toUpperCase() var url = param.url if (!url) &#123; return &#125; var data = param.data, dataArr = [] // 构造数组 for (var key in data) &#123; dataArr.push(key + &#x27;=&#x27; + data[key]) &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;) xhr.open(type, url) xhr.send() &#125; else if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url) // post 请求头 xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) xhr.send(dataArr.join(&#x27;&amp;&#x27;)) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200 || xhr.status == 304) &#123; if (param.success &amp;&amp; param.success instanceof Function) &#123; var result = xhr.responseText if (typeof result === &#x27;string&#x27;) &#123; result = JSON.parse(result) param.success.call(xhr, result) &#125; &#125; &#125; &#125; &#125;&#125; update: Promise 改造 12345678910111213141516171819202122232425262728293031323334353637var ajax = (&#123; type, url, data, header &#125;) =&gt; new Promise((resolve, reject) =&gt; &#123; // 兼容性处理 var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;) type = (type || &#x27;get&#x27;).toUpperCase() if (!url) return let dataArr = [] // 构造数组 for (var key in data) &#123; dataArr.push(key + &#x27;=&#x27; + data[key]) &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;) xhr.open(type, url) xhr.send() &#125; else if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url) // post 请求头 xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) for (let key in header) xhr.setRequestHeader(key, header[key]) xhr.send(dataArr.join(&#x27;&amp;&#x27;)) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200 || xhr.status == 304) &#123; resolve.call(undefined, xhr.responseText) &#125; else reject.call(undefined, xhr) &#125; &#125; &#125;) 跨域通信的方式： JSONP：只支持 GET 请求，通过 script 的异步加载实现 WebSocket CORS：跨域时，会在请求头增加 Origin 字段 Hash postMessage： window.postMessage() 发送","tags":["整理"]},{"title":"前端 .gitignore文件的配置","path":"/2019/03/05/前端-gitignore文件的配置/","content":".gitignore 文件的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Numerous always-ignore extensions_.bak_.patch_.diff_.err# temp file for git conflict merging_.orig_.log_.rej_.swo_.swp_.zip_.vi_~_.sass-cache_.tmp.html\\*.dump# OS or Editor folders.DS*Store.*_.cache.project.settings.tmproj_.esproj_.sublime-project_.sublime-workspacenbprojectthumbs.db\\*.iml# Folders to ignore.hg.svn.CVS.ideanode_modules/jscoverage_lib/bower_components/dist/","tags":["整理"]},{"title":"全排列思想","path":"/2019/03/05/全排列思想/","content":"全排列的思想从 n 个不同元素中任取 m（m&lt;&#x3D;n）个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列。当 m&#x3D;n 时所有的排列情况叫全排列。这时候我们就可以来思考，如何取得所有排列的情况。例如数组[1, 2, 3, 4]，我们可以先固定一个数字1，这时候剩下的数组就变成了[2, 3, 4]。此时再固定一个数字2，数组剩下[3, 4]。再固定3，这时候数组就只剩下[4]，就可以输出一个序列 -&gt; [1, 2, 3, 4]。这时候将3解除固定，与4交换，再固定4，这时又可以输出一个序列 -&gt; [1, 2, 4, 3]。这样固定1, 2时候的所有情况就排列出来了，再继续将2解除固定，并与3交换。这时候就固定了1, 3，数组剩下[2, 4]，再重复上面的方法，直到所有固定两个数的排列都排完后，再交换固定的第一个数，这样就可以推出全排列。 递归的实现1234567891011121314151617181920212223242526272829303132333435363738function Perm(arr, current, count) &#123; // 前面的数都已固定完 if (current == count) &#123; let str = &#x27;&#x27;; for (let i = 0; i &lt;= count; i++) &#123; str += arr[i]; &#125; console.log(str); &#125; else &#123; for (let i = current; i &lt;= count; i++) &#123; // 不相同才交换 if (sample(arr, current, i)) &#123; // 将数字挨个交换 [arr[i], arr[current]] = [arr[current], arr[i]]; // 交换后执行递归函数 Perm(arr, current + 1, count); // 数字交换后需要复原 [arr[i], arr[current]] = [arr[current], arr[i]]; &#125; &#125; &#125;&#125;function sample(arr, start, end) &#123;for (let i = start; i &lt; end; i++) &#123;if (arr[i] == arr[end]) &#123;return false;&#125;&#125;return true;&#125;let arr = [1, 2, 2, 1];Perm(arr, 0, arr.length - 1); 结果： 123456122112121122212121122211 非递归的实现** 会重复 ** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function permutation(arr) &#123;let total = 1;// 计算排列种数for (let i = 2; i &lt;= arr.length; i++) &#123;total \\*= i;&#125;print_r(arr);for (let i = 0; i &lt; total; i++) &#123;let k = arr.length - 1,min = Number.MAX_VALUE,minIndex = 0;// 从后开始遍历，找到底一个非增的元素，和后面某个刚好大于它的元素替换 while (k &gt; 0 &amp;&amp; arr[k] &lt; arr[--k]); // 找到刚好比替换到前面大的元素 for (let j = arr.length - 1; j &gt;= k + 1; j--) &#123; if (arr[j] &gt; arr[k] &amp;&amp; min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; //与找到的元素 进行交换 [arr[k], arr[minIndex]] = [arr[minIndex], arr[k]]; // 数组倒置 for (let m = 0; m &lt; (arr.length - k - 1) / 2; m++) &#123; [arr[k + 1 + m], arr[arr.length - 1 - m]] = [arr[arr.length - 1 - m], arr[k + 1 + m]] &#125; print_r(arr); &#125;&#125;function sample(arr, start, end) &#123;for (let i = start; i &lt; end; i++) &#123;if (arr[i] == arr[end]) &#123;return false;&#125;&#125;return true;&#125;function print_r(arr) &#123;let str = &#x27;&#x27;;for (let i = 0, len = arr.length; i &lt; len; i++) &#123;str += arr[i];&#125;console.log(str);&#125;","tags":["算法"]},{"title":"排序算法","path":"/2019/02/28/排序算法/","content":"简单插入排序1234567891011121314151617function insertSort(arr) &#123;for (let i = 1, len = arr.length; i &lt; len; i++) &#123;if (arr[i] &lt; arr[i - 1]) &#123;let current = i - 1; // the position need to movelet temp = arr[i]; // the value need to insertarr[i] = arr[current];while (temp &lt; arr[current]) &#123;arr[current + 1] = arr[current]; // move backwardcurrent--;&#125;arr[current + 1] = temp;&#125;&#125;&#125;let arr = [6, 7, 2, 3, 1, 5, 4];insertSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 希尔排序由于 JavaScript 的数据都是用浮点数存储的，所以需要用到parseInt() 123456789101112131415161718192021222324function shellSort(arr) &#123;let dert = parseInt(arr.length / 2);while (dert &gt;= 1) &#123;shellInsertSort(arr, dert);dert = parseInt(dert / 2); // compute the shell step&#125;&#125;function shellInsertSort(arr, dert) &#123;for (let i = dert, len = arr.length; i &lt; len; i++) &#123;if (arr[i] &lt; arr[i - dert]) &#123;let current = i - dert;let temp = arr[i];arr[i] = arr[current];while (temp &lt; arr[current]) &#123;arr[current + dert] = arr[current];current -= dert;&#125;arr[current + dert] = temp;&#125;&#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];shellSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 简单选择排序123456789101112131415161718192021function minIndex(arr, start) &#123;// find the mini indexlet min = start;for (let i = start + 1, len = arr.length; i &lt; len; i++) &#123;if (arr[min] &gt; arr[i]) min = i;&#125;return min;&#125;function selectSort(arr) &#123;let key = 0;for (let i = 0, len = arr.length; i &lt; len; i++) &#123;key = minIndex(arr, i);if (key != i) &#123;// if the mini index is not the current index then exchange value[arr[key], arr[i]] = [arr[i], arr[key]];&#125;&#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];selectSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 堆排序1234567891011121314151617181920212223242526272829303132333435363738function heapAdjust(arr, index, length) &#123;// adjust the heaplet temp = arr[index],child = index _ 2 + 1;while (child &lt; length) &#123;if (child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;// find the more big childchild++;&#125;if (arr[index] &lt; arr[child]) &#123;// exchange the parentNode and the childNodearr[index] = arr[child];index = child;child = index _ 2 + 1;&#125; else &#123;break;&#125;&#125;arr[index] = temp;&#125;function buildHeap(arr) &#123;// create the heaplet len = arr.length;for (let i = (arr.length - 1) / 2; i &gt;= 0; i--) &#123;heapAdjust(arr, i, len);&#125;&#125;function heapSort(arr) &#123;buildHeap(arr);for (let i = arr.length - 1; i &gt;= 0; i--) &#123;// exchange the 0th value and ith value[arr[i], arr[0]] = [arr[0], arr[i]];heapAdjust(arr, 0, i);&#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];heapSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 冒泡排序12345678910111213141516function bubbleSort(arr) &#123;let index = arr.length - 1;while (index &gt; 0) &#123;let pos = 0;for (let j = 0; j &lt; index; j++) &#123;if (arr[j] &gt; arr[j + 1]) &#123;pos = j;[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];&#125;&#125;index = pos;&#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];bubbleSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 快速排序1234567891011121314151617181920212223242526function partition(arr, low, high) &#123;let key = arr[low];while (low &lt; high) &#123;// from right to left to find a value that lower than keywhile (low &lt; high &amp;&amp; arr[high] &gt;= key) high--;[arr[low], arr[high]] = [arr[high], arr[low]];// from left to right to find a value thar large than keywhile (low &lt; high &amp;&amp; arr[low] &lt;= key) low++;[arr[low], arr[high]] = [arr[high], arr[low]];&#125;return low;&#125;function quickSortFunc(arr, low, high) &#123;if (low &lt; high) &#123;// binary iterationslet local = partition(arr, low, high);quickSortFunc(arr, low, local - 1);quickSortFunc(arr, local + 1, high);&#125;&#125;function quickSort(arr) &#123;quickSortFunc(arr, 0, arr.length - 1);&#125;let arr = [6, 7, 2, 3, 1, 4, 5];quickSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 归并排序123456789101112131415161718192021222324function merge(arr1, arr2) &#123;let result = [],length1 = arr1.length,length2 = arr2.length,index1 = 0,index2 = 0,reindex = 0;while (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;if (arr1[index1] &lt; arr2[index2]) &#123;result[reindex++] = arr1[index1++];&#125; else &#123;result[reindex++] = arr2[index2++];&#125;&#125;while (index1 &lt; length1) result[reindex++] = arr1[index1++];while (index2 &lt; length2) result[reindex++] = arr2[index2++]; return result;&#125;let arr1 = [2, 4, 6, 8, 10],arr2 = [1, 3, 5, 7, 9];let result = merge(arr1, arr2);console.log(result); 结果：Array(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","tags":["算法"]},{"title":"简单的LinkList实现","path":"/2019/02/28/简单的LinkList实现/","content":"简单的 LinkList 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Node &#123;constructor(data = -1, prev = null, next = null) &#123;this.data = data;this.prev = prev; // 向前指针this.next = next; // 向后指针&#125;&#125;class LinkList &#123;constructor() &#123;this.head = this.tail = null; // 首、尾指针this.size = 0; // 元素个数&#125; addHead(elem) &#123; let elemNode = new Node(elem); if (this.size == 0) &#123; this.head = this.tail = elemNode; this.size++; &#125; else &#123; this.head.prev = elemNode; elemNode.next = this.head; this.head = elemNode; this.size++; &#125; return true; &#125; deleteHead() &#123; if (this.size != 0) &#123; let elem = this.head.data; this.head.prev = null; this.head = this.head.next; this.size--; return elem; &#125; else &#123; console.log(&#x27;list is empty&#x27;); return; &#125; &#125; addTail(elem) &#123; let elemNode = new Node(elem); if (this.size == 0) &#123; this.head = this.tail = elemNode; this.size++; &#125; else &#123; elemNode.prev = this.tail; this.tail.next = elemNode; this.tail = elemNode; this.size++; &#125; return true; &#125; deleteTail() &#123; if (this.size != 0) &#123; let elem = this.tail.data; this.tail.next = null; this.tail = this.tail.prev; this.size--; return elem; &#125; else &#123; console.log(&#x27;list is empty&#x27;); return; &#125; &#125; display() &#123; let current = this.head, count = this.size, str = &#x27;&#x27;; while (count &gt; 0) &#123; str += current.data + &#x27; &#x27; current = current.next; count--; &#125; console.log(str); &#125;&#125;let linklist = new LinkList();linklist.addHead(1);linklist.addHead(2);linklist.addHead(3);linklist.deleteHead();linklist.addTail(4);linklist.display(); 结果2 1 4","tags":["算法"]},{"title":"简单的Queue实现","path":"/2019/02/28/简单的Queue实现/","content":"简单的 Queue 实现数组实现123456789101112131415161718192021222324252627282930313233343536373839404142434445class Queue &#123;constructor(size = 10) &#123;this.size = size; // 队列最大长度this.top = 0; // 首位置this.bottom = -1; // 尾位置this.elems = 0; // 成员个数this.arr = [] // 队列&#125; add(elem) &#123; if (this.elems == this.size) &#123; console.log(&#x27;Queue is full&#x27;); return; &#125; if (this.bottom == this.size - 1) &#123; // 循环队列 this.bottom = -1; &#125; this.arr[++this.bottom] = elem; this.elems++; return true; &#125; out() &#123; if (this.elems == 0) &#123; console.log(&#x27;Queue is empty&#x27;); return; &#125; let elem = this.arr[this.top] this.arr[this.top] = null; this.top++; if (this.top == this.size) &#123; this.top = 0; &#125; this.elems--; return elem; &#125;&#125;var queue = new Queue();queue.add(3);queue.add(2);console.log(queue.out())console.log(queue.out())console.log(queue.out()) 链式实现1234567891011121314151617181920212223242526272829303132333435363738class Node &#123;constructor(data = -1, next = null) &#123;this.data = data;this.next = next;&#125;&#125;class Queue &#123;constructor() &#123;this.top = null; // 首指针this.bottom = null; // 尾指针this.elems = 0; // 成员个数&#125; add(elem) &#123; if (this.elems == 0) &#123; this.top = this.bottom = new Node(elem); &#125; else &#123; let newNode = new Node(elem); this.bottom.next = newNode; this.bottom = newNode; &#125; this.elems++; &#125; out() &#123; if (this.elems == 0) &#123; console.log(&#x27;queue is empty&#x27;); return; &#125; let current = this.top; let value = current.data; this.top = this.top.next; this.elems--; this.current = null; return value; &#125;&#125; 结果123432Queue is emptyundefined","tags":["算法"]},{"title":"简单的Stack实现","path":"/2019/02/28/简单的Stack实现/","content":"简单的 Stack 实现数组实现123456789101112131415161718192021222324252627282930313233343536373839404142class Stack &#123;constructor(size = 10) &#123;this.arr = []; // 栈this.size = size; // 最大长度this.top = -1; // 栈顶&#125; push(elem) &#123; if (this.top == this.size) &#123; this.size *= 2; &#125; this.arr[++this.top] = elem; return true; &#125; pop() &#123; let elem = this.arr[this.top--]; return elem; &#125; peekTop() &#123; if (this.top == -1) &#123; console.log(&#x27;stack is empty&#x27;); return; &#125; return this.arr[this.top]; &#125; print() &#123; let str = &#x27;&#x27; for (let i = 0; i &lt;= this.top; i++) &#123; str += this.arr[i] + &#x27; &#x27; &#125; console.log(str) &#125;&#125;var stack = new Stack();stack.push(1);stack.push(2);stack.pop();console.log(stack.peekTop()) 链式实现1234567891011121314151617181920212223242526272829303132333435class Node &#123;constructor(data = -1, next = null) &#123;this.data = data;this.next = next;&#125;&#125;class Stack &#123;constructor() &#123;this.top = null; // 栈顶this.elems = 0; // 成员个数&#125; push(elem) &#123; this.top = new Node(elem, this.top); this.elems++; &#125; pop() &#123; if (this.elems == 0) &#123; console.log(&#x27;stack is empty&#x27;); return; &#125; let current = this.top; let elem = current.data; this.top = this.top.next; this.elems--; current = null; return elem; &#125; peekTop() &#123; return this.top.data; &#125;&#125; 结果：1","tags":["算法"]},{"title":"简单的Array实现","path":"/2019/02/28/简单的Array实现/","content":"简单的 Array 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Array &#123;constructor(size = 10) &#123;this.arr = []; // 数组this.size = size; // 最大长度this.elems = 0; // 成员数量&#125; add(elem) &#123; if (this.arr.length == this.size) &#123; console.log(&#x27;Array is full&#x27;); return; &#125; this.arr[this.elems++] = elem; return true; &#125; find(elem) &#123; for (let i = 0, len = this.elems; i &lt; len; i++) &#123; if (this.arr[i] == elem) return i; &#125; return -1; &#125; delete(elem) &#123; let index = this.find(elem); if (index == -1) &#123; console.log(&#x27;Element not found&#x27;); return; &#125; for (let i = index, len = this.elems - 1; i &lt; len; i++) this.arr[i] = this.arr[i + 1]; this.elems--; return true; &#125; update(oldVal, newVal) &#123; // only use for unique element let index = this.find(oldVal); if (index == -1) &#123; console.log(&#x27;Element not found&#x27;); return; &#125; this.arr[index] = newVal; return true; &#125; display() &#123; let srt = &#x27;&#x27;; for (let i = 0, len = this.elems; i &lt; len; i++) &#123; srt += &#x27;&#x27; + this.arr[i] + &#x27; &#x27;; &#125; console.log(srt); &#125; length() &#123; return this.elems; &#125;&#125;var arr = new Array();arr.add(1);arr.add(2);arr.add(3);arr.add(4);arr.display();console.log(arr.length()); 结果121 2 3 44","tags":["算法"]},{"title":"一道有趣的题目","path":"/2019/02/26/一道有趣的题目/","content":"在 CodeWars 上遇见的一道 3kyu 的题目** Task **You’re given an array of integers a and two integers x and y. Count the number of elements in the array such that x ≤ a[i] ≤ y, where i is the 0-based index of the element. ** Code Limit **Less than 48 characters. ** Example **For a &#x3D; [2, 5, 6, 7, 1, 3, 4, 11, 56, 49], x &#x3D; 1 and y &#x3D; 7, the output should be 7. elements 2, 5, 6, 7, 1, 3, 4 should be counted. 这道题有趣的地方在于，代码长度限制在 48 个字符内。最开始我用的是 forEach 去遍历，结果长度超出了一倍，后面考虑用 filter： 1checkRange=(a,x,y)=&gt;a.filter(e=&gt;e&gt;=x&amp;&amp;e&lt;=y).length 但是此时代码长度也有 50，考虑使用 map 来改造，但是 map 和 filter 不一样，数组的长度无法改变，所以就考虑使用一个变量来统计。 1234// 在 JS 中数值与 true 相加会使得结果增加一，所以可以考虑使用变量来与判断的结果相加。// i=0 未定义，在此是全局变量。// Array | Number =&gt; parseInt(Array) | Number =&gt; NaN | Number =&gt; Number, 所以 i 就被返回出去了checkRange=(a,x,y)=&gt;a.map(e=&gt;i+=(x&lt;=e&amp;&amp;e&lt;=y),i=0)|i 但是此时长度还是不够，问题在于 x&lt;&#x3D;e&amp;&amp;x&lt;&#x3D;y 这。仔细分析可知，不满足条件的话，有两种情况，第一种就是 a[i] &lt; x，第二种是 a[i] &gt; y所以只要 a[i] &lt; x &amp;&amp; a[i] &gt; y 的结果为 false 的话 那么就是不满足条件的。此时可以改造为 x &gt; a[i] &#x3D;&#x3D; a[i] &gt; y a[i] &lt; x &lt; y &#x3D;&gt; true &#x3D;&#x3D; false &#x3D;&gt; false x &lt; y &lt; a[i] &#x3D;&gt; false &#x3D;&#x3D; true &#x3D;&gt; false x &lt; a[i] &lt; y &#x3D;&gt; false &#x3D;&#x3D; false &#x3D;&gt; true 此时满足条件。 最后答案为： 1checkRange=(a,x,y)=&gt;a.map(e=&gt;i+=x&gt;e==e&gt;y,i=0)|i","tags":["整理","算法"]},{"title":"ES6读取文件","path":"/2019/02/26/ES6读取文件/","content":"** 需求：已知一个路径，读取文件内容并返回 ** 普通读取文件方式：123456const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)fs.readFile(path.join(\\_\\_dirname, &#x27;./1.txt&#x27;), &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123;if (err) throw errconsole.log(dataStr)&#125;) 封装函数：12345678function getFileByPath(fpath, callback) &#123;fs.readFile(fpath, &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123;// 如果报错，后面的代码无意义if (err) return callback(err)// console.log(dataStr)callback(null, dataStr)&#125;)&#125; 调用函数：1234getFileByPath(path.join(\\_\\_dirname, &#x27;./1.txt&#x27;), (err, dataStr) =&gt; &#123;if (err) return console.log(err.message)console.log(dataStr);&#125;) ** 新需求：顺序读取文件 ** 回调嵌套：123456789getFileByPath(path.join(**dirname, &#x27;./1.txt&#x27;), data =&gt; &#123;console.log(data)getFileByPath(path.join(**dirname, &#x27;./2.txt&#x27;), data =&gt; &#123;console.log(data)getFileByPath(path.join(\\_\\_dirname, &#x27;./3.txt&#x27;), data =&gt; &#123;console.log(data)&#125;)&#125;)&#125;) 用 Promise 改造：12345678910111213141516171819202122232425function getFileByPath(fpath) &#123; // 改造 functionreturn new Promise(function (resolve, reject) &#123;fs.readFile(fpath, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;if (err) reject(err)resolve(data)&#125;)&#125;)&#125;getFileByPath(&#x27;./1.txt&#x27;).then(function (data) &#123; // 读取文件console.log(data)return getFileByPath(&#x27;./2.txt&#x27;)&#125;, function (err) &#123;console.log(err.message)return getFileByPath(&#x27;./2.txt&#x27;)&#125;).then(function (data) &#123;console.log(data)return getFileByPath(&#x27;./3.txt&#x27;)&#125;, function (err) &#123;console.log(err.message)return getFileByPath(&#x27;./3.txt&#x27;)&#125;).then(function (data) &#123;console.log(data)&#125;, function (err) &#123;console.log(err.message)&#125;)","tags":["整理"],"categories":["ECMAScript"]},{"title":"Vue总结（三）","path":"/2019/02/26/Vue总结（三）/","content":"computed12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;&#x27;, lastName: &#x27;&#x27;, &#125;, computed: &#123; // 使用计算属性不需要() // 只要此function中使用的任何数据发生变化，就会重新计算值 fullName: function () &#123; return this.firstName + &#x27;-&#x27; + this.lastName &#125; &#125; &#125;)&lt;/script&gt; watch123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; @keyup=&quot;getFullName&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; @keyup=&quot;getFullName&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;&#x27;, lastName: &#x27;&#x27;, fullName: &#x27;&#x27; &#125;, methods: &#123; getFullName() &#123; this.fullName = this.firstName + &#x27;-&#x27; + this.lastName &#125; &#125;, watch: &#123; firstName: function (newValue, oldValue) &#123; this.fullName = newValue + &#x27;-&#x27; + this.lastName console.log(oldValue) &#125;, lastName: function (newValue) &#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125; &#125;)&lt;/script&gt; 全局组件123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component2&gt;&lt;/my-component2&gt;&lt;/div&gt;&lt;template id=&quot;tmp1&quot;&gt; &lt;h1&gt;template 1&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; var com1 = Vue.extend(&#123; template: `&lt;h3&gt;Vue.extend&lt;/h3&gt;` &#125;) Vue.component(&#x27;my-component2&#x27;, &#123; template: &#x27;#tmp1&#x27; &#125;) Vue.component(&#x27;my-component&#x27;, com1) var vm = new Vue(&#123; el: &#x27;#app&#x27;, &#125;)&lt;/script&gt; 私有组件1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;login&gt;&lt;/login&gt; &lt;test-component&gt;&lt;/test-component&gt;&lt;/div&gt;&lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt;Message&lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; login: &#123; template: &#x27;&lt;h1&gt;private component&lt;/h1&gt;&#x27; &#125;, testComponent: &#123; template: &#x27;#tmp1&#x27; &#125; &#125; &#125;)&lt;/script&gt; 组件传值123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;com1 v-bind:parent-msg=&quot;msg&quot;&gt;&lt;/com1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;parent message&#x27; &#125;, components: &#123; com1: &#123; props: [&#x27;parentMsg&#x27;], // 父组件的数据 readonly template: &#x27;&lt;h1 @click=&quot;change&quot;&gt;fff --- &#123; &#123; parentMsg &#125; &#125;&lt;/h1&gt;&#x27;, data() &#123; // 组件私有的，ajax请求的数据可以放在组件的data上 readwrite return &#123; title: &#x27;abd&#x27; &#125; &#125;, methods: &#123; change() &#123; this.parentMsg = &#x27;changed&#x27; &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 组件传递method123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;app&quot;&gt; &lt;com2 v-on:func=&quot;show&quot;&gt;&lt;/com2&gt;&lt;/div&gt;&lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;child template&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;child button&quot; v-on:click=&quot;myClick&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var com2 = &#123; template: &#x27;#tmpl&#x27;, data() &#123; return &#123; childMsg: &#123; name: &#x27;Edward&#x27;, age: 3 &#125; &#125; &#125;, methods: &#123; myClick() &#123; console.log(&#x27;myClick called&#x27;) this.$emit(&#x27;func&#x27;, this.childMsg) &#125; &#125; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dataFromChild: null &#125;, components: &#123; com2 &#125;, methods: &#123; show(data) &#123; this.dataFromChild = data // 子组件向父组件传值 &#125; &#125; &#125;)&lt;/script&gt; 组件切换123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;flag = true&quot;&gt;Login in&lt;/a&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;flag = false&quot;&gt;Sign in&lt;/a&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else&gt;&lt;/register&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;comName = &#x27;login&#x27;&quot;&gt;Login in&lt;/a&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;comName = &#x27;register&#x27;&quot;&gt;Sign in&lt;/a&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;Login&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;Register&lt;/h3&gt;&#x27; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true, comName: &#x27;login&#x27; &#125; &#125;)&lt;/script&gt; vue-router123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;!-- tag改变展示元素 --&gt; &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;login&lt;/h1&gt;&#x27; &#125; var register = &#123; template: &#x27;&lt;h1&gt;register&lt;/h1&gt;&#x27; &#125; const routerObj = new VueRouter(&#123; routes: [ // 路由匹配规则 path, component必须参数 &#123; path: &#x27;/&#x27;, redirect: &#x27;/login&#x27; &#125;, // redirect 重定向 &#123; path: &#x27;/login&#x27;, component: login &#125;, &#123; path: &#x27;/register&#x27;, component: register &#125; ], linkActiveClass: &#x27;myactive&#x27; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; &#125;, router: routerObj &#125;)&lt;/script&gt; 路由传参123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login?id=10&amp;name=zhangsan&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;Login --- &#123; &#123; $route.query.id &#125; &#125; --- &#123; &#123; $route.query.name &#125; &#125;&lt;/h1&gt;&#x27;, data() &#123; return &#123; msg: &#x27;123&#x27; &#125; &#125;, created() &#123; // 组件的生命周期 console.log(this.$route.query.id) &#125;, &#125; var register = &#123; template: &#x27;&lt;h1&gt;Register&lt;/h1&gt;&#x27; &#125; const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/login&#x27;, component: login &#125;, &#123; path: &#x27;/register&#x27;, component: register &#125; ] &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, router &#125;)&lt;/script&gt; 路由嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;Account component&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;Register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var account = &#123; template: &#x27;#tmpl&#x27; &#125; var login = &#123; template: &#x27;&lt;h1&gt;Login&lt;/h1&gt;&#x27; &#125; var register = &#123; template: &#x27;&lt;h1&gt;Register&lt;/h1&gt;&#x27; &#125; const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/account&#x27;, component: account, children: [ // 子路由path不带 &#x27;/&#x27; 否则以根目录还是匹配 &#123; path: &#x27;login&#x27;, component: login &#125;, &#123; path: &#x27;register&#x27;, component: register &#125; ] &#125;, ] &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, router &#125;)&lt;/script&gt; render渲染组件12345678910111213141516171819&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;Login&lt;/h1&gt;&#x27; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; &#125;, render: function (createElements) &#123; // 将指定的模板渲染成html return createElements(login) // return的结果会替换el指定的容器 &#125; &#125;)&lt;/script&gt;","tags":["整理"],"categories":["Vue"]},{"title":"Vue总结（二）","path":"/2019/02/26/Vue总结（二）/","content":"filter123456789101112Vue.filter(&#x27;msgFormat&#x27;, function (msg, arg) &#123;return msg.replace(/test/g, arg)&#125;)Vue.filter(&#x27;test&#x27;, function (msg) &#123;return msg + &#x27;====&#x27;&#125;)var vm = new Vue(&#123;el: &#x27;#app&#x27;,data: &#123;msg: &#x27;test1 test2 test3&#x27;&#125;&#125;) privateFilter1234567891011121314151617181920212223var vm = new Vue(&#123;el: &#x27;#app&#x27;,data: &#123;dt: new Date()&#125;,filters: &#123;dateFormate: function (dateStr, pattern = &#x27;&#x27;) &#123;var dt = new Date(dateStr)var y = dt.getFullYear()var m = dt.getMonth() + 1var d = dt.getDate() if (pattern.toLowerCase() == &#x27;yyyy-mm-dd&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125;&#125;) ** eg: ** 1234567891011121314151617181920212223var vm = new Vue(&#123;el: &#x27;#app&#x27;,data: &#123;dt: new Date()&#125;,filters: &#123;dateFormate: function (dateStr, pattern = &#x27;&#x27;) &#123;var dt = new Date(dateStr)var y = dt.getFullYear()var m = (dt.getMonth() + 1).toString().padStart(2, &#x27;0&#x27;)var d = dt.getDate().toString().padStart(2, &#x27;0&#x27;) if (pattern.toLowerCase() == &#x27;yyyy-mm-dd&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` else &#123; var hh = dt.getHours().toString().padStart(2, &#x27;0&#x27;) var mm = dt.getMinutes().toString().padStart(2, &#x27;0&#x27;) var ss = dt.getSeconds().toString().padStart(2, &#x27;0&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125;&#125;) Lifecycle123456789101112131415161718192021222324252627282930313233343536373839404142434445var vm = new Vue(&#123;el: &#x27;#app&#x27;,data: &#123;msg: &#x27;ok&#x27;&#125;,methods: &#123;show() &#123;console.log(&#x27;run show&#x27;)&#125;&#125;,beforeCreate() &#123;// data 和 methods 数据都未初始化// console.log(this.msg)// this.show()&#125;,created() &#123;console.log(this.msg)this.show()&#125;,beforeMount() &#123;// 编译好了模板，还未挂载到页面中console.log(document.getElementById(&#x27;h3&#x27;).innerText)&#125;,mounted() &#123;// 模板已经挂载到页面中console.log(document.getElementById(&#x27;h3&#x27;).innerText)// mounted 之后表示 Vue 实例已经被完全创建好了&#125;, beforeUpdate() &#123; // 数据改变，页面未变 console.log(document.getElementById(&#x27;h3&#x27;).innerText) &#125;, updated() &#123; // 数据和页面都改变了 &#125;, beforeDestroy() &#123; // data 和 methods 都可以使用 &#125;, destroyed() &#123; // 完全销毁 &#125;,&#125;)","tags":["整理"],"categories":["Vue"]},{"title":"Vue总结（一）","path":"/2019/02/26/Vue总结（一）/","content":":class 绑定1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;[&#x27;italic&#x27;, &#x27;red&#x27;, &#123;&#x27;active&#x27;: flag&#125;]&quot;&gt;Test H1 Message&lt;/h1&gt; &lt;h1 :class=&quot;classObj&quot;&gt;Test H1 Message&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true, classObj: &#123; red:true, thin:true, italic:true, active:false&#125; &#125; &#125;)&lt;/script&gt; :style绑定1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;[styleObj, styleObj2]&quot;&gt;This is H1&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; styleObj: &#123; color: &#x27;red&#x27;, &#x27;font-weight&#x27;: &#x27;280&#x27; &#125;, styleObj2: &#123; &#x27;font-style&#x27;: &#x27;italic&#x27; &#125; &#125; &#125;)&lt;/script&gt; preventDefault12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;divHandler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;click me&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;a href=&quot;http://github.io&quot; @click.prevent=&quot;linkClick&quot;&gt;link&lt;/a&gt; &lt;div class=&quot;inner&quot; @click.capture=&quot;divHandler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;click me&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;divHandler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;click me&quot; @click.self=&quot;btnHandler&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; divHandler() &#123; console.log(&#x27;inner div&#x27;) &#125;, btnHandler() &#123; console.log(&#x27;btn click&#x27;) &#125;, linkClick() &#123; console.log(&#x27;link click&#x27;) &#125; &#125; &#125;)&lt;/script&gt; v-cloak1234567891011121314151617&lt;style&gt; [v-cloak] &#123; display: none !important; &#125; &lt;/style&gt;&lt;div id=&quot;app&quot; v-cloak&gt; &lt;p&gt;&#123; &#123; msg &#125; &#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;ss&#x27; &#125; &#125;)&lt;/script&gt; v-for123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;item in list&quot;&gt;&#123; &#123; item.id &#125; &#125; --- &#123; &#123; item.name &#125; &#125;&lt;/p&gt; &lt;p v-for=&quot;(value, key) in user&quot;&gt;&#123; &#123; key &#125; &#125; -- &#123; &#123; value &#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#123; id: 1, name: &#x27;name1&#x27; &#125;, &#123; id: 2, name: &#x27;name2&#x27; &#125;, &#123; id: 3, name: &#x27;name3&#x27; &#125;, &#123; id: 4, name: &#x27;name4&#x27; &#125;, ], user: &#123; id: 1, name: &#x27;Hello world&#x27;, gender: &#x27;male&#x27; &#125; &#125; &#125;)&lt;/script&gt; ** eg: ** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label for=&quot;id&quot;&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label for=&quot;name&quot;&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;p v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;&#123; &#123; item.id &#125; &#125; --- &#123; &#123; item.name &#125; &#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [&#123; id: 1, name: &#x27;孔子&#x27; &#125;, &#123; id: 2, name: &#x27;孟子&#x27; &#125;, &#123; id: 3, name: &#x27;韩非子&#x27; &#125;, ] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;)&lt;/script&gt; v-if1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag = !flag&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;V-IF&lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt;V-SHOW&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;)&lt;/script&gt;","tags":["整理"],"categories":["Vue"]},{"title":"webpack配置","path":"/2019/02/25/webpack配置/","content":"项目文件目录123456789101112-Demo|--build|--dist|--css|--js|--view|--node_modules|--src|--|--package.json|--webpack.config.js|--webpack.production.config.js src：代码开发目录 build：开发环境 webpack 输出目录 dist：生产环境 webpack 输出目录 package.json：项目配置 webpack.config.js：开发环境配置 webpack.production.config.js：生产环境配置 webpack 配置文件需命名为 webpack.config.js 123456789101112131415161718192021222324252627282930313233const path = require(&#x27;path&#x27;) // 模块module.exports = &#123;mode: &#x27;development&#x27;,entry: path.join(**dirname, &#x27;./src/main.js&#x27;), // 入口文件output: &#123;path: path.join(**dirname, &#x27;./dist&#x27;), // 输出文件filename: &#x27;bundle.js&#x27;&#125;,plugins: [ // 插件],module: &#123;rules: [ // 路由规则&#123;test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/,use: &#x27;url-loader?limit=1111&amp;name=[hash:8]-[name].[ext]&#x27;&#125;,&#123;test: /\\.(ttf|eot|svg|woff|woff2)$/, use: &#x27;url-loader&#x27; &#125;, &#123; test: /\\.js$/,use: &#x27;babel-loader&#x27;,exclude: /node_modules/&#125;,]&#125;,&#125; webpack-dev-server 通过 npm 安装：npm i webpack-dev-server 运行命令：webpack-dev-server –devtool eval –port 9876 –progress –colors – compress –hot –inline –content-base .&#x2F;build可以在 package.json 中的 script 加一个启动项。 –devtool eval：在报错时精确到文件的行号 –progress：显示编译的输出内容进度 –compress：启用 gzip 压缩 –hot：热更新，无需刷新浏览器 –colors：显示编译的输出内容颜色 –inline：自动刷新模式。默认为 iframe。 –content-base：设置输出目录。","tags":["整理","学习"]},{"title":"广州之行","path":"/2018/12/24/广州之行/","content":"导语想着下学期开始可能没有太多时间了，而且大学间还没有旅过游，所以就挑了个时间去了广州。由于时间不是很足，所以去的地方不是很多，主要还是那几个比较火的地点： 上下九 北京路 江南西 海珠区 而且……拍的照也不是很多。 上火车本以为挑的时间段算比较好的，但是失算了。火车上挺多人的，但是与春运相比又显得人挺少的。可能大部分都是去考研的吧，很多背着包的大学生。对面的老大爷和右边的是一家，听口音像是潮州那边的。半道老大爷还拿出了一瓶葡萄酒，喝了起来。中途老大爷睡着了，长得和家有儿女里夏雨的爷爷相似。临走时估摸着大爷听见了我们也是去广州的，并没有与普通人说帅哥，而是说了句“靓仔” 其实坐火车也是很有趣的一件事，比坐医院里观察人要欢乐的多。 到达广州在晚上九点多到达了广州站，出来明显感觉到热！不是一般的热！看了看天气似乎是 25℃。与其他火车站一样，出站口聚集了许多住宿的房东。好在提前订好了房间，于是出发乘坐地铁去往住处。路线是 广州站-&gt;2 号线-&gt;江南西 广州第一餐或许是赶上了互联网行业下班时间，路上有许多背着瑞士包的男生，少数格子衫的，地铁人挺多，但是算不上挤。到达广州第一餐，就是久违的 MacDonald，对，MacDonald。当然也就是解解馋了，毕竟上学的地方只有一家MacDonald，而且在车站。 肠粉这次来广州只吃了一次肠粉，因为时间关系不能再吃第二餐，只能等回家吃了。准备吃的时候，发现了两家，一家是华辉拉肠，一家是银记肠粉。虽然听过银记肠粉的名头，但是还是选择了华辉拉肠，原因是——有个本地人说了句华辉拉肠好吃。点了一个普通的蛋肠和皮蛋瘦肉粥，但是当我吃第一口的时候我就后悔了。酱料，不应该叫做酱料，应该叫酱油，而且还是老抽。这和我小时候吃的普通肠粉、石磨肠粉、簸箕肠粉完全就是两个味道，实在是太失望了，而且没有酱汁，这是最大的槽点。肠粉没了酱汁，我觉得就不能叫做肠粉了。吃完后已经快十二点了，所以选择回去休息。 住处住处是在 Airbnb 上找的，但是可能是专业人士经营的，买的没有卖的精。虽说实物与网图差距不是很大，但还是挺不满意的。唯一的满意之处也就是与众不同+交通方便了吧。只摄了一张图（没错就是我的脚）： 第一天这天起的挺早的，还在收拾的时候就听见楼下传来一声“点外卖用饿了吗”，几十个外卖小哥骑着小蓝车开始刷街了，也不知道是不是饿了吗的传统活动。住的地方在江南西，周围挺多网红店的，但是营业时间大部分都是早上十点开始，所以考虑晚上回来再看看。 江南西-&gt;宝业路-&gt;沙园 一早去的地方是宝业路，但是几乎都是烧烤店，所以就没有做过多停留，选择去寻找一家烤西瓜的店。地图上看的那家店在一家商场里，但是转了很久都没找着，根据定位判断，可能是不开了，因为那家店的位置开了家新店，而且在搞活动：所以，我们决定去北京路。 沙园-&gt;8 号线-&gt;2 号线-&gt;6 号线-&gt;北京路 不得不说北京路的小吃非常多，各种小吃都有。但是，人多，很多都是长长的队伍。买了根蟹肉棒：原味脆皮棒（给我的感觉就是泡芙）：时间已经差不多到午饭的点了，附近刚好有家点都德，就决定去了。过了早茶的时间，人不是很多，来的也大部分都是游客，都是奔着拍照来的。椰汁糕，没得说的：排骨（牙齿整形 ing 咬不动）：灌汤包（被我手快夹了一个）：还有虾饺，云吞，港式混酱肠粉。嗯，混酱，芝麻酱、甜面酱、酱油，负分！吃饱后开始散食了，附近兜兜转转，赏赏花：顺便顺着地图找到了家店——步步高昇钵仔糕：这家店不一样的原因是会放鸡蛋，与普通的钵仔糕不一样，普通的一般不放或者放椰果什么的（其实钵仔糕没什么味道）：感觉逛得差不多了，想吃的吃的着的都吃了，吃不着的都是人，决定换个地方。 北京路-&gt;6 号线-&gt;文化公园 文化公园往前走点，就发现了大大的招牌：与北京路差不多，人挺多的，但是小吃感觉挺少的，大部分还是服饰的商家。让我倍感神奇的是，臭豆腐也可以排那么长的队伍。逛了逛手信，还是觉得鸡仔饼可以让我提起兴趣，其余的在小时候已经吃腻了。顺带买了瓶凉茶治咳嗽（现在觉得一点效果也没有）：然后就一路走到了黄沙，途中遇到了迪卡侬（滴滴）：也差不多一下午就逛完了，还是决定去北京路附近吃。 黄沙-&gt;6 号线-&gt;北京路 这次路过了大头虾，排队的人依然很多，本准备翻翻菜单就走，然后发现有两人的位置，于是就进去了。上菜速度还是有点慢的，而且，越式菜也有点吃不惯。三色刨冰：越式春卷（味道怪怪的，但是配上酱料还算能吃）：盐焗基围虾：越式炒米（大赞，要不是吃不下了）：虽然吃的不多，但是会有饱的感觉（也许是错觉）。临走看看排队的人们： 北京路-&gt;天字码头-&gt;大沙头游船码头 又到了散食时间，沿着北京路一直往下走，去江边看看。沿途经过的酒吧：江边有挺多拍照的人，也许是光线挺美的吧：还有苟：本来想着直接走去看广州塔的，看了看地图……行吧，坐地铁。 东湖-&gt;6 号线-&gt;1 号线-&gt;5 号线-&gt;珠江新城 不直接去广州塔的原因是我觉得站在塔底反而不好拍了。到了珠江新城，崩溃了，为什么这个出口可以这么长，走了快十分钟还没出去。但是终于，还是看见了广州塔：趁着没有人合影的时机，来了张：旁边就是 K11：但是由于已经挺晚的了，回去晚了没地铁了，所以就没进去。 第一天到这就差不多结束了，回去收拾收拾就碎觉了。 第二天第二天就起的比较晚了，而且下午就得上车，所以也就在广州东附近转了几圈。 江南西-&gt;2 号线-&gt;8 号线-&gt;3 号线-&gt;广州东上 3 号线时本以为大家都是去广州东的，结果后面两站一车厢只剩几个人了，来这第一次在地铁上可以坐着。 去了广州东站寄存了行李后，就出来觅食了。在大众点评上看好了一家店，奔着那出发。途中经过一家一点点，只有一个人，这也是在广州第一次看见没人排队的一点点，买到了红茶冰淇淋：花了近二十分钟到了那家店，发现门上贴着一张纸：“臨时休息”，好嘛白跑一趟。决定去路上经过的鸟剑居酒屋（十号店），坐下后发现周围三桌都是日本家庭，女性有很明显的家庭主妇的气质。鱼籽寿司：日式薄饼：照烧鸡扒定食：吃完了就差不多到了该上车的点了，至此本次旅行也画上了句号。 至此我的大学首次旅行也结束了，有的地方还是没有做足准备，但是总的来说还是不错的。","tags":["旅游"],"categories":["Travel"]},{"title":"C %s格式化输出","path":"/2018/11/07/C-s格式化输出/","content":"写题时遇见的一个东西123char\\* s = &quot;hello world&quot;;printf(&quot;%15.2s&quot;, s);//result: he 找到如下用法： *%ms:输出的字符串占 m 列，如字符串本身长度大于 m,则突破获 m 的限制，将字符串全部输出。若串长小于 m,则左补空格。 *%-ms:如果串长小于 m,则在 m 列范围内，字符串向左靠，右补空格。 *%m.ns:输出占 m 列，但只取字符串中左端 n 个字符。这 n 个字符输出在 m 列的右侧，左补空格，注意：如果 n 未指定，默认为 0. *%-m.ns:其中 m、n 含义同上，n 个字符输出在 m 列范围的左侧，右补空格。如果 n&gt;m,则自动取 n 值，即保证 n 个字符正常输出，注意：如果 n 未指定，默认为 0. 如果是 sprintf(desc, “%m.ns”, sour); 如果 desc 空间够的话，会在%m.ns 串 的结尾自动补 null 字符，不同于 strncpy.例如 :sprintf(desc, “%.3s”, “123456”); desc 如果空间&gt;&#x3D;4 字节的话，第 4 个字节将是 null 字符。","tags":["整理","学习"],"categories":["C"]},{"title":"跨浏览器处理处理XML","path":"/2018/11/01/跨浏览器处理处理XML/","content":"一个简单的处理 XML 的函数123456789101112131415161718192021function parseXml(xml) &#123; //跨浏览器处理 XMLvar xmldom = null; if (typeof DOMParser != &#x27;undefined&#x27;) &#123; xmldom = (new DOMParser()).parseFromString(xml, &#x27;text/xml&#x27;); var errors = xmldom.getElementsByTagName(&#x27;parsererror&#x27;); if (errors.length) &#123; throw new Error(&#x27;XML parsing error:&#x27; + errors[0].textContent); &#125; &#125; else if (typeof ActiveXObject != &#x27;undefined&#x27;) &#123; xmldom = createDocument(); xmldom.loadXML(xml); if (xmldom.parseError != 0) &#123; throw new Error(&#x27;XML parsing error:&#x27; + xmldom.parseError.reason); &#125; &#125; else &#123; throw new Error(&#x27;No XML parser available.&#x27;); &#125; return xmldom;&#125; 序列化 XML 文档12345678910111213//序列化 xmldom 文档function serializeXML(xmldom)&#123;if(typeof XMLSerializer!=&quot;undefined&quot;)&#123; //兼容 ie9+ safari Chrome operavar serializer = new XMLSerializer();return (serializer.serializeToString(xmldom));&#125;else if((typeof xmldom.xml)!=undefined)&#123;//兼容 ie9.0 以下return (xmldom.xml);&#125;else&#123;throw new Error(&quot;serialize XML Dom failed!&quot;);&#125;&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"EventUtil.js","path":"/2018/11/01/EventUtil-js/","content":"EventUtil为了在不同的浏览器中处理相同的事件，需要编写一段可以兼容大部分浏览器的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var EventUtil = &#123; addHandler: function (element, type, handler) &#123; //添加事件 if (element.addEventListener) &#123; element.addEventListener(type, handler, false); //使用DOM2级方法添加事件 &#125; else if (element.attachEvent) &#123; //使用IE方法添加事件 element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; //使用DOM0级方法添加事件 &#125; &#125;, removeHandler: function (element, type, handler) &#123; //取消事件 if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, getEvent: function (event) &#123; //使用这个方法跨浏览器取得event对象 return event ? event : window.event; &#125;, getTarget: function (event) &#123; //返回事件的实际目标 return event.target || event.srcElement; &#125;, preventDefault: function (event) &#123; //阻止事件的默认行为 if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function (event) &#123; //立即停止事件在DOM中的传播 //避免触发注册在document.body上面的事件处理程序 if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, getRelatedTarget: function (event) &#123; //获取mouseover和mouseout相关元素 if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; //兼容IE8- return event.toElement; &#125; else if (event.formElement) &#123; return event.formElement; &#125; else &#123; return null; &#125; &#125;, getButton: function (event) &#123; //获取mousedown或mouseup按下或释放的按钮是鼠标中的哪一个 if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)) &#123; return event.button; &#125; else &#123; switch (event.button) &#123; //将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1: case 3: case 5: case 7: return 0; //按下的是鼠标主按钮 case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮 &#125; &#125; &#125;, getWheelDelta: function (event) &#123; //获取表示鼠标滚轮滚动方向的数值 if (event.wheelDelta) &#123; return event.wheelDelta; &#125; else &#123; return -event.detail * 40; &#125; &#125;, getCharCode: function (event) &#123; //以跨浏览器取得相同的字符编码，需在keypress事件中使用 if (typeof event.charCode == &quot;number&quot;) &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;&#125;;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"new Study","path":"/2018/10/30/new-Study/","content":"开始新一轮的学习大晴天，白天上课，晚上班会。在傍晚时发现了有一丝的腰疼。晚上回到寝室突然又有点心绞痛的迹象···。年纪轻轻应该不会有大碍，应该吧···毕竟也没有去检查过身体。今天开始应该会把兼职辞了，开始新的学习吧。驾照什么的···就留着寒暑假有空再说吧。 date: 22:35 2018&#x2F;10&#x2F;30","tags":["雜談"]},{"title":"Generator","path":"/2018/09/01/Generator/","content":"基本用法12345678910function* testGenerator() &#123; yield &#x27;hello&#x27; yield &#x27;world&#x27; return &#x27;done&#x27;&#125;let test = testGenerator()test.next() // &#123; value : &#x27;hello&#x27;, done : false &#125;test.next() // &#123; value : &#x27;world&#x27;, done : false &#125;test.next() // &#123; value : &#x27;done&#x27;, done : true &#125;test.next() // &#123; value : undefined, done : true &#125; yield 表达式Generator 的 next 方法运行逻辑如下： 遇到 yield 语句就暂停执行后面的操作，并将紧跟在 yield 后的表达式的值作为的对象的 value 属性值 下一次调用 next 方法时在继续往下执行，直到遇到下一条 yield 语句 如果没有遇到新的 yield 语句，就一直运行到函数结束，知道运行到 return 为止，并将 return 语句后面的表达式作为返回对象的 value 属性值 如果该函数没有 return 语句，则返回对象的 value 属性值为 undefined yield 是惰性求值的： 123function* gen() &#123; yield 123 + 456&#125; 以上的代码只有在 next 将指针移到这一句时才求值。Generator 函数可以不使用 yield 语句，此时就变成了一个暂缓执行的函数，只有在调用了 next 时才执行： 12345function* f() &#123; console.log(&#x27;run&#x27;)&#125;let generator = f()setTimeout(() =&gt; generator.next(), 3000) 展开数组嵌套： 123456789101112131415var arr = [[1, 2], 3, [4, [5]]]var flat = function* (arr) &#123; var length = arr.length for (var i = 0; i &lt; length; i++) &#123; var item = arr[i] if (typeof item !== &#x27;number&#x27;) &#123; yield* flat(item) &#125; else &#123; yield item &#125; &#125;&#125;for (var f of flat(arr)) &#123; console.log(f) // 1, 2, 3, 4, 5&#125; next 方法的参数next 可以带有一个参数，该参数会被当做上一条 yield 语句的返回值，这样就可以在 Generator 函数运行的不同阶段从外部向内部注入不同的值，从而调整函数的行为： 123456789101112131415function* f() &#123; for (var i = 0; true; i++) &#123; var reset = yield i if (reset) &#123; i = -1 &#125; &#125;&#125;let generator = f()generator.next() // &#123; value : 0, done : false &#125;generator.next() // &#123; value : 1, done : false &#125;generator.next() // &#123; value : 2, done : false &#125;generator.next(true) // &#123; value : 0, done : false &#125;generator.next() // &#123; value : 1, done : false &#125;generator.next() // &#123; value : 2, done : false &#125; V8 引擎直接忽略第一次使用 next 时的参数，只有第二次使用 next 开始的参数才是有效的向内部注入值的例子： 12345678910function* dataConsumer() &#123; console.log(&#x27;start&#x27;) console.log(`1. $&#123;yield&#125;`) console.log(`2. $&#123;yield&#125;`) return &#x27;result&#x27;&#125;let run = dataConsumer()run.next() // &#x27;start&#x27;run.next(&#x27;first&#x27;) // 1. firstrun.next(&#x27;haha&#x27;) // 2. haha Generator.prototype.throw()throw 方法可以在函数体外抛出错误，然后在 Generator 函数体内捕获： 123456789101112131415var g = function* () &#123; try &#123; yield &#125; catch (e) &#123; console.log(&#x27;内部捕获&#x27;, e) &#125;&#125;var i = g()i.next()try &#123; i.throw(&#x27;a&#x27;) // 内部捕获 a i.throw(&#x27;b&#x27;) // 外部捕获 b&#125; catch (e) &#123; console.log(&#x27;外部捕获&#x27;, e)&#125; throw 方法可以接受一个参数，该参数会被 catch 语句接收： 1234567891011var g = function* () &#123; try &#123; yield &#125; catch (e) &#123; console.log(e) &#125;&#125;var i = g()i.next()i.throw(new Error(&#x27;test&#x27;))// Error: test 如果 Generator 函数内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误不影响下一次遍历，否则遍历直接终止。遍历器的 throw 与 throw 不同，后者只能被函数体外的 catch 捕获到throw 方法被捕获后会附带执行下一条 yield 表达式，即执行一次 next 方法： 1234567891011var gen = function* () &#123; try &#123; yield console.log(&#x27;a&#x27;) &#125; catch (e) &#123;&#125; yield console.log(&#x27;b&#x27;) yield console.log(&#x27;c&#x27;)&#125;var g = gen()g.next() // &#x27;a&#x27;g.throw() // &#x27;b&#x27;g.next() // &#x27;c&#x27; Generator 函数体内抛出的错误也能被函数体外的 catch 捕获： 123456789101112function* foo() &#123; var x = yield 3 var y = x.toUpperCase() yield y&#125;var it = foo()it.next() // &#123; value : 3, done : false &#125;try &#123; it.next(32)&#125; catch (e) &#123; console.log(e) //TypeError&#125; 一旦 Generator 执行过程中抛出错误，就不会再执行下去。如果此后再调用 next，将返回一个 value 属性等于 undefined，done 属性等于 true 的对象。 Generator.prototype.return()返回给定的值，并终结 Generator 函数的遍历： 123456789function* gen() &#123; yield 1 yield 2 yield 3&#125;var g = gen()g.next() // &#123; value : 1, done : false &#125;g.return(&#x27;foo&#x27;) // &#123; value : &#x27;foo&#x27;, done : true &#125;g.next() // &#123; value : undefined, done : true &#125; 如果 Generator 函数内部有 try…catch 代码块，那么 return 方法会推迟到 finally 代码块执行完成再执行。 yield*用于在一个 Generator 函数中执行另一个 Generator 函数。 1234567891011121314151617function* foo() &#123; yield &#x27;a&#x27; yield &#x27;b&#x27;&#125;function* bar() &#123; yield &#x27;x&#x27; yield* foo() yield &#x27;y&#x27;&#125;//等同于function* bar() &#123; yield &#x27;x&#x27; yield &#x27;a&#x27; yield &#x27;b&#x27; yield &#x27;y&#x27;&#125; 用 yield*取出嵌套数组成员： 1234567891011function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for (let i = 0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]) &#125; &#125; else &#123; yield tree &#125;&#125;const tree = [&#x27;a&#x27;, [&#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;, &#x27;e&#x27;]]for (let x of iterTree(tree)) console.log(x) // a b c d e 遍历完全二叉树： 123456789101112131415161718192021222324function Tree(left, label, right) &#123; this.left = left this.label = label this.right = right&#125;//中序遍历函数function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left) yield t.label yield* inorder(t.right) &#125;&#125;//生成二叉树function make(array) &#123; if (array.length === 1) return new Tree(null, array[0], null) return new Tree(make(array[0]), array[1], make(array[2]))&#125;let tree = make([[[&#x27;a&#x27;], &#x27;b&#x27;, [&#x27;c&#x27;]], &#x27;d&#x27;, [[&#x27;e&#x27;], &#x27;f&#x27;, [&#x27;g&#x27;]]])var result = []for (let node of inorder(tree)) &#123; result.push(node)&#125;result // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;] 作为对象属性的 Generator 函数1234567891011let obj = &#123; *myGeneratorMethod() &#123; //... &#125;,&#125;//等价写法let obj = &#123; myGeneratorMethod: function* () &#123; //... &#125;,&#125; Generator 函数 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，它也继承了 Generator 函数的 prototype 对象上的方法。 1234567function* g() &#123;&#125;g.prototype.hello = function () &#123; return &#x27;hi&#x27;&#125;let obj = g()obj instanceof g // trueobj.hello() // &#x27;hi&#x27; 让 Generator 函数返回一个正常对象的实例，既可以使用 next 方法，又可以获得正常的 this： 方法一： 12345678910111213function* F() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;var obj = &#123;&#125;var f = F.call(obj) // obj 绑定thisf.next() // &#123; value : 2, done : false &#125;f.next() // &#123; value : 3, done : false &#125;f.next() // &#123; value : undefined, done : true &#125;obj.a // 1obj.b // 2obj.c // 3 方法二： 123456789101112131415function* gen() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;function F() &#123; return gen.call(gen.prototype)&#125;var f = new F()f.next() // &#123; value : 2, done : false &#125;f.next() // &#123; value : 3, done : false &#125;f.next() // &#123; value : undefined, done : true &#125;f.a // 1f.b // 2f.c // 3 Generator 函数与状态机123456789101112var clock = function* () &#123; while (true) &#123; console.log(&#x27;Tick&#x27;) yield console.log(&#x27;Tock&#x27;) yield &#125;&#125;let c = clock()c.next() // Tickc.next() // Tockc.next() // Tick 异步操作的同步化表达123456789101112function* loadUI() &#123; showLoadingScreen() yield loadUIDataAsynchronously() hideLoadingScreen()&#125;var loader = loadUI()//加载UIloader.next()//卸载UIloader.next() 用同步方式表达 Generator 部署 AJAX 操作： 123456789101112function* main() &#123; var result = yield request(&#x27;http://some.url&#x27;) var resp = JSON.parse(result) console.log(resp.value)&#125;function request(url) &#123; makeAjaxCall(url, function (response) &#123; it.next(response) &#125;)&#125;var it = main()it.next() Async Generator123456789101112131415161718192021class A &#123; to = 0 constructor() &#123;&#125;&#125;const range = &#123; from: 1, to: 5, async *[Symbol.asyncIterator]() &#123; for (let i = this.from, to = this.to; i &lt; to; i++) &#123; await new Promise((resolve) =&gt; setTimeout(resolve, 1000)) yield i &#125; &#125;,&#125;;(async function () &#123; // for await of will call the [Symbol.asyncIterator] for await (const value of range) console.log(value)&#125;)()","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Iterator","path":"/2018/08/31/Iterator/","content":"Iterator 概念Iterator 是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署 Iterator 接口，就可以完成遍历操作。Iterator 的主要作用：为数据结构提供统一的、简便的访问接口；使得数据结构的成员能够按照某种次序排列；供 for…of 消费。遍历过程如下： 创建一个指针对象，指向当前数据结构的起始位置。 第一次调用指针对象的 next 方法，将指针指向数据结构的第一个成员。 第二次调用 next 方法，指向第二个成员。 不断调用 next 方法，直到指针指向数据结构的结束位置。 每次调用 next 方法都会返回数据结构当前成员的信息，返回一个包含 value 的 done 两个属性的对象。value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。模拟 next 方法返回值： 1234567891011121314var it = makeIterator([&#x27;a&#x27;, &#x27;b&#x27;])it.next() // &#123; value : &#x27;a&#x27;, done : false &#125;it.next() // &#123; value : &#x27;b&#x27;, done : false &#125;it.next() // &#123; value : undefined, done : true &#125;function makeIterator(array) &#123; var nextIndex = 0 return &#123; next: function () &#123; return nextIndex &lt; array.length ? &#123; value: array[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125; &#125;, &#125;&#125; 遍历器与所遍历的数据结构实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者用遍历器对象模拟出数据结构。无限运行的遍历器对象的例子： 123456789101112var it = idMaker()it.next().value // 0it.next().value // 1//...function idMaker() &#123; var index = 0 return &#123; next: function () &#123; return &#123; value: index++, done: false &#125; &#125;, &#125;&#125; 默认 Iterator 接口类部署 Iterator 接口： 1234567891011121314151617181920212223class RangeIterator &#123; constructor(start, stop) &#123; this.value = start this.stop = stop &#125; [Symbol.iterator]() &#123; return this &#125; next() &#123; var value = this.value if (value &lt; this.stop) &#123; this.value++ return &#123; value: value, done: false &#125; &#125; return &#123; value: undefined, done: true &#125; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop)&#125;for (var value of range(0, 3)) &#123; console.log(value) // 0, 1, 2&#125; 实现指针结构： 12345678910111213141516171819202122232425262728function Obj(value) &#123; this.value = value this.next = null&#125;Obj.prototype[Symbol.iterator] = function () &#123; var iterator = &#123; next: next &#125; var current = this function next() &#123; if (current) &#123; var value = current.value // 获取当前值 current = current.next // 指向下一个实例 return &#123; value: value, done: false &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125; return iterator&#125;var one = new Obj(1)var two = new Obj(2)var three = new Obj(3)one.next = twotwo.next = threefor (var i of one) &#123; console.log(i) // 1, 2, 3&#125; 为对象添加 Iterator 接口： 12345678910111213141516171819let obj = &#123; data: [&#x27;hello&#x27;, &#x27;world&#x27;], [Symbol.iterator]() &#123; const self = this let index = 0 return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false, &#125; &#125; else &#123; return &#123; value: undefined, done: true &#125; &#125; &#125;, &#125; &#125;,&#125; 类似数组对象调用数组的 Symbol.iterator 方法： 12345678910let iterable = &#123; 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, 2: &#x27;c&#x27;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator],&#125;for (let item of iterable) &#123; console.log(item) // &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; 普通对象部署数组的 Symbol.iterator 方法并无效果。如果 Symbol.iterator 方法对应的不是遍历器生成对象（即会返回一个遍历器对象），解释引擎将会报错。 调用 Iterator 的场合 解构赋值 123let set = new Set().add(&#x27;a&#x27;).add(&#x27;b&#x27;).add(&#x27;c&#x27;)let [x, y] = set // x = a, y = blet [first, ...rest] = set // first = &#x27;a&#x27;, rest = [&#x27;b&#x27;, &#x27;c&#x27;] 拓展运算符 1234var str = &#x27;hello&#x27;;[...str] // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]let arr = [&#x27;b&#x27;, &#x27;c&#x27;];[&#x27;a&#x27;, ...arr, &#x27;d&#x27;] // [&#x27;a&#x27;, b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] yield*yield*后面跟着是一个可遍历的结构，它会调用该结构的遍历器接口。 123456789101112let generator = function* () &#123; yield 1 yield* [2, 3, 4] yield 5&#125;var iterator = generator()iterator.next() // &#123; value : 1, done : false &#125;iterator.next() // &#123; value : 2, done : false &#125;iterator.next() // &#123; value : 3, done : false &#125;iterator.next() // &#123; value : 4, done : false &#125;iterator.next() // &#123; value : 5, done : false &#125;iterator.next() // &#123; value : undefined, done : true &#125; 字符串的 Iterator 接口覆盖原生的 Symbol.iterator 方法达到修改遍历器行为的目的。 1234567891011121314151617var str = new String(&#x27;hi&#x27;);[...str] // [&#x27;h&#x27;, &#x27;i&#x27;]str[Symbol.iterator] = function () &#123; return &#123; next: function () &#123; if (this._first) &#123; this._first = false return &#123; value: &#x27;bye&#x27;, done: false &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125;, _first: true, &#125;&#125;;[...str] // [&#x27;bye&#x27;]str //&#x27;hi&#x27; Iterator 接口与 Generator 函数Symbol.iterator 方法的最简单实现还是使用 Generator 函数。 1234567891011121314151617var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function* () &#123; yield 1 yield 2 yield 3&#125;;[...myIterable] // [1, 2, 3]//或下面的写法let obj = &#123; *[Symbol.iterator]() &#123; yield &#x27;hello&#x27; yield &#x27;world&#x27; &#125;,&#125;for (let x of obj) &#123; console.log(x)&#125; return()、throw()return 使用的场合是，如果 for…of 循环提前退出（error、continue、break)，会调用 return 方法。如果一个对象在完成遍历以前需要清理或释放资源，就可以部署 return 方法。 123456789101112131415function readLinesSync(file) &#123; return &#123; next() &#123; return &#123; done: false &#125; &#125;, return() &#123; file.close() return &#123; done: true &#125; &#125;, &#125;&#125;for (let line of readLinesSync(fileName)) &#123; console.log(line) break&#125; return 必须返回一个对象，这是 Generator 规定的 数组数组原生具备 Iterator 接口： 123456const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const obj = &#123;&#125;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr)for (let v of arr) console.log(v)for (let v of obj) console.log(v)//完全相同的结果 for…of 可以代替 forEach 方法，for…in 获取对象的键名，for…of 获取对象的键值： 123var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]for (let a in arr) console.log(a) // 0 1 2 3for (let a of arr) console.log(a) // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; for…of 只返回具有数字索引的属性： 1234let arr = [3, 4, 5]arr.foo = &#x27;fun&#x27;for (let i in arr) console.log(i) // 0 1 2 foofor (let i of arr) console.log(i) // 3 4 5 Set 和 Map 结构Set 和 Map 结构原生具有 Iterator 接口，可以直接使用 for…of。 123456789var engines = new Set([&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;])for (var e of engines) console.log(e) // aaa bbb cccvar es = new Map()es.set(&#x27;edition&#x27;, 6)es.set(&#x27;committee&#x27;, &#x27;TC39&#x27;)for (var [name, value] of es) console.log(name + &#x27; : &#x27; + value)// edition : 6// committee : TC39 其他方法 entries()返回一个遍历器对象，用于遍历[键名，键值]组成的数组 keys()返回一个遍历器对象，用于遍历所有键名 values()返回一个遍历器对象，用于遍历所有键值 类似数组对象用 Array.from()方法转为数组： 12let arrayLike = &#123; length: 2, 0: &#x27;a&#x27;, 1: &#x27;b&#x27; &#125;for (let x of Array.from(arrayLike)) console.log(x) // &#x27;a&#x27; &#x27;b&#x27; 普通对象for…in 仍可用于遍历键名，但是 for…of 不能使用，一种解决方法是使用 Object.keys()生成一个键名数组： 1for (var key of Object.keys(object)) console.log(key + &#x27;:&#x27; + object[key]) 另一个方法是使用 Generator 函数将对象重新包装： 12345678function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]] &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key + &#x27;-&gt;&#x27; + value)&#125; for…in 的不足： 数组的键名是数字，但是 for…in 循环是以字符串作为键名，’0’、’1’等 for…in 循环不仅会遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键 某些情况下，for…in 会以任意顺序遍历键名 Update on 6&#x2F;22&#x2F;2021Range123456789101112131415161718192021222324252627let range = &#123; from: 1, to: 5, [Symbol.iterator]() &#123; return &#123; current: this.from, last: this.to, next() &#123; if (this.current &lt;= this.last) &#123; return &#123; done: false, value: this.current++ &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125;, &#125; &#125;,&#125;for (let num of range) &#123; console.log(num)&#125;console.log(&#x27;second range&#x27;)for (let num of range) &#123; console.log(num)&#125; Another Range123456789101112131415161718192021222324let anotherRange = &#123; from: 1, to: 5, [Symbol.iterator]() &#123; this.current = this.from return this &#125;, next() &#123; if (this.current &lt;= this.to) &#123; return &#123; done: false, value: this.current++ &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125;,&#125;for (let num of anotherRange) &#123; console.log(num)&#125;console.log(&#x27;another range&#x27;)for (let num of anotherRange) &#123; console.log(num)&#125; Get Iterator12345678910let str = &#x27;Hello&#x27;let iterator = str[Symbol.iterator]()while (true) &#123; let result = iterator.next() if (result.done) break console.log(result)&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Promise","path":"/2018/08/31/Promise/","content":"Promise 的特点 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Fulfilled（已成功）、Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变就不会再变，任何时候得到的都是这个结果。Promise 对象的状态改变只有两个可能：从 Pending 变为 Fulfilled，从 Pending 变为 Rejected。只要这两种情况发生，这时就成为 resolve。就算改变已经发生，再对 Promise 对象添加回调函数，也会立即得到这个结果。与 Event 完全不同，Event 一旦错过再监听是得不到结果的。 基本用法123456789var promise = new Promise(function (resolve, reject) &#123; //some code if (/*异步操作成功*/) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;) resolve 函数的作用是，将 Promise 对象的状态从 Pending 变为 Resolved，在异步操作成功时调用，并将异步操作的结果作为参数传递出去。reject 函数的作用是，将 Promise 对象的状态从 Pending 变为 Rejected，将报出的错误传递出去。Promise 实例生成后，可以用 then 方法分别制定 Resolve 状态和 Rejected 状态的回调函数： 12345678promise.then( function (value) &#123; //success &#125;, function (error) &#123; //failure &#125;,) then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调是 Promise 对象的状态变为 Rejected 时调用。其中，第二个参数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &#x27;done&#x27;) &#125;)&#125;timeout(100).then((value) =&gt; &#123; console.log(value)&#125;)//&#x27;done&#x27; 过了 ms 后，Promise 实例的状态变为 Resolved，触发 then 方法绑定的回调函数。Promise 新建后就会立即执行： 123456789101112let promise = new Promise(function (resolve, reject) &#123; console.log(&#x27;Promise&#x27;) resolve()&#125;)promise.then(function () &#123; console.log(&#x27;Resolve&#x27;)&#125;)console.log(&#x27;hi&#x27;)//Promise//hi//Resolve then 方法指定的回调函数将在当前脚本所有同步任务执行完成后才会执行，所以 Resolve 最后输出。异步加载图片： 123456789101112function loadImageAsync(url) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image() image.onload = function () &#123; resolve(image) &#125; image.onerror = function () &#123; reject(new Error(&#x27;Could not load image at &#x27; + url)) &#125; image.src = url &#125;)&#125; 使用 Promise 实现 AJAX： 123456789101112131415161718192021222324252627282930var getJSON = function (url) &#123; var promise = new Promise(function (resolve, reject) &#123; var client = new XMLHttpRequest() client.open(&#x27;GET&#x27;, url) client.onreadystatechange = handler client.responseType = &#x27;json&#x27; client.setRequestHeader(&#x27;Accept&#x27;, &#x27;application/json&#x27;) client.send() function handler() &#123; if (this.readyState !== 4) &#123; return &#125; if (this.status === 200) &#123; resolve(this.response) &#125; else &#123; reject(new Error(this.statusText)) &#125; &#125; &#125;) return promise&#125;getJSON(&#x27;/posts.json&#x27;).then( function (json) &#123; console.log(&#x27;Contents: &#x27; + json) &#125;, function (error) &#123; console.error(&#x27;出错了&#x27;, error) &#125;,) 以 Promise 对象作为 resolve 的参数1234567var p1 = new Promise(function (resolve, reject) &#123; //...&#125;)var p2 = new Promise(function (resolve, reject) &#123; //... resolve(p1)&#125;) 此时 p1 的状态决定了 p2 的状态。如果 p1 的状态是 Pending，那么 p2 的回调就会等待 p1 的改变；如果 p1 的状态已经是 Resolved 或者 Rejected，那么 p2 的回调函数就会立即执行。 1234567var p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;fail&#x27;)), 3000)&#125;)var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2.then((result) =&gt; console.log(result)).catch((error) =&gt; console.log(error)) p1 三秒后变为 Rejected，p2 在一秒后变为 Resolved，由于 p2 返回的是另一个 Promise，所以 p2 的状态无效，由 p1 的状态决定 p2 的状态。后面的 then 语句都变成针对 p2 的，再过两秒，p1 变为 Rejected，触发 catch 指定的回调函数。调用 resolve 或 reject 并不会结束 Promise 函数的执行因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。所以最好在前面加上 return 语句。 Promise.prototype.catch()是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456789101112131415161718192021222324252627282930313233343536373839404142getJSON(&#x27;/posts.json&#x27;) .then(function (posts) &#123; //... &#125;) .catch(function (error) &#123; //处理getJSON和前一个回调函数运行时发生的错误 &#125;)p.then((val) =&gt; console.log(&#x27;fulfilled:&#x27;, val)).catch((err) =&gt; console.log(&#x27;rejected:&#x27;, err),)//等同于p.then((val) =&gt; console.log(&#x27;fulfilled:&#x27;, val)).then(null, (err) =&gt; console.log(&#x27;rejected&#x27;, err),)var promise = new Promise(function (resolve, reject) &#123; throw new Error(&#x27;test&#x27;)&#125;)promise.catch(function (error) &#123; console.log(error)&#125;)//写法一var promise = new Promise(function (resolve, reject) &#123; try &#123; throw new Error(&#x27;test&#x27;) &#125; catch (e) &#123; reject(e) &#125;&#125;)promise.catch(function (error) &#123; console.log(error)&#125;)//写法二var promise = new Promise(function (resolve, reject) &#123; reject(new Error(&#x27;test&#x27;))&#125;)promise.catch(function (error) &#123; console.log(error)&#125;) 比较可知 reject 方法的作用等同于抛出错误。如果 Promise 状态已经变成 Resolved，再抛出错误是无效的 1234567891011var promise = new Promise(function (resolve, reject) &#123; resolve(&#x27;ok&#x27;) throw new Error(&#x27;test&#x27;)&#125;)promise .then(function (value) &#123; console.log(value) &#125;) .catch(function (error) &#123; console.log(error) &#125;) //&#x27;ok&#x27; Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止。一般来说，应用 Promise 的 catch 方法。与传统的 try&#x2F;catch 不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，不会有任何反应。需要注意的是，catch 返回的还是一个 Promise 对象。 1234567891011121314var someAsyncThing = function () &#123; return new Promise(function (resolve, reject) &#123; resolve(x + 2) //ReferenceError &#125;)&#125;someAsyncThing() .catch(function (error) &#123; console.log(&#x27;error:&#x27;, error) &#125;) .then(function () &#123; console.log(&#x27;carry on&#x27;) &#125;)//Error: ReferenceErro x is not defined//carry on 如果没有报错，会跳过 catch 方法。catch 方法中还能抛出错误： 123456789101112131415161718var someAsyncThing = function () &#123; return new Promise(function (resolve, reject) &#123; resolve(x + 2) //ReferenceError &#125;)&#125;someAsyncThing() .then(function () &#123; return someOtherAsyncThing() &#125;) .catch(function (error) &#123; console.log(error) y + 2 //ReferenceError &#125;) .catch(function (error) &#123; console.log(&#x27;carry on&#x27;, error) &#125;)//x in not defined//carry on y is not defined Promise.all将多个 Promise 对象包装成一个新的实例。 1var p = Promise.all(p1, p2, p3) p 的状态由 p1、p2、p3 决定： 只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1、p2、p3 有一个被 Rejected，p 的状态就变为 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。 123456const databasePromise = connectDatabase()const booksPromise = databasePromise.then(findAllBooks)const userPromise = databasePromise.then(getCurrentUser)Promise.all([booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user),) 只有 booksPromise 和 userPromise 结果都返回，才会触发 pickTopRecommentations 回调函数。如果作为参数的 Promise 实例自身定义了 catch 方法，那么它被 rejected 时并不会触发 Promise.all 的 catch 方法 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;) .then((result) =&gt; result) .catch((e) =&gt; e)const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;test&#x27;)&#125;) .then((result) =&gt; result) .catch((e) =&gt; e)Promise.all([p1, p2]) .then((result) =&gt; console.log(result)) .catch((e) =&gt; console.log(e))//[&#x27;hello&#x27;, Error: test] 如果 p2 没有自己的 catch 方法，就会调用 Promise.all 的 catch 方法： 12345678910const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;).then((result) =&gt; result)const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;test&#x27;)&#125;).then((result) =&gt; result)Promise.all([p1, p2]) .then((result) =&gt; console.log(result)) .catch((e) =&gt; console.log(e))//Error: test Promise.race将多个 Promise 实例包装成一个新的实例。 1var p = Promise.race([p1, p2, p3]) 只要 p1、p2、p3 有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的实例的返回值就传给 p 的回调函数。 123456789const p = Promise.race([ fetch(&#x27;/resource-that-may-take-a-while&#x27;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000) &#125;),])p.then((response) =&gt; console.log(response))p.catch((error) =&gt; console.log(error))//五秒内fetch无法返回变量，p的状态就变为Rejected，从而触发catch方法的回调函数 Promise.resolve 参数是一个 Promise 实例，不做任何修改，返回这个实例 参数是一个 thenable 对象，将这个对象转为 Promise 对象，然后立即执行 thenable 对象的 then 方法 12345678910let thenable = &#123; then: function (resolve, reject) &#123; resolve(42) &#125;,&#125;let p1 = Promise.resolve(thenable)p1.then(function (value) &#123; console.log(value)&#125;)//42 参数根本不是具有 then 方法的对象或者不是对象，返回一个新的 Promise 对象，状态为 Resolved 12345var p = Promise.resolve(&#x27;hello&#x27;)p.then(function (s) &#123; console.log(s)&#125;)//&#x27;hello&#x27; 不带有任何参数，直接返回一个 Resolved 状态的对象 Promise.reject 返回一个状态为 Rejected 的 Promise 对象 立即 resolve 的 Promise 对象是在本轮事件循环结束时，而不是在下次事件循环开始时 done只要最后一个方法抛出错误，都有可能无法捕捉到，为此可以配置一个 done 方法。 1asyncFunc().then(f1).catch(r1).then(f2).done() 实现的代码如下： 1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected).catch(function (reason) &#123; setTimeout(() =&gt; &#123; throw reason &#125;, 0) //抛出一个全局错误 &#125;)&#125; finally与 done 最大的区别在于，接受一个普通的回调函数作为参数，该函数不管怎样都执行。 123456server .listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop) 实现代码如下： 12345678910Promise.prototype.finally = function (callback) &#123; let P = this.constructor return this.then( (value) =&gt; P.resolve(callback()).then(() =&gt; value), (reason) =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;), )&#125; eg: 加载图片 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image() image.onload = resolve image.onerror = reject image.src = path &#125;)&#125; Generator 函数与 Promise 结合使用 Generator 函数管理流程，遇到异步操作时通常返回一个 Promise 对象。 1234567891011121314151617181920212223242526272829function getFoo() &#123; return new Promise(function (resolve, reject) &#123; resolve(&#x27;foo&#x27;) &#125;)&#125;var g = function* () &#123; try &#123; var foo = yield getFoo() console.log(foo) &#125; catch (e) &#123; console.log(e) &#125;&#125;function run(generator) &#123; var it = generator() function go(result) &#123; if (result.done) return result.value return result.value.then( function (value) &#123; return go(it.next(value)) &#125;, function (error) &#123; return go(it.throw(error)) &#125;, ) &#125; go(it.next())&#125;run(g) // 用run处理Promise对象，并调用下一个next方法 Promise chaining1234567891011121314151617181920212223242526272829function loadJSON(url) &#123; return fetch(url).then((response) =&gt; response.json())&#125;function loadUser(name) &#123; return fetch(`https://api.github.com/users/$&#123;name&#125;`).then((response) =&gt; response.json(), )&#125;function showAvatar(user) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = document.createElement(&#x27;img&#x27;) img.src = user.avatar_url img.className = &#x27;example-img&#x27; document.body.append(img) setTimeout(() =&gt; &#123; img.remove() resolve(loadUser) // here can resolve another promise &#125;, 3000) &#125;)&#125;loadJSON(&#x27;test.json&#x27;) .then((user) =&gt; loadUser(user.name)) .then(showAvatar) .then((user) =&gt; console.log(`github user: $&#123;user&#125;`))// ... and so on","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Reflect","path":"/2018/08/31/Reflect/","content":"从 Reflect 对象上可以获得语言内部的方法 修改某些 Object 方法的返回结果，让其变得更合理。比如 Object.defineProperty 在无法定义属性时会抛出一个错误，而 Reflect.defineProperty 则会返回 false 让 Object 操作都变成函数行为。 只要是 Proxy 对象的方法，就能在 Reflect 对象上找到相应的方法，无论 Proxy 怎么修改默认行为，总可以在 Reflect 上获取默认行为 静态方法 Reflect.apply(target, thisArg, args)等同于 Function.prototype.apply.call(func, thisArg, args)，用于绑定 this 对象后执行给定函数。 Reflect.construct(target, args)等同于 new target(…args)，提供了一种不使用 new 来调用构造函数的方法：123456789 function Greeting(name) &#123; this.name = name; &#125;//new 的写法const instance = new Greeting(&#x27;张三&#x27;);//Reflect.construct 写法const instance = Reflect.construct(Greeting, [&#x27;张三&#x27;]); Reflect.get(target, name, receiver)查找并返回 target 的 name 属性，如果没有返回 undefined。123456789let obj = &#123;foo : 1,bar : 2,get baz() &#123;return this.foo + this.bar;&#125;&#125;Reflect.get(obj, &#x27;foo&#x27;); //1Reflect.get(obj, &#x27;baz&#x27;); //3 如果 name 属性部署了 getter，则 getter 的 this 绑定 receiver：123456789101112let obj = &#123;foo : 1,bar : 2,get gaz() &#123;return this.foo + this.bar;&#125;&#125;;let myobj = &#123;foo : 2,bar : 4,&#125;Reflect.get(obj, &#x27;gaz&#x27;, myobj); //myobj.foo + myobj.bar 6 如果第一个参数不是 object，会报错Reflect.set 会触发 Proxy.defineProperty 拦截：1234567891011121314151617let p = &#123;a : &#x27;a&#x27;&#125;;let handler = &#123;set(target, key, value, receiver) &#123;console.log(&#x27;set&#x27;);Reflect.set(target, key, value, receiver);&#125;,defineProperty(target, key, attribute) &#123;console.log(&#x27;defineProperty&#x27;);Reflect.defineProperty(target, key, attribute);&#125;&#125;;let obj = new Proxy(p, handler);obj.a = &#x27;A&#x27;;//set//defineProperty Reflect.set(target, name, value, receiver)设置 target 的 name 属性等于 value。123456789let obj = &#123;foo : 1,set bar(value) &#123;return this.foo = value;&#125;&#125;;obj.foo; //1Reflect.set(obj, &#x27;foo&#x27;, 2);obj.foo; //2 如果 name 属性设置了 setter，则 setter 的 this 绑定 receiver：1234567891011let obj = &#123;foo : 1,set bar(value) &#123;return this.foo = value;&#125;&#125;;let myobj = &#123;foo : 0&#125;;Reflect.set(obj, &#x27;bar&#x27;, 4, myobj);myobj.foo; //4 如果第一个参数不是 object，会报错 Reflect.defineProperty(target, name, descriptor)用来定义对象的属性。 Reflect.deleteProperty(target, name)等同于 delete obj[name]，用于删除对象的属性，返回一个布尔值，删除成功返回 true，否则返回 false。 Reflect.has(target, name)对应 name in target 中的 in 运算符，如果第一个参数不是对象，Reflect.has 和 in 都会报错。 Reflect.ownKeys(target)返回对象的所有属性，包括 Symbol 属性。 Reflect.isExtensible(target)返回一个布尔值，表示当前对象是否可拓展。 Reflect.preventExtensions(target)用于使一个对象变为不可拓展的，返回一个布尔值，代表是否成功。 Reflect.getOwnPropertyDescriptor(target, name)基本等同于 Object.getOwnPropertyDescriptor(target, propertyKey)，用于获得指定属性的描述对象。 Reflect.getPrototypeOf(target)用于读取对象的prop属性，对应 Object.getPrototypeOf(obj)。 Reflect.setPrototypeOf(target, prototype)用于设置对象的prop属性，返回第一个参数对象。 用 Proxy 实现观察者模式Observe mode 指的是函数自动观察数据对象的模式，一旦对象有变化，函数就会自动执行。思路：使用 observable 和 observe 这两个函数，observable 函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 1234567891011121314151617181920const queueObservers = new Set();const observe = fn =&gt; queueObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123; set &#125;); //拦截 setfunction set(target, key, value, receiver) &#123;const result = Reflect.set(target, key, value, receiver); //完成原始操作queueObservers.forEach(observer =&gt; observer());return result;&#125;const person = observable(&#123;name : &#x27;张三&#x27;,age : 20&#125;);function print() &#123;console.log(`$&#123;person.name&#125;， $&#123;person.age&#125;`);&#125;observe(print);person.name = &#x27;李四&#x27;; //李四，20","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Proxy","path":"/2018/08/20/Proxy/","content":"Proxy 用于修改某些操作的默认行为，等同与在语言层面做出修改，属于一种 meta programming。 1234567891011121314let obj = new Proxy(&#123;&#125;, &#123;get: function (target, key, receiver) &#123;console.log(`getting $&#123;key&#125;`);return Reflect.get(target, key, receiver);&#125;,set: function (target, key, receiver) &#123;console.log(`setting $&#123;key&#125;`);return Reflect.set(target, key, receiver);&#125;&#125;);obj.count = 1;//setting countobj.count;//getting count ES6 提供 Proxy 构造函数，用于生成 Proxy 实例。 1let proxy = new Proxy(target, handler); 将 Proxy 对象设置到 object.proxy 属性，从而可以在 object 对象上调用： 1let obj = &#123; proxy: new Proxy(target, handler) &#125;; Proxy 实例也可以作为其他对象的原型对象： 1234567let proxy = new Proxy(&#123;&#125;, &#123;get: function (target, handler) &#123;return 2;&#125;&#125;);let obj = Object.create(proxy);obj.time; //2 同一个 Proxy 可以设置多个拦截属性： 12345678910111213141516171819202122let handler = &#123;get: function (target, name) &#123;if (name === &#x27;prototype&#x27;) &#123;return Object.prototype;&#125;return &#x27;Hello, &#x27; + name;&#125;,apply: function (target, thisBinding, args) &#123;return args[0];&#125;,construct: function (target, args) &#123;return &#123; value: args[1] &#125;;&#125;&#125;;let fproxy = new Proxy(function (x, y) &#123;return x + y;&#125;, handler);fproxy(1, 2); //1new fproxy(1, 2); //2fproxy.prototype === Object.prototype; //truefproxy.foo; //&#x27;hello, foo&#x27; Proxy 方法 get(target, propKey, receiver)拦截对象的属性读取，如 proxy.foo 和 proxy[‘foo’]。最后一个参数是可选的。1234567891011121314let person = &#123;name : &#x27;张三&#x27;&#125;;let proxy = new Proxy(person, &#123;get : function (target, property) &#123;if (property in target) &#123;return target[property];&#125; else &#123;throw new ReferenceError(&#x27;Property \\&quot;&#x27; + property + &#x27;\\&quot; does not exist.&#x27;);&#125;&#125;&#125;);proxy.name; //张三proxy.age; //ReferenceError get 方法可以继承：12345678let proto = new Proxy(&#123;&#125;, &#123;get(target, propertyKey, receiver) &#123;console.log(&#x27;get &#x27; + propertyKey);return target[propertyKey];&#125;&#125;);let obj = Object.create(proto);obj.aaa; //get aaa 使用 get 实现负数索引：12345678910111213141516function createArray(...elements) &#123;let handler = &#123;get(target, propKey, receiver) &#123;let index = Number(propKey);if (index &lt; 0) &#123;propKey = String(target.length + index);&#125;return Reflect.get(target, propKey, receiver);&#125;&#125;;let target = [];target.push(...elements);return new Proxy(target, handler);&#125;let arr = createArray(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);arr[-1]; //&#x27;c&#x27; 将 get 转为执行某个函数，实现属性的链式操作：123456789101112131415161718192021var pipe = (function () &#123;return function (value) &#123;var funcStack = [];var oproxy = new Proxy(&#123;&#125;, &#123;get : function (pipeObject, fnName) &#123;if (fnName === &#x27;get&#x27;) &#123;return funcStack.reduce(function (val, fn) &#123; //reduce 接受一个函数作为累加器，从左到右缩减，最终计算为一个值return fn(val);&#125;, value);&#125;funcStack.push(window[fnName]);return oproxy;&#125;&#125;);return oproxy;&#125;&#125;());var double = n =&gt; n _ 2;var pow = n =&gt; n _ n;var reverseInt = n =&gt; n.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) | 0;pipe(3).double.pow.reverseInt.get; //63 set(target, propKey, value, receiver)拦截对象的属性设置，如 proxy.foo &#x3D; 1，返回一个布尔值。123456789101112131415161718let validator = &#123;set : function (obj, prop, value) &#123;if (prop === &#x27;age&#x27;) &#123;if (!Number.isInteger(value)) &#123;throw new TypeError(&#x27;The age is not an integer&#x27;);&#125;if (value &gt; 200) &#123;throw new RangeError(&#x27;The age seems invalid&#x27;);&#125;&#125;//age &lt; 200 直接保存obj[prop] = value;&#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age = 201; //RangeErrorperson.age = &#x27;tom&#x27;; //TypeError 给对象设置内部属性：1234567891011121314151617181920var handler = &#123;get(target, key) &#123;invariant(key, &#x27;get&#x27;);return target[key];&#125;,set(target, key, value) &#123;invariant(key, &#x27;set&#x27;);target[key] = value;return true;&#125;&#125;;function invariant(key, action) &#123;if (key[0] === &#x27;\\_&#x27;) &#123;throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);&#125;&#125;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.\\_temp; //Errorproxy.\\_temp = 2; //Error has(target, propKey)拦截 propKey in proxy 的操作，返回一个布尔值。has 拦截对 for…in 循环不生效 deleteProperty(target, propKey)拦截 delete proxy[propKey]的操作，返回一个布尔值。如果这个方法抛出错误或者返回 false，当前属性就不能被 delete 删除。1234567891011121314var handler = &#123;deleteProperty(target, key) &#123;invariant(key, &#x27;delete&#x27;);return true;&#125;&#125;;function invariant(key, action) &#123;if (key[0] === &#x27;\\_&#x27;) &#123;throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);&#125;&#125;var target = &#123; \\_temp : &#x27;test&#x27; &#125;;var proxy = new Proxy(target, handler);delete proxy.\\_temp; //Error ownKeys(target)拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回所有属性名，而Object.keys()返回结果仅包括目标对象和自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象或者 undefined。123456789101112var handler = &#123;getOwnPropertyDescriptor(target, key) &#123;if (key[0] === &#x27;\\_&#x27;) &#123;return;&#125;return Object.getOwnPropertyDescriptor(target, key);&#125;&#125;;var target = &#123; \\_foo : &#x27;foo&#x27;, bar : &#x27;bar&#x27; &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, &#x27;\\_foo&#x27;); //undefinedObject.getOwnPropertyDescriptor(proxy, &#x27;bar&#x27;); //&#123; value : &#x27;bar&#x27;, writable : true, enumerable : true, configurable : true &#125; defineProperty(target, propKey, propDesc)拦截 Objec.defineProperty:123456789var handler = &#123;defineProperty(target, key, descriptor) &#123;return false;&#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = &#x27;bar&#x27;;proxy.foo; //undefined preventExtensions(target)拦截 Object.preventExtensions，必须返回布尔值，否则会强制转换为布尔值。 getPrototypeOf(target)拦截获取对象原型 isExtensible(target)拦截 Objec.isExtensible 操作 setPrototypeOf(target, proto)拦截 Object.setPrototypeOf 方法 apply(target, object, args)拦截函数的调用、call 和 apply 操作，12345678var target = function () &#123; return &#x27;test&#x27;; &#125;var handler = &#123;apply : function () &#123;return &#x27;apply&#x27;;&#125;&#125;;let p = new Proxy(target, handler);p(); //apply construct(target, args)拦截 new 命令，返回的必须是对象，否则会报错：123456789var p = new Proxy(function () &#123;&#125;, &#123;construct : function (target, args) &#123;console.log(&#x27;called &#x27; + args.join(&#x27;,&#x27;));return &#123; value : args[0] \\* 10 &#125;;&#125;&#125;);(new p(1)).value; //called 1//10 Proxy.revocable()返回一个可取消的 Proxy 实例： 12345678let target = &#123;&#125;;let handler = &#123;&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo; //123revoke();proxy.foo; //TypeError 执行 revoke 函数后再访问 Proxy 实例，就会抛出一个错误。 this 问题在 Proxy 代理下，目标对象内部的 this 关键字会指向 Proxy 代理： 12345678910111213const \\_name = new WeakMap();class Person &#123;constructor(name) &#123;\\_name.set(this, name);&#125;get(name) &#123;return \\_name.get(this);&#125;&#125;const jane = new Person(&#x27;Jane&#x27;);jane.name; //&#x27;Jane&#x27;const proxy = new Proxy(jane, &#123;&#125;);proxy.name; //undefined 此外，有些原生对象内部属性只有通过正确的 this 才能获取，所以 Proxy 也无法代理这些原生对象的属性 1234const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate();//TypeError: This is not a Date Object 这时，this 绑定原始对象就可以解决 1234567891011const target = new Date(&#x27;2018-8-31&#x27;);const handler = &#123;get(target, prop) &#123;if (prop === &#x27;getDate&#x27;) &#123;return target.getDate.bind(target);&#125;return Reflect.get(target, prop);&#125;&#125;;const proxy = new Proxy(target, handler);proxy.getDate(); //31 观察者模式Observer mode：函数自动观察对象，一旦数据有变化，函数就会自动执行。 123456789101112131415161718192021222324252627282930313233let hero = &#123; // data object name: &#x27;test&#x27;, hp: 100, sp: 100, equipment: [&#x27;weapon&#x27;],&#125;const observableArray = new Set()const handler = &#123; set: (target, key, value, receiver) =&gt; &#123; const result = Reflect.set(target, key, value, receiver) observableArray.forEach((item) =&gt; item(key)) return result &#125;,&#125;/** * Create a Proxy object * @param &#123;Object&#125; obj the data object * @returns &#123;Object&#125; Proxy */const creatProxy = (obj) =&gt; new Proxy(obj, handler)const heroProxy = creatProxy(hero) // the data ProxyobservableArray.add((prop) =&gt; &#123; // callback function console.log(`new $&#123;prop&#125;: $&#123;heroProxy[prop]&#125;`) // log value of the prop handled&#125;)heroProxy.name = &#x27;change name&#x27; // new name: change nameheroProxy.sp = 12 // new sp: 12","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Map","path":"/2018/08/20/Map/","content":"ES6 提供了 Map 数据结构，它类似对象，也是键值对的集合，但是‘键’的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map 结构是一种更完善的 Hash 结构实现。如果需要‘键值对’的数据结构，Map 比 Object 更合适。 1234let m = new Map();const o = &#123; p : &#x27;hello&#x27; &#125;;m.set(o, &#x27;content&#x27;);m.get(o); //&#x27;content&#x27; Map 也可以接受一个数组作为参数，该数组的成员是一个表示键值对的数组： 12345678const map = new Map([[&#x27;name&#x27;, &#x27;张三&#x27;],[&#x27;title&#x27;, &#x27;test&#x27;]]);map.size; //2map.has(&#x27;name&#x27;); //truemap.get(&#x27;name&#x27;); //&#x27;张三&#x27; Map 构造函数接受数组作为参数，实际上执行的是下面的算法： 12345678const item = [[&#x27;name&#x27;, &#x27;张三&#x27;],[&#x27;title&#x27;, &#x27;test&#x27;]];const map = new Map();item.forEach(([key, valule]) =&gt; map.set(key, value)); 同名问题Map 的键实际上是和内存地址绑定的，只要内存地址不一样，就视为两个键。如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 就视其为一个键，包括-0 和 0。另外，虽然 NaN 不严格等于自身，但 Map 将其视为同一个键。 实例的属性和操作方法 size 属性size 属性返回 Map 结构的成员总数。 set(key, value)set 方法设置 key 所对应的键值，返回整个 Map 结构。如果 key 已经有值，则键值更新，否则新生成键值。 get(key)get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。 has(key)has 方法返回一个布尔值，表示某个键是否在 Map 数据结构中。 delete(key)delete 方法删除某个键，返回 true。如果删除失败，返回 false。 clear()clear 方法清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历 Map 的所有成员 Map 的遍历顺序就是插入顺序 Map 与其他数据结构相互转换 Map 转为数组12const myMap = new Map().set(true, 1).set(false, 2).set(&#123; foo: 1 &#125;, [&#x27;abc&#x27;]);[...myMap]; //[[true, 1], [false, 2], [&#123;foo:1&#125;, [&#x27;abc&#x27;]]] 数组转为 Map1234new Map([[true, 1],[&#123; foo : 3 &#125;, [&#x27;abc&#x27;]]]) Map 转为对象如果 Map 的所有键都是字符串，则可以转为对象。1234567function strMapToObj(strMap) &#123;let obj = Object.create(null);for (let [k, v] of strMap) &#123;obj[k] = v;&#125;return obj;&#125; 对象转为 Map1234567function objToStrMap(obj) &#123;let strMap = new Map();for (let k of Object.keys(obj)) &#123;strMap.set(k. obj[k]);&#125;return strMap;&#125; Map 转为 JSON Map 的键名都是字符串：123function strMapToJson(strMap) &#123;return JSON.stringify(strMapToObj(strMap));&#125; 键名有非字符串123function mapToArrayJson(map) &#123;return JSON.stringify([...map]);&#125; JSON 转为 Map 正常情况下所有键名都是字符串123function jsonToStrMap(jsonStr) &#123;return objToStrMap(JSON.parse(jsonStr));&#125; JSON 就是一个数组的情况123function jsonToMap(jsonStr) &#123;return new Map(JSON.parse(jsonStr));&#125; WeakMap 只接受对象作为键名（null 除外） WeakMap 中的对象都是弱引用，如果其他对象都不再引用该对象，那么 GC 会自动回收该对象所占的内存，不考虑该对象是否在 WeakMap 中 没有 size 属性，没有 clear 方法 WeakMap 的专用场景就是它的键所对应的对象可能会在将来消失的场景，有助于防止内存泄露","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Set","path":"/2018/08/18/Set/","content":"基本用法Set 类似于数组，但是成员的值都是唯一的，没有重复。Set 本身是一个构造函数。 1234567891011const set = new Set();[1, 2, 3, 4].forEach(x =&gt; set.add(x));for (let value of set) &#123;console.log(value); //1, 2, 3, 4&#125;const set = new Set([1, 2, 3, 4]);[...set]; //[1, 2, 3, 4]//数组除重[...new Set(array)] 在 Set 内部，NaN 是相等的，两个对象总是不相等的。 12345678let set = new Set();let a = NaN;let b = NaN;set.add(a).add(b);set.size; //1set.add(&#123;&#125;).add(&#123;&#125;);set.size; //3 Set 实例的属性和方法Set 结构的实例有以下属性： Set.prototype.constructor：构造函数，默认是 Set 函数 Set.prototype.size：返回 Set 成员的总数 Set 实例的方法： add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回布尔值表示是否删除成功 has(value)：返回一个布尔值，表示参数是否为 Set 的成员 clear()：清除所有成员，没有返回值 Array.from 方法可以将 Set 转为数组： 1234567const item = new Set([1, 2, 3, 4]);const array = Array.from(item);//去重function dedupe(array) &#123;return Array.from(new Set(array));&#125; 遍历操作 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Set 的遍历顺序就是插入顺序由于 Set 结构没有键名，所以 values 和 keys 方法的行为完全一致。 WeakSet 成员只能是对象，而不能是其他类型的值 WeakSet 中的对象都是弱引用，如果其他对象都不再引用该对象，那么 GC 会自动回收该对象所占的内存，不考虑该对象是否在 WeakSet 中 没有 size 属性，不可遍历","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Symbol","path":"/2018/08/17/Symbol/","content":"ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。Symbol 值通过 Symbol 函数生成，也就是说，对象的属性名现在可以有两种类型：一种是字符串，另一种就是 Symbol 类型。只要属性名属于 Symbol 类型，就是独一无二的，可以保证不会与其他属性名冲突。 12let s = Symbol();typeof s; //symbol Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在 console 显示。 12let s = Symbol(&#x27;str&#x27;);s.toString(); //&#x27;Symbol(str)&#x27; 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，再生成 Symbol 值 1234567const obj = &#123;toString() &#123;return &#x27;test&#x27;;&#125;&#125;;const s = Symbol(obj);s.toString(); //&#x27;Symbol(test)&#x27; Symbol 函数只表示对当前 Symbol 值的描述，因此相同的 Symbol 函数的返回值是不相等的 123let s1 = Symbol();let s2 = Symbol();s1 === s2; //false 作为属性名的 SymbolSymbol 值可以作为标识符用于对象的属性名，保证不会出现同名的属性，还能防止某一个键被不小心覆盖。 1234567891011121314let symbol = Symbol();//写法一let a = &#123;&#125;;a[symbol] = &#x27;test&#x27;;//写法二let a = &#123;[symbol]: &#x27;test&#x27;&#125;//写法三let a = &#123;&#125;;Object.defineProperty(a, symbol, &#123; value : &#x27;test&#x27; &#125;); 实例：消除代码中的字符串 12345678910111213141516171819202122function getArea(shape, options) &#123;let area = 0;switch (shape) &#123;case &#x27;Triangle&#x27;:area = 0.5 _ options.width _ options.height;break;&#125;return area;&#125;//转变后const shaptType = &#123;triangle: Symbol();&#125;;function getArea(shape, options) &#123;let area = 0;switch (shape) &#123;case shaptType.triangle:area = 0.5 _ options.width _ options.height;break;&#125;return area;&#125; 属性名的遍历Symbol 属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyName()返回。有一个 Object.getOwnPropertySymbols 方法可以获取指定对象的所有 Symbol 属性。 123456let obj = &#123;&#125;;let a = Symbol(&#x27;hello&#x27;);let b = Symbol(&#x27;world&#x27;);obj[a] = &#x27;a&#x27;;obj[b] = &#x27;b&#x27;;Object.getOwnPropertySymbols(obj); //[Symbol(hello), Symbol(world)] Symbol.for()、Symbol.keyFor()Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值，如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值。 123let str1 = Symbol.for(&#x27;test&#x27;);let str2 = Symbol.for(&#x27;test&#x27;);str1 === str2; //true Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key： 12345let s1 = Symbol.for(&#x27;foo&#x27;);Symbol.keyFor(s1); //&#x27;foo&#x27;let s2 = Symbol(&#x27;foo&#x27;);Symbol.keyFor(s2); //undefined Symbol.for 为 Symbol 登记的名字是全局环境的，可以在不同的 iframe 或 serviceWorker 中取到同一个值 内置的 Symbol 值 Symbol.hasInstancefoo instanceof Foo 实际在内部调用的是 Foo[Symbol.hasInstance](foo)： 1234567891011121314 class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125; &#125; [1, 2, 3] instanceof new MyClass(); //trueclass Even &#123;static [Symbol.hasInstance](obj) &#123;return Number(obj) % 2 === 0;&#125;&#125;1 instanceof Even; //false2 instanceof Even; //true Symbol.isConcatSpreadable等于一个布尔值，表示该对象使用 Array.prototype.concat()时是否可以展开： 1234567 let arr1 = [&#x27;a&#x27;, &#x27;b&#x27;]; [1, 2].concat(arr1, &#x27;c&#x27;); //[1, 2, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] arr1[Symbol.isConcatSpreadable]; //undefinedlet arr2 = [&#x27;a&#x27;, &#x27;b&#x27;];arr2[Symbol.isConcatSpreadable] = false;[1, 2].concat(arr2, &#x27;c&#x27;); //[1, 2, [&#x27;a&#x27;, &#x27;b&#x27;], &#x27;c&#x27;] 类似数组的对象也可以展开，默认值为 false，必须手动打开： 1234let obj = &#123; length : 2, 0 : &#x27;c&#x27;, 1 : &#x27;d&#x27; &#125;;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj); //[&#x27;a&#x27;, &#x27;b&#x27;, obj]obj[Symbol.isConcatSpreadable] = true;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj); //[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 对一个类而言，Symbol.isConcatSprealable 属性必须写成实例属性： 123456class myClass extends Array &#123;constructor(args) &#123;super(args);this[Symbol.isConcatSpreadable] = true;&#125;&#125; Symbol.species对象的 Symbol.species 属性指向当前对象的构造函数，创造实例时会默认调用这个方法。 123456789101112 class myClass extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125; &#125; let a = new myClass(1, 2, 3); let mapped = a.map(x =&gt; x \\* x); a instanceof Array; //true mapped instanceof Array; //true a instanceof myClass; //true mapped instanceof myClass; //false//默认值等同于下面的写法static get [Symbol.species]() &#123; return this; &#125; Symbol.match对象的 Symbol.match 属性指向一个函数，当执行 str.match(myObject)时，如果该属性存在，会调用它的返回值： 12345678910 String.prototype.match(regexp); //等同于 regexp[Symbol.match](this);class myMatcher &#123;[Symbol.match](string) &#123;return &#x27;hello world&#x27;.indexOf(string);&#125;&#125;e.match(new myMatcher()); //1 Symbol.replace对象的 Symbol.replace 属性指向一个方法，当对象被 String.prototype.replace 方法调用时会返回该方法的返回值： 123String.prototype.replace(searchValue, replaceValue);//等同于searchValue[Symbol.replace](this, replaceValue); Symbol.replace 方法会收到两个参数，一个是 replace 方法正在作用的对象，第二个是替换后的值： 123const x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);&#x27;hello&#x27;.replace(x, &#x27;world&#x27;); //[&#x27;hello&#x27;, &#x27;world&#x27;] Symbol.search对象的 Symbol.search 属性指向一个方法，当对象被 String.prototype.search 方法调用时会返回该方法的返回值： 12345678910111213 String.prototype.search(regexp); //等同于 regexp[Symbol.search](this);class mySearch &#123;constructor(value) &#123;this.value = value;&#125;[Symbol.search](string) &#123;return string.indexOf(this.value);&#125;&#125;&#x27;foobar&#x27;.search(new mySearch(&#x27;foo&#x27;)); //3 Symbol.split对象的 Symbol.split 属性指向一个方法，当对象被 String.prototype.split 方法调用时会返回该方法的返回值： 123String.prototype.split(separator, limit);//等同于separator[Symbol.split](this, limit); 重定义 split 方法的行为： 12345678910111213141516class mySplit &#123;constructor(value) &#123;this.value = value;&#125;[Symbol.split](string) &#123;let index = string.indexOf(this.value);if (index === -1) return string;return [string.substr(0, index),string.substr(index + this.value.length);];&#125;&#125;&#x27;foobar&#x27;.split(new mySplit(&#x27;foo&#x27;)); //[&#x27;&#x27;, &#x27;bar&#x27;]&#x27;foobar&#x27;.split(new mySplit(&#x27;bar&#x27;)); //[&#x27;foo&#x27;, &#x27;&#x27;]&#x27;foobar&#x27;.split(new mySplit(&#x27;1&#x27;)); //&#x27;foobar&#x27; Symbol.iterator对象的 Symbol.iterator 属性指向该对象的默认遍历器方法： 1234567891011121314151617181920212223 let myIterable = &#123;&#125;; myIterable[Symbol.iterator] = function\\* () &#123; yield 1; yield 2; yield 3; &#125; [...myIterable]; //[1, 2, 3]class Collection &#123; \\*[Symbol.iterator]() &#123;let i = 0;while (this[i] !== undefined) &#123;yield this[i];i++;&#125;&#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for (let value of myCollection) &#123;console.log(value); //1, 2&#125; Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"拖放事件","path":"/2018/08/15/拖放事件/","content":"拖拽元素事件： dragstart：拖拽前触发 drag：拖拽前到拖拽结束之间，连续触发 dragend：拖拽结束触发 1234567891011121314151617181920212223&lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let aLi = document.querySelectorAll(&#x27;li&#x27;); for (let li of aLi) &#123; let count = 0; li.ondragstart = function() &#123; this.style.backgroundColor = &#x27;red&#x27;; &#125;; li.ondrag = function () &#123; console.log(count++); //连续触发 &#125; li.ondragend = function() &#123; this.style.backgroundColor = &#x27;&#x27;; &#125; &#125;&lt;/script&gt; 目标元素事件： dragenter：进入目标元素触发，相当于 mouseover dragover：进入目标到离开目标之间，连续触发 dragleave：离开目标元素触发，相当于 mouseout drop：在目标元素上释放鼠标触发 123456789101112131415161718192021&lt;div id=&quot;div1&quot; style=&quot;width:50px;height:50px;background:yellow&quot;&gt;&lt;/div&gt;&lt;script&gt; let oDiv = document.querySelector(&#x27;#div1&#x27;); oDiv.ondragenter = function () &#123; this.style.backgroundColor = &#x27;blue&#x27;; &#125;; oDiv.ondragover = function (ev) &#123; console.log(&#x27;test&#x27;); //连续触发 //要想触发drop事件，就必须在dragover中阻止默认事件 ev.preventDefault(); //阻止默认事件 &#125; oDiv.ondragleave = function () &#123; this.style.backgroundColor = &#x27;yellow&#x27;; &#125;; oDiv.ondrop = function () &#123; console.log(&#x27;drop&#x27;); &#125;&lt;/script&gt; dataTransfer 对象 setData()：设置数据 key 和 value 值(必须是 string) getDate()；获取数据，根据 key 值获取 value 123456789101112131415161718192021222324252627&lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;div1&quot; style=&quot;width:50px;height:50px;background:yellow&quot;&gt;&lt;/div&gt;&lt;script&gt; let oUl = document.querySelector(&#x27;ul&#x27;); let aLi = oUl.querySelectorAll(&#x27;li&#x27;); let oDiv = document.querySelector(&#x27;#div1&#x27;); for (let i = 0, length = aLi.length; i &lt; length; i++) &#123; aLi[i].index = i; aLi[i].ondragstart = function (ev) &#123; ev.dataTransfer.setData(&#x27;index&#x27;, this.index); &#125;; &#125; oDiv.ondrop = function (ev) &#123; oUl.removeChild(aLi[ev.dataTransfer.getData(&#x27;index&#x27;)]); for (let i = 0, length = aLi.length; i &lt; length; i++) &#123; //重新赋索引值 aLi[i].index = i; &#125; &#125;&lt;/script&gt; effectAllowed：设置光标样式(none, copy, copyLink, copyMove, link, linkMove, move all, uninitalized) setDragImage：参数为指定的元素、x 坐标值、坐标值 files：获取外部拖拽文件，返回一个 fileList 列表，fileList 下 type 属性返回文件类型 FileReaderFileReader 用于读取文件信息 readAsDataURL：参数为要读取的文件对象，将文件读取为 DataUrl onload：当读取文件完成时触发此事件，通过 this.result 获取读取文件的数据，如果是图片，返回 base64 格式的图片数据","tags":["整理","学习"],"categories":["HTML5"]},{"title":"data自定义数据","path":"/2018/08/15/data自定义数据/","content":"data 自定义数据在 query、mobile 常用。 123456789&lt;div id=&quot;div1&quot; data-test=&quot;hello&quot; data-test-last=&quot;world&quot;&gt;&lt;/div&gt;&lt;script&gt; let oDiv = document.getElementById(&#x27;div1&#x27;); oDiv.dataset.test; //&#x27;hello&#x27; oDiv.dataset.testLast; //&#x27;world&#x27;&lt;/script&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"JSON新方法","path":"/2018/08/15/JSON新方法/","content":"eval()eval 可以解析任何字符串变成 JS： 123var str = &quot;function testFunction() &#123;console.log(&#x27;test&#x27;);&#125;&quot;eval(str)testFunction() //&#x27;test&#x27; JSON.parse()JSON.parse 只能解析 JSON 形式的字符串变成 JS，安全性比 eval 高一些。字符串中的属性要严格加上引号 123let str = &#x27;&#123; &quot;name&quot; : &quot;hello&quot; &#125;&#x27;let json = JSON.parse(str)json.name //&#x27;hello&#x27; JSON.stringify()JSON.stringify 将 JSON 转换成字符串： 12345let json = &#123; name: &#x27;hello&#x27;,&#125;let str = JSON.stringify(json)str //&#123;&quot;name&quot;:&quot;hello&quot;&#125; 复制对象出现的问题由于&#x3D;赋值，会有引用的问题，新对象属性改变可能会影响到源对象： 123456let a = &#123; name: &#x27;hello&#x27;,&#125;let b = ab.name = &#x27;hi&#x27;a.name //&#x27;hi&#x27; 可以用 JSON 的新方法解决： 123456let a = &#123; name: &#x27;hello&#x27;,&#125;let b = JSON.parse(JSON.stringify(a))b.name = &#x27;ni&#x27;a.name //&#x27;hello&#x27; JS 历史管理触发历史管理的方法： 通过跳转页面 hash pushState Update at 2021&#x2F;6&#x2F;24123456789101112131415161718192021222324252627let room = &#123; number: 23 &#125;let meetup = &#123; title: &#x27;Conference&#x27;, participants: [&#123; name: &#x27;John&#x27; &#125;, &#123; name: &#x27;Alice&#x27; &#125;], place: room,&#125;room.occupiedBy = meetup // circular referenceconsole.log( JSON.stringify( meetup, (key, value) =&gt; &#123; return key === &#x27;occupiedBy&#x27; ? undefined : value &#125;, 2, ),)let toJson = &#123; age: 32, toJSON() &#123; return this.age &#125;,&#125;console.log(JSON.stringify(toJson))","tags":["整理","学习"],"categories":["HTML5"]},{"title":"新的选择器","path":"/2018/08/15/新的选择器/","content":"querySelector()querySelector 只能选择一组中的第一个元素： 12345678&lt;div class=&quot;test&quot;&gt;div1&lt;/div&gt;&lt;div class=&quot;test&quot;&gt; div2&lt;/div&gt;&lt;script&gt; document.querySelector(&#x27;.test&#x27;).style.color = &#x27;red&#x27;; //只有第一个会变红&lt;/script&gt; querySelectorAll()querySelectorAll 获取一组元素： 1234567891011&lt;div class=&quot;test&quot;&gt;div1&lt;/div&gt;&lt;div class=&quot;test&quot;&gt;div2&lt;/div&gt;&lt;script&gt; let aDiv = document.querySelectorAll(&#x27;.test&#x27;); for (let div of aDiv) &#123; div.style.color = &#x27;red&#x27;; &#125;&lt;/script&gt; getElementsByClassName()getElementsByClassName 通过 class name 选择元素： 1234567891011&lt;div class=&quot;test&quot;&gt;div1&lt;/div&gt;&lt;div class=&quot;test&quot;&gt;div2&lt;/div&gt;&lt;script&gt; let aDiv = document.getElementsByClassName(&#x27;test&#x27;); for (let div of aDiv) &#123; div.style.color = &#x27;red&#x27; &#125;&lt;/script&gt; 获取 classList 属性1234567891011&lt;div id=&quot;div1&quot; class=&quot;box1 box2 box3&quot;&gt;&lt;/div&gt;&lt;script&gt; let oDiv = document.getElementById(&#x27;div1&#x27;); oDiv.classList; //[box1, box2, box3] oDiv.classList.add(&#x27;box4&#x27;); //添加className oDiv.classList.remove(&#x27;box2&#x27;); //删除className oDiv.classList.toggle(&#x27;box4&#x27;); //如果有box4，则删除；反之，则添加box4&lt;/script&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5表单验证反馈","path":"/2018/08/14/HTML5表单验证反馈/","content":"validity 对象通过 validity 对象，通过下面的 valid 可以查看验证是否通过，如果八种验证都通过返回 true，有一种失败则返回 false oText.addEventListener(‘invalid’, fn, false); ev.preventDefault() valueMissing: 输入值为空时 typeMismatch: 控件值与预期类型不匹配 patterMismatch: 输入值不满足 pattern 正则 tooLong: 超过 maxLength 最大限制 rangeUnderflow: 验证的 range 最小值 rangeOverflow: 验证的 range 最大值 setMismatch: 验证 range 的当前值是否符合 min、max、step 的规则 customError: 不符合自定义验证–setCustomValidity()设置自定义验证 1234567891011121314&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;text&quot; required /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;script&gt; let oText = document.getElementById(&#x27;text&#x27;) oText.addEventListener(&#x27;invalid&#x27;, fn, false) function fn() &#123; console.log(this.validity) console.log(this.validity.valid) &#125;&lt;/script&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5新标签(三)","path":"/2018/08/14/HTML5新标签-三/","content":"123456789101112131415161718192021222324&lt;form action=&quot;&quot;&gt; &lt;!--placeholder: 输入框提示信息--&gt; &lt;!--autocomplete: 自动保存用户输入过的值，默认为on--&gt; &lt;!--pattern: 正则验证--&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入6-8个数字&quot; pattern=&quot;\\d&#123;6,8&#125;&quot; name=&quot;user&quot; autocomplete=&quot;off&quot; id=&quot;&quot; /&gt; &lt;!--formaction: 定义提交地址--&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; formaction=&quot;http://www.baidu.com&quot; /&gt;&lt;/form&gt;&lt;form action=&quot;&quot;&gt; &lt;!--autofocus: 自动焦点--&gt; &lt;!--required: 必填项--&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; autofocus required /&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; required /&gt;&lt;/form&gt;&lt;!--datalist选项列表，与input元素配合使用，定义input的可能值--&gt;&lt;input type=&quot;text&quot; list=&quot;varList&quot; /&gt;&lt;datalist id=&quot;varList&quot;&gt; &lt;option value=&quot;javascript&quot;&gt;javascript&lt;/option&gt; &lt;option value=&quot;html&quot;&gt;html&lt;/option&gt; &lt;option value=&quot;css&quot;&gt;css&lt;/option&gt;&lt;/datalist&gt; JS延迟加载 12345678910&lt;!--会在window.onload之前加载--&gt;&lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;&lt;!--异步加载--&gt;&lt;script src=&quot;a.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;&lt;script src=&quot;c.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt; contextmenu捕获右键菜单事件： 12345678910111213141516171819202122232425&lt;ul id=&quot;myMenu&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var menu = document.querySelector(&#x27;#myMenu&#x27;) document.addEventListener( &#x27;contextmenu&#x27;, (event) =&gt; &#123; event.preventDefault() menu.style.left = event.clientX + &#x27;px&#x27; menu.style.top = event.clientY + &#x27;px&#x27; menu.style.visibility = &#x27;visible&#x27; &#125;, false, ) document.addEventListener( &#x27;click&#x27;, (event) =&gt; &#123; menu.style.visibility = &#x27;hidden&#x27; &#125;, false, )&lt;/script&gt; DOMContentLoaded当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。 在使用 DOMContentLoaded 更加合适的情况下使用 load 是一个令人难以置信的流行的错误，所以要谨慎。注意：DOMContentLoaded 事件必须等待其所属 script 之前的样式表加载解析完成才会触发。load 是在所有资源加载完成后才触发。 readystatechange当文档的 readyState 属性发生改变，readystatechange 事件会被触发。 123456789document.readyState === &#x27;complete&#x27;// true// 替代 DOMContentLoadeddocument.onreadystatechange = function () &#123; if (document.readyState === &#x27;interactive&#x27;) &#123; initApplication() &#125;&#125; dragable全局属性 draggable 是一个枚举类型的属性，用于标识元素是否允许使用 拖放操作 API 拖动。它的取值如下： true，表示元素可以被拖动 false，表示元素不可以被拖动 如果该属性没有设值，则默认值 为 auto ，表示使用浏览器定义的默认行为。这个属性是枚举类型，而不是 Boolean默认情况下，只有已选中的文本、图片、链接可以拖动。对其它的元素来说，必须按拖动机制的顺序设置 ondragstart 事件才能正常工作: 123456&lt;div draggable=&quot;true&quot; ondragstart=&quot;event.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;This text may be dragged&#x27;)&quot;&gt; This text &lt;strong&gt;may&lt;/strong&gt; be dragged.&lt;/div&gt; Drag Data每一个 drag events 都有一个 dataTransfer 属性，用于保存 drag data，dataTransfer 是一个 DataTransfer 对象。使用 setData(type, value)来设置值。例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;style&gt; .container &#123; display: flex; flex-direction: row; &#125; #draggable &#123; width: 100px; height: 100px; background: white; justify-content: center; line-height: 100px; display: flex; &#125; .dragger-container &#123; margin: 0 2px; width: 100px; height: 100px; background-color: gray; padding: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dragger-container&quot;&gt; &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt;Drag me&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;dragger-container&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dragger-container&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dragger-container&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; let dragged document.addEventListener( &#x27;dragstart&#x27;, (event) =&gt; &#123; dragged = event.target &#125;, false, ) document.addEventListener( &#x27;dragover&#x27;, (event) =&gt; &#123; event.preventDefault() &#125;, false, ) document.addEventListener( &#x27;drop&#x27;, (event) =&gt; &#123; event.preventDefault() if (event.target.className == &#x27;dragger-container&#x27;) &#123; dragged.parentNode.removeChild(dragged) event.target.appendChild(dragged) &#125; &#125;, false, ) &#125;&lt;/script&gt; storage sessionStorage: 关闭页面时会清空 localStorage: 关闭页面时不会清空 两者 API 一致。 requestAnimationFrame(callback)表示在重绘前执行指定的回调函数，一个栗子： 12345&lt;div id=&quot;root&quot; style=&quot;width: 50px; height: 50px; background-color: red; position: relative;&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617let root = document.querySelector(&#x27;#root&#x27;)let flag = truelet left = 0requestAnimFrame = (() =&gt; requestAnimationFrame || webkitRequestAnimationFrame || mozRequestAnimationFrame || ((callback) =&gt; &#123; setTimeout(callback, 1000 / 60) &#125;))();(function _animation() &#123; left == 0 ? (flag = true) : left == 100 ? (flag = false) : &#x27;&#x27; flag ? (root.style.left = `$&#123;left++&#125;px`) : (root.style.left = `$&#123;left--&#125;px`) requestAnimFrame(_animation)&#125;)()","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5新标签(二)","path":"/2018/08/14/HTML5新标签-二/","content":"12345678910111213141516171819202122232425&lt;!--新的输入控件--&gt;&lt;!--email: 电子邮箱文本框，当输入的不是邮箱的时候，验证通不过。移动端的键盘会有变化--&gt;&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;!--tel: 电话号码--&gt;&lt;input type=&quot;tel&quot; name=&quot;&quot; id=&quot;&quot; /&gt;&lt;!--url: 网页的url--&gt;&lt;!--search: 搜索引擎，chrom下会多个关闭按钮--&gt;&lt;!--number: 只能输入数字--&gt;&lt;!--color: 颜色选择器--&gt;&lt;!--datetime: 显示日期--&gt;&lt;!--datetime-local: 显示完整日期，不含时区--&gt;&lt;!--time: 显示时间，不含时区--&gt;&lt;!--date: 显示日期--&gt;&lt;!--week: 显示周--&gt;&lt;!--month: 显示月--&gt;&lt;!--特定范围内的数值选择器 max、min、step、value--&gt;&lt;input type=&quot;range&quot; step=&quot;2&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;2&quot; name=&quot;&quot; id=&quot;&quot; /&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5新标签(一)","path":"/2018/08/14/HTML5新标签-一/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!--语义化标签--&gt;&lt;header&gt;页面的头部&lt;/header&gt;&lt;hgroup&gt; &lt;h1&gt;Test&lt;/h1&gt; &lt;h2&gt;test&lt;/h2&gt;&lt;/hgroup&gt;&lt;footer&gt;页面的底部&lt;/footer&gt;&lt;nav&gt; &lt;a href=&quot;#&quot;&gt;导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;link1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;link2&lt;/a&gt;&lt;/nav&gt;&lt;section&gt;用来划分区域&lt;/section&gt;&lt;article&gt;用来在页面中表示一套结构完整且独立的内容部分（主题）&lt;/article&gt;&lt;aside&gt;和主题相关的附属信息&lt;/aside&gt;&lt;figure&gt;用于对元素进行组合，一般用于图片或视屏&lt;/figure&gt;&lt;figure&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; &lt;figcaption&gt;Test&lt;/figcaption&gt;&lt;/figure&gt;&lt;time&gt;9:00&lt;/time&gt;&lt;p&gt;明天 &lt;time datatime=&quot;2018-02-14&quot;&gt;情人节&lt;/time&gt;&lt;/p&gt;&lt;!--用于描述文档或文档某个部分的细节--&gt;&lt;details open&gt; &lt;!--open时默认打开--&gt; &lt;summary&gt;test&lt;/summary&gt; &lt;!--details元素的标题--&gt; &lt;p&gt;testjfkdsjkfsjd&lt;/p&gt;&lt;/details&gt;&lt;!--定义一段对话--&gt;&lt;dialog&gt; &lt;dt&gt;老师&lt;/dt&gt; &lt;dd&gt;2 + 3 ?&lt;/dd&gt; &lt;dt&gt;学生&lt;/dt&gt; &lt;dd&gt;5&lt;/dd&gt;&lt;/dialog&gt;&lt;address&gt;定义文章或页面作者的详细联系信息&lt;/address&gt;&lt;mark&gt;需要标记的词或句子&lt;/mark&gt;&lt;!--keygen给表单添加一个公钥--&gt;&lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; 用户： &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt; 公钥： &lt;keygen name=&quot;security&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;!--定义进度条--&gt;&lt;progress max=&quot;100&quot; value=&quot;76&quot;&gt; &lt;span&gt;76&lt;/span&gt;% &lt;!--为了兼容--&gt;&lt;/progress&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"对象的扩展","path":"/2018/08/13/对象的扩展/","content":"属性名表达式JavaScript 定义属性有两种方法： 12obj.foo = trueobj[&#x27;a&#x27; + &#x27;bc&#x27;] = 123 ES6 允许字面量定义对象时使用第二种方法： 12345678let propKey = &#x27;foo&#x27;let obj = &#123; [propKey]: true, [&#x27;a&#x27; + &#x27;bc&#x27;]: 123, [&#x27;he&#x27; + &#x27;llo&#x27;]() &#123; return &#x27;hi&#x27; &#125;,&#125; 方法的 name 属性方法的 name 属性也返回函数名。 123456const person = &#123; sayName() &#123; console.log(&#x27;hello&#x27;) &#125;,&#125;person.sayName.name //&#x27;sayName&#x27; 如果对象的方法使用了 getter 和 setter，则 name 的属性不是在该方法上面，而是在该方法属性的描述对象的 get 和 set 属性上面，返回值是方法名前面加上 get 和 set 123456789const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;,&#125;// obj.foo.name; //TypeError: Cannot read property &#x27;name&#x27; of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;)descriptor.get.name //&#x27;get foo&#x27;descriptor.set.name //&#x27;set foo&#x27; 如果对象的方法是一个 Symbol 值，那么 name 属性返回的是这个 Symbol 值的描述。 12345678const key1 = Symbol(&#x27;description&#x27;)const key2 = Symbol()let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;obj[key1].name //&#x27;[description]&#x27;obj[key2].name //&#x27;&#x27; Object.is()ES5 比较两个值是否相等，只有两个相等运算符：&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;，他们都有个缺点，前者会自动转换数据类型，后者 NaN 不等于自身，以及+0 等于-0。ES6 提出了Same-value-equality算法来解决这个问题，Object.is()就是部署这个算法的新方法。不同之处只有两个： 1234;+0 === -0 //trueNaN === NaN //falseObject.is(+0, -0) //falseObject.is(NaN, NaN) //true ES5 可以用代码部署： 12345678910111213Object.defineProperty(Object, &#x27;is&#x27; &#123; value : function(x, y) &#123; if (x === y) &#123; //针对+0不等于-0的情况 return x !== 0 || 1 / x === 1 / y; &#125; //针对NaN return x !== x &amp;&amp; y !== y; &#125;, configurable : true, enumerable : false, writable : true&#125;); Object.assign()Object.assign 方法用于将源对象的所有 可枚举 属性复制到目标对象。第一个参数是目标对象，后面的参数都是源对象 12345var target = &#123; a: 1 &#125;var source1 = &#123; b: 2 &#125;var source2 = &#123; c: 3 &#125;Object.assign(target, source1, source2)target //&#123; a : 1, b : 2, c : 3 &#125; 如果只有一个参数，Object.assign()会直接返回该参数。如果参数不是对象，会先转成对象，然后返回，由于 undefined 和 null 无法转变，所以如果将他们作为参数，就会报错。但是，如果 undefined 和 null 不在首参数，那就不会报错。其他类型的值（数值、字符串和布尔值）不在首参数也不会报错，但是，除了字符串会以数组形式复制到目标对象，其他值都不会产生效果。Object.assign()方法实行的赋值是浅复制，如果源对象的某个属性的值是对象，那么目标对象得到的是这个对象的引用 1234var obj1 = &#123; a: &#123; b: 1 &#125; &#125;var obj2 = Object.assign(obj2, obj1)obj1.a.b = 2obj2.a.b //2 对于这种嵌套对象，一旦遇到同名属性，处理的方法是替换而不是添加。 1234var target = &#123; a: &#123; b: &#x27;c&#x27;, d: &#x27;e&#x27; &#125; &#125;var source = &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;Object.assign(target.source)//target对象的a属性被source对象的a属性整个替换掉了 Object.assign()可以用来处理数组，但是会把数组当成对象来处理。 1Object.assign([1, 2, 3], [4, 5]) //[4, 5, 3] 常见用途： 为对象添加属性： 12345class Point &#123; constructor(x, y) &#123; Object.apply(this, &#123; x, y &#125;) &#125;&#125; 为对象添加方法： 12345678910111213Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123;&#125;, anotherMethod() &#123; //... &#125;,&#125;)//等同于SomeClass.prototype.someMethod = function (arg1, arg2) &#123; //...&#125;SomeClass.prototype.anotherMethod = function () &#123; //...&#125; 克隆对象 12345678910//只克隆对象自身值function clone(origin) &#123; Object.assign(&#123;&#125;, origin)&#125;//保持继承链的方法function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin) return Object.assign(Object.create(originProto), origin)&#125; 合并多个对象 1234const merge = (target, ...sources) =&gt; Object.assign(target, ...sources)//合并到一个对象const merge = (...source) =&gt; Object.assign(&#123;&#125;, ...source) 为属性指定默认值 123456789const DEFAULTS = &#123; logLevel: 0, outputFormat: &#x27;html&#x27;,&#125;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options) console.log(options) //...&#125; 属性的可枚举性对象的每一个属性都有一描述对象，用于控制该属性的行为，Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;)// &#123;// value : 123,// writable : true,// enumerable : true,// configurable : false// &#125; enumerable 属性成为可枚举性，如果该属性为 false，就表示某些操作会忽略当前属性。ES5 有三个操作会忽略 enumerable 为 false 的属性： for…in 循环：只遍历对象自身和继承的可枚举属性。 Object.keys()： 返回对象自身的所有可枚举属性的键名。 JSON.stringify()：只串行化对象自身的可枚举属性。 ES6 规定，所有 Class 的原型的方法都是不可枚举的 属性的遍历ES6 共有五种方法遍历对象的属性： for…in 循环：遍历对象自身和继承的可枚举属性（不含 Symbol 属性）。 Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有 Symbol 属性。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 还是字符串，也不管是否可枚举。以上方法遍历对象属性时都遵守同样的属性遍历次序规则： 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。 proto属性proto属性用来读取或设置当前对象的 prototype 对象。 123456789//ES6写法var obj = &#123; method: function () &#123;&#125;,&#125;obj.__proto__ = someOtherObj//ES5写法var obj = Object.create(someOtherObj)obj.method = function () &#123;&#125; 在实现上，proto调用的是 Object.prototype.proto，实现如下： 123456789101112131415161718192021222324Object.defineProperty(Object.prototype, &#x27;__proto__&#x27;, &#123; get() &#123; let _thisObj = Object(this) return Object.getPrototypeOf(_thisObj) &#125;, set(proto) &#123; if (this === undefined || this === null) &#123; throw new TypeError() &#125; if (!isObject(this)) &#123; return undefined &#125; if (!isObject(proto)) &#123; return undefined &#125; let status = Reflect.setPrototypeOf(this, proto) if (!status) &#123; throw new TypeError() &#125; &#125;,&#125;)function isObject(value) &#123; return Object(value) === value&#125; 如果一个对象本身部署了proto属性，则该属性的值就是对象的原型。 1Object.getPrototypeOf(&#123; __proto__: null &#125;) //null Object.setPrototypeOf()Object.setPrototypeOf()用于设置一个对象的 prototype 对象，返回参数本身。 12345678let proto = &#123;&#125;let obj = &#123; x: 10 &#125;Object.setPrototypeOf(obj, proto)proto.y = 20proto.z = 30//obj对象可以读取proto对象的属性obj.y //20obj.z //30 如果第一个参数不是对象，就会自动转为对象，但是由于返回的还是第一个参数，所以这个操作不会有任何的结果。如果第一个参数是 undefined 或 null，则会报错 Object.setPrototypeOf()Object.setPrototypeOf()用于读取一个对象的 prototype 对象。如果第一个参数不是对象，则会自动转为对象。如果第一个参数是 undefined 或 null，则会报错 Object.keys()、Object.values()、Object.entries()Object.keys()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键名。Object.values()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值。Object.entries()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。实现 Object.entries()： 123456789101112131415//Generator函数版本function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]] &#125;&#125;//非Generator函数版本function entries(obj) &#123; let arr = [] for (let key of Object.keys(obj)) &#123; arr.push([key, obj[key]]) &#125; return arr&#125; 对象的扩展运算符1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;x //1y //2z //&#123; a : 3, b : 4 &#125; 扩展运算符可以用于合并两个对象 123let ab = &#123; ...a, ...b &#125;//等同于let ab = Object.assign(&#123;&#125;, a, b) Object.getOwnPropertyDescriptors()ES5 的 Object.getOwnPropertyDescriptor()方法用来返回某个对象属性的 descriptor。 12345678var obj = &#123; p: &#x27;a&#x27; &#125;Object.getOwnPropertyDescriptor(obj, &#x27;p&#x27;)// Object &#123;// value : &#x27;a&#x27;,// writable : true,// enumerable: true,// configurable: true// &#125; ES2017 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承）的 descriptor。 123456789101112131415161718192021const obj = &#123; foo: 123, get bar() &#123; return this.foo &#125;,&#125;Object.getOwnPropertyDescriptors(obj)// &#123;// foo: &#123;// value : 123,// writable: true,// enumerable: true,// configurable: true// &#125;,// bar: &#123;// get: [Function bar],// set: undefined,// enumerable: true,// configurable: true// &#125;// &#125; 使用 Object.prototype.toString()进行类型判断Object.prototype能够更好的识别出类型，typeof只能识别出基础类型。 1234let date = new Date()console.log(typeof date) // objectconsole.log(Object.prototype.toString.call(date)) // [object Date] 可以识别的类型有： 123: [object Number] ‘1234’: [object String] true: [object Boolean] undefined: [object Undefined] null: [object null] {foo: ‘bar’}: [object Object] [1, 2, 3]: [object Array] new Date(): [object Date] new Error(): [object Error] &#x2F;a+&#x2F;g: [object RegExp] function a() {}: [object Function] Math: [object Math] JSON: [object JSON] arguments: [object arguments]","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"数组的扩展","path":"/2018/08/13/数组的扩展/","content":"扩展运算符123456789console.log(...[1, 2, 3]); //1 2 3console.log(1, ...[2, 3], 4); //1 2 3 4[...document.querySelectorAll(&#x27;divi&#x27;)]; //[&lt;div&gt;, &lt;div&gt;, ...];function add(x, y) &#123; return x + y; &#125;add(...[1, 2]); //3//与表达式一同使用const arr = [...(x &gt; 0 ? [&#x27;a&#x27;] : []), &#x27;b&#x27;]; 扩展运算符的应用 替代数组的 apply 方法 12345678910111213141516171819202122232425 function f(x, y, z) &#123;&#125; var args = [0, 1, 2];//ES5 写法f.apply(null, args);//ES6 写法f(...args);//用 Math.max 求数组中最大的数//ES5 写法Math.max.apply(null, [2, 33, 3]);//ES6 写法Math.max(...[2, 33, 3]);//用 push 将一个数组添加到另一个数组尾部var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];//ES5 写法Array.prototype.push.apply(arr1, arr2);//ES6 写法arr1.push(...arr2); 合并数组 123456789 var arr1 = [&#x27;a&#x27;]; var arr2 = [&#x27;b&#x27;, &#x27;c&#x27;]; var arr3 = [&#x27;d&#x27;];//ES5 写法arr1.concat(arr2, arr3);//ES6 写法[...arr1, ...arr2, ...arr3]; 与解构赋值结合 如果将扩展运算符用于数组赋值，只能将其放在最后一位 1const [first, ...middle, last] = [1, 2, 3, 4, 5]; //SyntaxError: Rest element must be last element 函数的返回值 字符串 实现了 Iterator 接口的对象 Map 和 Set 解构、Generator 函数 Array.from()Array.from()将两类对象转换成真正的数组： array-like object iterable object 123456789101112let arrayLike = &#123;&#x27;0&#x27; : &#x27;a&#x27;,&#x27;1&#x27; : &#x27;b&#x27;,&#x27;2&#x27; : &#x27;c&#x27;,length : 3&#125;;//ES5 写法var arr = [].slice.call(arrayLike);//ES6 写法let arr = Array.from(arrayLike); DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象，Array.from()都可以将他们转换成真正的数组 12//String 有 Iterator 接口Array.from(&#x27;hello&#x27;); //[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] Array.from()还可以接受第二个参数，类似于数组的 map 方法，对每个元素进行处理，将处理后的值放入返回的数组。 12345Array.from(arrayLike, x =&gt; x _ x);//等同于Array.from(arrayLike).map(x =&gt; x _ x);Array.from(&#123; length : 2 &#125;, () =&gt; &#x27;test&#x27;); //[&#x27;test&#x27;, &#x27;test&#x27;] 另一个用途是将字符串转为数组，然后返回长度，可以正确处理 Unicode 字符 123function countSymbols(string) &#123;return Array.from(string).length;&#125; Array.of()Array.of 用于将一组值转换为数组。 123Array.of(1, 2, 3); //[1, 2, 3]Array.of(); //[]Array.of(undefined); //[undefined] 模拟实现： 123function ArrayOf() &#123;return [].slice.call(arguments);&#125; 数组实例的 copyWithin()在当前数组内将指定位置的成员复制到其他位置，然后返回当前数组。接受三个参数： 1Array.prototype.copyWithin(target, start = 0, end = this.length); target（必选）：从该位置开始替换数据 start（可选）：从该位置开始读取数据，默认为 0。如果为负数，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负数，表示倒数。 这三个参数会自动转为数值 1234//从 0 位置开始，将 3 开始到 this.length 的位置的数据填入[1, 2, 3, 4, 5].copyWithin(0, 3); //[4, 5, 3, 4, 5];[1, 2, 3, 4, 5].copyWithin(0, 2); //[3, 4, 5, 4, 5]; 数组实例的 find()和 findIndex()find 用于找出第一个符合条件的数组成员，参数是一个回调函数，如果没有符合的成员，返回 undefined。 1[1, 3, -5, 3, 2].find((n) =&gt; n &lt; 0); //-5 findIndex 方法与 find()类似，没有符合的成员时返回-1。这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象，这两个函数都能发现 NaN，弥补了 IndexOf 的不足。 12[NaN].indexOf(NaN); //-1[NaN].findIndex(y =&gt; Object.is(NaN, y)); //0 数组实例的 fill()与 copyWithin 一样，接受三个参数： value：用于填充的值 start：起始位置 end：结束位置 1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(&#x27;7&#x27;, 0, 1); //[&#x27;7&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 数组实例的 entries()、keys()和 values()ES6 提供了 3 个新方法用于遍历数组，他们都返回一个 Generator 对象，可用 for…of 遍历。唯一的区别在于 keys()是对键名遍历，values()是对键值遍历，entries()是对键值对遍历。 数组实例的 includes()Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与 string 的 includes 方法类似。ES2016 引入了该方法。**Map 和 Set 有 has 方法，需与 includes 区分 Map 的 has 方法是查找键名的 Set 的 has 方法是查找键值的 数组的空位数组的空位指数组的某一个位置没有任何值。比如 Array 构造函数返回的数组都是空位。 1Array(3); //[, , ,] 空位不是 undefined 120 in [undefined, undefined, undefined];//0 号位置有值0 in [,,,]; //0 号位没值 ES5 大多数情况下会忽略空位： forEach()、filter()、every()和 some()都会跳过空位 map()会跳过空位，但会保留这个值 join()和 toString()会将空位视为 undefined，undefined 和 null 会被处理成空字符串 ES6 将空位转为 undefined由于空位的规则非常不统一，所以应避免出现空位","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"尾调用","path":"/2018/08/13/尾调用/","content":"尾调用Tail Call 是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。 123function f(x) &#123;return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 1234function f(x) &#123;if (x &gt; 0) return t(x);return m(x);&#125; 尾调用优化函数调用会在内存中形成一个 call frame，保存调用位置和内部变量等信息。所有的 call frame 形成一个 call stack。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的 call frame，这就叫 Tail Call Optimization，即只保留内层函数的调用帧。 尾递归递归非常耗内存，因为需要同时保存多个 call frame，很容易发生 stack overflow。但对于尾递归来说，由于只存在一个 call frame，所以不会发生溢出。 1234567function Fibonacci(n) &#123;if (n &lt;= 1) return 1;return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;console.log(Fibonacci(10)); //89console.log(Fibonacci(100)); //overflowconsole.log(Fibonacci(500)); //overflow 尾递归优化如下： 1234567function Fibonacci(n, ac1 = 1, ac2 = 1) &#123;if (n &lt;= 1) return ac2;return Fibonacci(n - 1, ac2, ac1 + ac2);&#125;console.log(Fibonacci(10)); //89console.log(Fibonacci(100)); //573147844013817200000console.log(Fibonacci(500)); //2.2559151616193602e+104 由此可见，尾调用优化对递归操作意义重大，所有 ECMAScript 的实现都必须部署尾调用优化。 递归函数的改写函数式编程有一个概念，叫 currying，将多参数的函数转换成单参数的形式。 123456789101112//阶乘的例子function currying(fn, n) &#123;return function (m) &#123;return fn.call(this, m, n);&#125;&#125;function tailFactorial(n, total) &#123;if (n === 1) return total;return tailFactorial(n - 1, n _ total);&#125;const factorial = currying(tailFactorial, 1); //fn, n 都已设定factorial(5); //传 m 120 第二种方法就是使用 ES6 的默认函数值 1234function factorial(n, total = 1) &#123;if (n === 1) return total;return factorial(n - 1, n _ total);&#125; 尾递归优化的实现将递归转换成循环执行1234567891011121314151617function sum(x, y) &#123; //累加函数if (y &gt; 0) return sum(x + 1, y - 1);else return x;&#125;// sum(1, 100000); //RangeError: Maximum call stack size exceeded//用 trampoline 将递归转换为循环执行function trampoline(f) &#123;while (f &amp;&amp; f instanceof Function) &#123;f = f();&#125;return f;&#125;function sum1(x, y) &#123;if (y &gt; 0) return sum1.bind(null, x + 1, y - 1);else return x;&#125;trampoline(sum1(1, 100000)); //100001 使用状态变量1234567891011121314151617181920function tco(f) &#123;var value;var active = false;var accumulated = [];return function accumulator() &#123;accumulated.push(arguments);if (!active) &#123;active = true;while (accumulated.length) &#123;value = f.apply(this, accumulated.shift());&#125;active = false;return value;&#125;&#125;;&#125;var sum = tco(function (x, y) &#123;if (y &gt; 0) return sum(x + 1, y - 1);else return x;&#125;);","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"函数的扩展","path":"/2018/08/13/函数的扩展/","content":"函数的默认值在 ES6 之前，不能直接为函数指定默认值，只能采用变通的方法： 12345678function log(x, y) &#123; if (y === &#x27;undefined&#x27;) &#123; y = &#x27;world&#x27; &#125; console.log(x, y)&#125;log(&#x27;hello&#x27;) //hello testlog(&#x27;hello&#x27;, &#x27;&#x27;) //hello ES6 允许为函数的参数设置默认值： 123456789101112function log(x, y = &#x27;world&#x27;) &#123; console.log(x, y)&#125;log(&#x27;hello&#x27;) //hello worldlog(&#x27;hello&#x27;, &#x27;&#x27;) //helloeg: function Point(x = 0, y = 0) &#123; this.x = x this.y = y&#125;let p = new Point()console.log(p.x + &#x27; &#x27; + p.y) //0 0 参数的默认值是 lazy evaluation 的，每次都重新计算默认值 1234567let x = 1function foo(f = x + 1) &#123; console.log(f)&#125;foo() //2x = 3foo() //4 解构赋值与默认值结合使用1234567function foo(&#123; x, y = 5 &#125;) &#123; console.log(x, y)&#125;foo(&#123;&#125;) //undefined 5foo(&#123; x: 1 &#125;) //1 5foo(&#123; x: 1, y: 2 &#125;) //1 2foo() //TypeError: Cannot destructure property `x` of &#x27;undefined&#x27; or &#x27;null&#x27; 写法不同，默认值不同 12345678910111213function m1(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; //默认值是空对象 console.log(x, y)&#125;function m2(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; console.log(x, y)&#125;m1() //0 0m2() //0 0m1(&#123; x: 1, y: 2 &#125;) //1 2m2(&#123; x: 1, y: 2 &#125;) //1 2m1(&#123;&#125;) //0 0m2(&#123;&#125;) //undefined undefined 如果传入 undefined，将触发该参数等于默认值，null 没有效果 1234function foo(x = 1, y = 2) &#123; console.log(x, y)&#125;foo(undefined, null) //1 null 利用默认参数可以指定某一个参数不得省略，省略就报错 1234567function throwIfMissing() &#123; throw new Error(&#x27;Missing parameter&#x27;)&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided&#125;foo() //Error: Missing parameter 可以将参数默认值设为 undefined，表明这个参数是可以省略的 1function foo(optional = undefined) &#123;&#125; 函数的 length 属性length 不计从默认参数开始的参数个数。 123;(function (a) &#123;&#125;).length //1;(function (a = 5) &#123;&#125;).length //0;(function (a, b = 1) &#123;&#125;).length //1 rest 参数ES6 引入了 rest 参数，用于获取函数的多余参数，这样就不用使用 arguments 对象了。 12345678910111213function add(...values) &#123; let sum = 0 for (let value of values) sum += value return sum&#125;add(1, 2, 3, 4) //10//arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort()&#125;//rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort() 函数的 length 属性也不包括 rest 参数 name 属性函数的 name 属性返回该函数的函数名 12345678910111213function foo() &#123;&#125;foo.name //&#x27;foo&#x27;var f = function () &#123;&#125;//ES5f.name //&#x27;&#x27;//ES6f.name //&#x27;f&#x27;const bar = function baz() &#123;&#125;bar.name //&#x27;baz&#x27; Function 构造函数返回的函数实例，name 属性的值为 anonymous。 1new Function().name //&#x27;anonymous&#x27; bind 返回的函数，name 属性值会加上 bound 前缀。 123function foo() &#123;&#125;foo.bind(&#123;&#125;).name //&#x27;bound foo&#x27;;(function () &#123;&#125;).bind(&#123;&#125;).name //&#x27;bound &#x27; 箭头函数12345var f = (v) =&gt; v//等同于var f = function (v) &#123; return v&#125; 如果箭头函数的代码块多于一条语句，就要使用大括号括起来。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2&#125; 由于大括号被解释为代码块，所以如果直接返回一个对象，必须在对象外加上括号。 1var get = (id) =&gt; (&#123; id: id, name: &#x27;get&#x27; &#125;) 可以与变量解构结合使用 12345const full = (&#123; first, last &#125;) =&gt; first + &#x27;,&#x27; + last//等同于function full(person) &#123; return person.first + &#x27;,&#x27; + person.last&#125; 注意事项 函数体内的 this 对象就是定义时所在的对象，而不是使用时所在的对象。 不可当做构造函数，不能使用 new 命令。 不可使用 arguments 对象，该对象在函数体内不存在，可以使用 rest 参数代替。 不可以使用 yield 命令，因此不能做 Generator 函数。 1234567function foo() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;id:&#x27;, this.id) &#125;, 1000)&#125;let id = 21foo.call(&#123; id: 4 &#125;) //id: 4 嵌套的箭头函数12345678910111213141516171819202122function insert(value) &#123; return &#123; into: function (array) &#123; return &#123; after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value) return array &#125;, &#125; &#125;, &#125;&#125;insert(2).into([1, 3]).after(1) //[1, 2, 3]//箭头函数写法const insert = (value) =&gt; (&#123; into: (array) =&gt; (&#123; after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value) return array &#125;, &#125;),&#125;) apply 的简易实现Function.apply(thisArg: any, argArray?: any)第一个参数用于接受 this 对象，剩余参数为arguments。所以可以根据思路： 将this挂载到thisArg.fn上 通过thisArg.fn传递参数，获取返回值 删除thisArg.fn 返回 在浏览器中，如果第一个参数为this，那么需要将thisArg设置为window对象。 123456789101112131415161718Function.prototype.my_apply = function (context, array) &#123; context = Object(context) || window context.fn = this let result if (!array) &#123; result = context.fn() &#125; else &#123; let args = [] for (let i = 0, len = array.length; i &lt; len; i++) &#123; args.push(`array[$&#123;i&#125;]`) &#125; result = eval(`context.fn($&#123;args&#125;)`) // context.fn(array[0], array[1]) &#125; delete context.fn return result&#125; call 的简易实现与apply的实现类似，区别在于参数的获取方式不同。 12345678910111213Function.prototype.my_call = function (context) &#123; let args = [] context = Object(context) || window // if call(null) then point to window context.fn = this // put current function into context.fn for (let i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(`arguments[$&#123;i&#125;]`) // push the arguments into args &#125; let result = eval(`context.fn($&#123;args&#125;)`) // call function with parameters delete context.fn return result&#125; bind 的简易实现bind有个最大的特点，就是绑定后的函数也可以使用new操作符创建对象，这时bind中指定的this就会被忽略，转而指向被构造的对象： 12345678910111213141516171819202122let age = 2let person = &#123; age: 12,&#125;function foo(text) &#123; this.first = &#x27;Edward&#x27; console.log(this.age) console.log(text)&#125;foo.prototype.last = &#x27;Snowden&#x27;let bindFoo = foo.bind(person, &#x27;some text&#x27;)let obj = bindFoo()// 12// some textlet newObj = new bindFoo()// undefined// some textconsole.log(newObj.first, newObj.last) // Edward Snowden 在上面这个例子中，不管是person中的age还是Global中的age，都没有被打印出来，因为此时的this已经指向了newObj。所以需要通过修改返回值来实现。 1234567891011121314151617181920212223Function.prototype.my_bind = function (context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new Error(`need to be function`) &#125; let _this = this let args = Array.prototype.slice.call(arguments, 1) // get the rest of arguments let fTemp = function () &#123;&#125; let fBound = function () &#123; let bindArgs = Array.prototype.slice.call(arguments) // get the arguments from the return function return _this.apply( this instanceof fTemp ? this : context, args.concat(bindArgs), ) // check if it is be a constructor &#125; fTemp.prototype = this.prototype fBound.prototype = new fTemp() return fBound&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"~运算符","path":"/2018/08/12/运算符/","content":"~运算符位运算符是三步处理的过程： 把运算数转换成 32 位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 123var iNum1 = 25; //25 等于 00000000000000000000000000011001var iNum2 = ~iNum1; //转换为 11111111111111111111111111100110alert(iNum2); //输出 &quot;-26&quot; ~~技巧这是刷题时看见别人的代码里使用的东西，通常用来代替 Math.trunc()的方法。 123456//单个 ~console.log(~1337); // -1338//数字输入console.log(~~47.11); //47console.log(~~1.9999); //1console.log(~~3); //3 当原始输入不确定时，~~可以将任何非数字类型转换成 0： 12345678console.log(~~[]) //0console.log(~~NaN) //0console.log(~~null) //0// | 0 也是相同的效果console.log([] | 0) //0console.log(NaN | 0) //0console.log(null | 0) //0 在使用前应仔细检查值，数值大的情况： 1234let number = 2147483647.123; //比 32 位最大正数，再多一点console.log(~~number); //2147483647 (ok)number += 10000; //2147493647.123 (ok)console.log(~~number); //-2147473649","tags":["学习"],"categories":["ECMAScript"]},{"title":"Math的扩展","path":"/2018/08/11/Math的扩展/","content":"Math.trunc()Math.trunc 用于除去一个数的小数部分。 123456789Math.trunc(111.22); //111Math.trunc(&#x27;123.456&#x27;); //123//对空和无法截取整数的值，返回 NaNMath.trunc(NaN); //NaN//代码模拟Math.trunc = Math.trunc || function (x) &#123;return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.sign()Math.sign 用于判断一个数到底是正数、负数、还是零。 参数为正数，返回+1 参数为负数，返回-1 参数为 0，返回 0 参数为-0，返回-0 其他值，返回 NaN 12345678//代码模拟Math.sign = Math.sign || function (x) &#123;x = +x; //convert to a numberif (x === 0 || isNaN(x)) &#123;return x;&#125;return x &gt; 0 ? 1 : -1;&#125;; Math.cbrt()Math.cbrt 用于计算一个数的立方根，对于非数值，内部也是先使用 Number 方法转换为数值。 12345//代码模拟Math.cbrt = Math.cbrt || function (x) &#123;var y = Math.pow(Math.abs(x), 1 / 3);return x &lt; 0 ? -y : y;&#125;; Math.clz32()Math.clz32 返回一个数的 32 位无符号整数形式有多少个前导 0. 12345Math.clz32(0); //32Math.clz32(1); //31Math.clz32(0b01000000000000000000000000000000); //1Math.clz32(1 &lt;&lt; 1); //30 对于小数，Math.clz32()只考虑整数部分 1Math.clz32(3.9); //30 Math.imul()Math.imul 返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位带符号整数。对于很大数的乘法，低位数值往往是不精确的，Math.imul()方法可以正确的返回低位数值。 Math.fround()Math.fround 方法返回一个数的单精度浮点数形式。对于整数来说，Math.fround()方法的返回结果不会有任何不同，区别主要在于那些无法用 64 个二进制位精确表示的小数。这时，Math.fround()方法会返回最接近这个小数的单精度浮点数。 1234//代码模拟Math.fround = Math.fround || function (x) &#123;return new Float32Array([x])[0];&#125;; Math.hypot()Math.hypot 方法返回所有参数的平方和的平方根。 1Math.hypot(3, 4); //5 Math.expm1()Math.expm1(x)返回$e^x-1$， 即 Math.exp(x) - 1; 1234//代码模拟Math.expm1 = Math.expm1 || function (x) &#123;return Math.exp(x) - 1;&#125;; Math.log1p()Math.log1p(x)返回$ln(1+x)$，即 Math.log(1 + x)。如果 x 小于-1，则返回 NaN。 1234//代码模拟Math.log1p = Math.log1p || function (x) &#123;return Math.log(1 + x);&#125; Math.log10()Math.log10(x)返回$log_{10}(x)$，如果 x 小于 0，返回 NaN。 1234//代码模拟Math.log10 = Math.log10 || function (x) &#123;return Math.log(x) / Math.LN10;&#125;; Math.log2()Math.log2(x)返回$log_2(x)$，如果 x 小于 0，返回 NaN。 1234//代码模拟Math.log2 = Math.log2 || function (x) &#123;return Math.log(x) / Math.LN2;&#125;; 双曲函数方法ES6 新增了六个双曲函数方法 Math.sinh(x) 返回 $sinh\\ x&#x3D;\\frac{e^x-e^{-x}}{2}$ Math.cosh(x) 返回 $cosh\\ x&#x3D;\\frac{e^x+e^{-x}}{2}$ Math.tanh(x) 返回 $tanh\\ x&#x3D;\\frac{sinh\\ x}{cosh\\ x}&#x3D;\\frac{e^x-e^{-x}}{e^x+e^{-x}}$ Math.asinh(x) 返回 $arsinh\\ x&#x3D;ln(x+\\sqrt[\\ ]{x^2+1})$ Math.acosh(x) 返回 $arsinh\\ x&#x3D;ln(x+\\sqrt[\\ ]{x^2-1})$ Math.atanh(x) 返回 $artanh\\ x&#x3D;\\frac{1}{2}ln\\frac{1+x}{1-x}$ Math.sign()Math.sign 用来判断一个数的正负，如果参数是-0，会返回-0。 指数运算符**123452 ** 2; //43 ** 3; //27let a = 1.5;a **= 3; //a = a _ a _ a; **在 V8 引擎中，指数运算符与 Math.pow 的实现不相同，对于特别大的运算结果，两者会有差异**","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Number的扩展","path":"/2018/08/11/Number的扩展/","content":"进制表示0b(0B)表示二进制，0o(0O)表示八进制 Number.isFinite()、Number.isNaN()Number.isFinite 用来检查一个数值是否为有限的。 123456Number.isFinite(NaN); //falseNumber.isFinite(Infinity); //falseNumber.isFinite(-Infinity); //falseNumber.isFinite(&#x27;15&#x27;); //falseNumber.isFinite(&#x27;foo&#x27;); //falseNumber.isFinite(true); //false ES5 部署 Number.isFinite()方法： 12345678910111213(function (global) &#123;var global_isFinite = global.isFinite; Object.defineProperty(Number, &#x27;isFinite&#x27;, &#123; value : function isFinite(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; global_isFinite(value); &#125;, configurable : true, enumerable : false, writable : true &#125;);&#125;)(this); Number.isNaN 用来检查一个值是否为 NaN。 12345Number.isNaN(NaN); //trueNumber.isNaN(&#x27;15&#x27;); //falseNumber.isNaN(9 / NaN); //trueNumber.isNaN(&#x27;true&#x27; / 0); //trueNumber.isNaN(&#x27;true&#x27; / &#x27;true&#x27;); //true ES5 部署 Number.isNaN()方法： 12345678910111213(function (global) &#123;var global_isNaN = global.isNaN; Object.defineProperty(Number, &#x27;isNaN&#x27;, &#123; value : function isNaN(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; global_isNaN(value); &#125;, configurable : true, enumerable : false, writable : true &#125;);&#125;)(this); Number.parseInt()、Number.parseFloat()ES6 将全局方法 parseInt 和 parseFloat 移植到了 Number 对象上面，行为完全不变。 Number.isInteger()Number.isInteger 判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是相同的储存方法，所以 3 和 3.0 视为同一个值。 12Number.isInteger(&#x27;15&#x27;); //falseNumber.isInteger(true); //false ES5 部署 Number.isInteger()方法： 12345678910111213(function (global) &#123;var floor = Math.floor, isFinite = global.isFinite; Object.defineProperty(Number, &#x27;isInteger&#x27;, &#123; value : function isInteger(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; isFinite(value) &amp;&amp; floor(value) == value; &#125;, configurable : true, enumerable : false, writable : true &#125;);&#125;)(this); Number.EPSILONES6 在 Number 对象上面新增一个极小的常量–Number.EPSILON。浮点数计算是不精确的，但是如果这个误差可以小于 Number.EPSILON，就可以认为得到了正确的结果。 Number.isSafeInteger()JavaScript 能够准确表示的整数范围在$-2^{53}$到$2^{53}$之间（不含两个端点），超过这个范围就无法精确表示。ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 两个常量来表示这个范围的上下限","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"正则的扩展","path":"/2018/08/11/正则的扩展/","content":"基本用法12345var regex = new RegExp(&#x27;xyz&#x27;, &#x27;i&#x27;);var regex = new RegExp(/xyz/i);var regex = /xyz/i;new RegExp(/abc/ig, &#x27;i&#x27;).flags; //ig 被覆盖成 i match()、replace()、search()、split()String.prototype.match 调用 RegExp.prototype[Symbol.match]String.prototype.replace 调用 RegExp.prototype[Symbol.replace]String.prototype.search 调用 RegExp.prototype[Symbol.search]String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符、i 修饰符、y 修饰符ES6 对正则表达式添加了 u 修饰符，用来处理大于\\uFFFF 的 Unicod 字符。\\u004B 与\\u212A 都是 K，不加修饰就无法识别非规范的 K 字符。y 修饰符与 g 修饰符类似，也是全局匹配，不同之处在于 g 修饰符只要剩余位置中存在匹配就行，而 y 修饰符会确保匹配必须从剩余的第一个位置开始。 12345678var s = &#x27;aaa-aa-a&#x27;;var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); //[&#x27;aaa&#x27;]r2.exec(s); //[&#x27;aaa&#x27;]r1.exec(s); //[&#x27;aa&#x27;]r2.exec(s); //null sticky 属性与 y 修饰符匹配，表示是否设置了 y 修饰符。 flags 属性返回正则表达式的修饰符。 组匹配12345const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(&#x27;2018-03-01&#x27;);const year = matchObj[1]; //2018const month = matchObj[2]; //03const day = matchObj[3]; //01","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"字符串的扩展","path":"/2018/08/10/字符串的扩展/","content":"codePointAt()JavaScript-16 的格式储存，每个字符固定为两个字节。需要四个字节储存的字符，JavaScript 会认为那是两个字符。ES6 提供了 codePointAt 方法，能够正确处理四个字节储存的字符，返回一个字符的码点。 String.fromCodePoint()识别 UTF-32 字符。 includes()、startsWith()、endsWith()1234567var s = &#x27;hello world&#x27;;s.startWith(&#x27;hello&#x27;); //trues.endsWith(&#x27;d&#x27;); //trues.includes(&#x27;o&#x27;); //trues.startsWith(&#x27;world&#x27;, 6); //true;s.includes(&#x27;hello&#x27;, 6); //false repeat()1234567891011&#x27;x&#x27;.repeat(3); //&#x27;xxx&#x27;&#x27;na&#x27;.repeat(0); //&#x27;&#x27;&#x27;na&#x27;.repeat(2.9); //取整 -&gt; &#x27;nana&#x27;&#x27;na&#x27;.repeat(Infinity); //Error&#x27;na&#x27;.repeat(-1); //Error&#x27;na&#x27;.repeat(-0.9); //&#x27;&#x27;&#x27;na&#x27;.repeat(NaN); //&#x27;&#x27;&#x27;na&#x27;.repeat(&#x27;3&#x27;); //&#x27;nanana&#x27; padStart(), padEnd()首、尾补全 123456789&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;); //&#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;); //&#x27;abax&#x27;&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;); //&#x27;xabab&#x27;&#x27;x&#x27;.padStart(5); //&#x27; x&#x27;&#x27;x&#x27;.padEnd(5); //&#x27;x &#x27;&#x27;1&#x27;.padStart(10, &#x27;0&#x27;); //&#x27;0000000001&#x27;&#x27;09-12&#x27;.padStart(10, &#x27;YYYY-MM-DD&#x27;); //&#x27;YYYY-09-12&#x27; 模板字符串1234567891011121314let name = &#x27;test&#x27;;`name : $&#123;name&#125;`;let x = 1, y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`;//1 + 2 = 3let obj = &#123; x : 1, y : 2 &#125;;`&#123;obj.x + obj.y&#125;`;function fn() &#123;return &#x27;test&#x27;&#125;`foo $(fn)`; String.raw()Sring.raw 方法用来充当模板字符串的处理函数，返回一个斜线都被转义的字符串，对应于替换变量后的模板字符串。 12String.raw`Hi $&#123;1 + 3&#125;`;//Hi\\ 4","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"解构赋值","path":"/2018/08/10/解构赋值/","content":"基本用法12345678910111213141516171819let [a, b, c] = [1, 2, 3];let [foo, [[bar], baz]] = [1, [[2], 3]];let [, , third] = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;];third; //&#x27;baz&#x27;let [x, , y] = [1, 2, 3];x, y; //1, 3let [head, ...tail] = [1, 2, 3, 4];head; //1tail; //[2, 3, 4]let [x, y, ...z] = [&#x27;a&#x27;];x; //ay; //undefinedz; //[]let [x, y, z] = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);x; //&#x27;a&#x27; 不完全解构也会解构成功1234567let [x, y] = [1, 2, 3];x, y; //1, 2let [a, [b], d] = [1, [2, 3], 4];a; //1b; //2d; //4 只要具备 Iterator 接口，都可以进行解构赋值123456789function\\* fibs() &#123;let a = 0, b = 1;while (true) &#123;yield a;[a, b] = [b, a + b];&#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth; //5 默认值1234567let [foo = &#x27;true&#x27;] = [];foo; //truelet [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; //x = a, y = blet [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;, undefined]; //x = a, y = b;let [x = 1] = [null]; //x = null, null 不严格等于 undefined 如果默认值是一个表达式，那么这个表达式是 lazy evaluation 的，只有在用到时才会求值。 12345function f() &#123;console.log(&#x27;f is run&#x27;);&#125;let [x = f()] = [1]; //f 不会执行let [x = y, y = 1] = []; //ReferenceError 对象的解构赋值12345678let &#123; foo, bar &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27; &#125;;foo; //&#x27;aaa&#x27;bar; //&#x27;baz&#x27;let &#123; baz &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27; &#125;;baz; //undefinedlet &#123; foo : baz &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27; &#125;;baz; //&#x27;aaa&#x27; 前者是匹配模式，后者是变量。 1let &#123; foo : foo, bar : bar &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27;&#125;; 解构的嵌套123456789101112131415161718192021222324let obj = &#123;p : [&#x27;hello&#x27;,&#123; y : &#x27;world&#x27; &#125;]&#125;;let &#123; p : [x, &#123;y&#125;]&#125; = obj;//x : &#x27;hello&#x27;, y : &#x27;world&#x27;var node = &#123;loc : &#123;start : &#123;line : 1,column : 5&#125;&#125;&#125;;var &#123; loc, loc : &#123; start &#125;, loc : &#123; start : &#123; line &#125;&#125;&#125; = node;line; //1loc; //Object &#123;start : Object&#125;start; //Object &#123;line : 1, column : 5&#125;let x;(&#123;x&#125; = &#123;x : 1&#125;); //避免 JavaScript 解释为代码块 如果解构失败，变量的值等于 undefined 解构的用途交换变量的值12let x = 1, y = 2;[x, y] = [y, x]; 从函数返回多个值1234567891011function example1() &#123;return [1, 2, 3];&#125;let [a, b, c] = example1();function example2() &#123;return &#123;foo : 1,bar : 2&#125;;&#125;let &#123; foo, bar &#125; = example2(); 函数参数的定义1234function f([x, y, z]) &#123;&#125;f([1, 2, 3]);function f1(&#123;x, y, z&#125;) &#123;&#125;f1(&#123;z : 3, y : 1, x : 1&#125;); 提取 JSON 数据123456let jsonData = &#123;id : 32,status : &#x27;OK&#x27;,data : [332, 452]&#125;let &#123; id, status, data : number &#125; = jsonData;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"顶层对象","path":"/2018/08/10/顶层对象/","content":"ES6 中，为了保持兼容性，var 和 function 声明的全局变量依旧是顶层对象的属性1234var a = 1; //如果在 Node 的 REPL 环境，可以写成 global.a 或者 this.awindow.a; //1let b = 1;window.b; //undefined global 对象 在浏览器对象中，顶层对象是 window，但 Node 和 Web Worker 没有 window。 在浏览器和 Web Worker 中，self 也指向顶层对象，但 Node 没有 self。 在 Node 中，顶层对象是 global，但其他环境都不支持。 以下为两种勉强可以取到顶层对象的方法： 1234567891011//方法一(typeof window !== &#x27;undefined&#x27; ? window : (typeof process === &#x27;object&#x27; &amp;&amp; typeof require === &#x27;function&#x27; &amp;&amp; typeof global === &#x27;object&#x27;) ? global : this);//方法二var getGlobal = function () &#123;if (typeof self !== &#x27;undefined&#x27;) &#123; return self; &#125;if (typeof window !== &#x27;undefined&#x27;) &#123; return window; &#125;if (typeof global !== &#x27;undefined&#x27;) &#123; return global; &#125;throw new Error(&#x27;unalbe to locate global object&#x27;);&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"const","path":"/2018/08/10/const/","content":"一旦声明，值不可变12const PI = 3.14;PI = 3; //TypeError: Assignment to constant variable. 只声明不赋值也会报错。 1const foo; //SyntaxError: Missing initializer in const declaration 实质为变量指向的内存地址不可变动const 只能保证这个指针是固定的，不能控制数据结构的变化。 123const foo = &#123;&#125;;foo.prop = 123; //Successfoo = &#123;&#125;; //TypeError: &#x27;foo&#x27; is read-only 对象冻结方法使用 Object.freeze 函数，冻结对象 1const foo = Object.freeze(&#123;&#125;); 冻结属性的函数 12345678var constantize = (obj) =&gt; &#123;Object.freeze(obj);Object.keys(obj).forEach((key, i) =&gt; &#123;if (typeof obj[key] === &#x27;object&#x27;) &#123;constantize(obj[key]);&#125;&#125;);&#125;;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"let","path":"/2018/08/10/let/","content":"let 声明的变量在代码块内有效1234567var a [];for (let i = 0; i &lt; 10; i++) &#123;a[i] = function() &#123;console.log(i);&#125;;&#125;a[6](); //6 不存在变量提升var 命令的变量可以在声明之前使用，值为 undefined 暂时性死区在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。TDZ(temporal dead zone) 12345var temp = 123;if (true) &#123;temp = &#x27;abc&#x27;; //ReferenceErrorlet temp;&#125; 有些死区是不易发现的 1234function bar(x = y, y = 2) &#123; //y is not definedreturn [x, y];&#125;let x = x; //ReferenceError: x is not defined 不允许重复声明1234function foo() &#123;var a;let a;&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"未看书导致的一个坑","path":"/2018/08/10/未看书导致的一个坑/","content":"某日被书中一段代码误导 1234567var promise = new Promise(function (resolve, reject) &#123;resolve(&#x27;ok&#x27;);setTimeout(function() &#123; throw new Error(&#x27;test&#x27;) &#125;, 0);&#125;);promise.then(function (value) &#123; console.log(value) &#125;);//ok//Uncaught Error : test 由于前面还有这样一段话 如果 Promise 状态已经变成 Resolved，再抛出错误是无效的。 当时看到这，思索了许久，为什么已经 resolve 了这个 ERROR 还是可以往外抛出呢？后面发现，settimeout 是一个异步函数，throw 会在下一轮事件循环开始时抛出，所以无论是否 resolve，这个 ERROR 都是会抛出的。","tags":["学习"]},{"title":"开坑","path":"/2018/08/10/开坑/","content":"开坑第一篇从大学开始就想着弄一篇自己的博客，但是一直都断断断续的。在这个风雨交加的午间，我决定开坑了。可能以后主要还是用于记笔记之类的吧，偶尔应该也会写点杂七杂八的东西。。","tags":["雜談"]},{"title":"ABOUT ME","path":"/about/index.html","content":"Freelancers"},{"title":"Battery Notes","path":"/battery/index.html","content":"This page is used to record some notes"},{"title":"18650","path":"/battery/18650.html","content":"名称含义 18：直径 18mm 65：高度 65mm 0：圆柱体 Li-ion Battery，Lithiumion Battery 锂电池 Lithiumion second Battery 锂二次电池 Lithium Rechargeable Battery 锂充电电池 3.7v：使用过程中的平台电压（classical voltage） 4.2v：满电电压 动力电池：功率高（容量在 2200-2600mah 之间） 寿命：理论循环 1000 次 充放电原理锂电池充电控制是分为两个阶段的，第一阶段是恒流充电，在电池电压低于 4.2V 时，充电器会以恒定电流充电。第二阶段是恒压充电阶段，当电池电压达到 4.2V 时，由于锂电池特性，如果电压再高，就会损坏，充电器会将电压固定在 4.2V，充电电流会逐步减小，当电流减小到一定值时（一般是 1&#x2F;10 设置电流时），切断充电电路，充电完成指示灯亮，充电完成。锂离子电池过度充放电会对正负极造成永久性损坏。过度放电导致负极碳片层结构出现塌陷，而塌陷会造成充电过程中锂离子无法插入；过度充电使过多的锂离子嵌入负极碳结构，而造成其中部分锂离子再也无法释放出来。 有些充电器使用廉价的方案实现的，在控制精度上不够好，容易造成电池充电异常，甚至损坏电池。选购充电器的时候尽量选择大品牌的 18650 锂离子电池充电器，质量和售后有保证，延长电池的使用寿命。品牌保障的 18650 锂离子电池充电器拥有四重保护：短路保护、过流保护、过压保护、电池反接保护功能等。过充电保护：当充电器对锂离子电池过充电时，为防止因温度上升所导致的内压上升，需终止充电状态。为此，保护器件需监测电池电压，当其到达电池过充电压时，即激活过充电保护功能，中止充电。 过放电保护：为了防止锂离子电池的过放电状态，当锂离子电池电压低于其过放电电压检测点时，即激活过放电保护，中止放电，并将电池保持在低静态电流的待机模式。过电流及短路保护：当锂离子电池的放电电流过大或短路情况产生时，保护器件将激活过电流保护功能。 一般配置 单节标称电压一般为：3.6V 或 3.7V 充电电压一般为：4.20V (钴酸锂为 4.2V-4.3V) 最小放电终止电压一般为： 2.75V ，低于这个电压容易导致电池容量严重下降乃至报废 最大充电终止电压：4.20V 直径：18±0.2mm 高度：65±2.0mm 容量：1000mAh 以上，常规容量为 2200mAh-3200mAh，18650 电池容量做得最高的是 LG，能做到 3600mAh，但价格也不低。"},{"title":"原料","path":"/battery/原料.html","content":"原料部分 青稞纸 泡沫 美纹纸 保护芯片 PVC 防水胶 设备部分 点焊机 切割机 电池电压电阻测试仪（不可测量电芯，精度太低） 电芯高精度测试仪 老化测试仪 红外温度计 电烙铁 电池分选机 自动贴面垫机 激光焊接机（大电池组需要铜排焊接）"},{"title":"电池组电芯条件","path":"/battery/电池组电芯条件.html","content":"标压 3.7v 的四个电池组，中间最大的误差为 10mv，过大的误差会导致电池组无法统一容量，造成其他问题。 在下午的测试中，标压 3.7v，最大电压可到 3.895。 随着时间推移，可能会下降， 但是电池组之间的电池各自电压应相差无几。如相隔 3 个月的 2 并 1 串电池，电压跌至 3.841v 附近，但同组电池之间相差无几，就可正常使用。"},{"title":"Breadth-First Search","path":"/algorithm/Breadth-First Search.html","content":"与 DFS 类似，从某个状态出发探索所有可以到达的状态。不同之处在于访问的顺序，BFS 总是先访问距离初始状态最近的状态。也就是说： 开始 -&gt;一次转化可以到达的状态 -&gt; 二次转化可以到达的状态 -&gt; …。对于同一个状态，BFS 只访问一次。复杂度为 O(状态数量 * 转移方式) eg： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * * @param &#123;string[]&#125; matrix * @return &#123;number&#125; - The minimum length from start to end. */ function resolve(matrix) &#123; const dx = [1, 0, -1, 0] const dy = [0, 1, 0, -1] let startX = 0 let startY = 0 let endX = 0 let endY = 0 const iLen = matrix.length const jLen = matrix[0].length const queue = [] // 到各个位置的最短距离数组 const dp = new Array(iLen) .fill(null) .map(() =&gt; new Array(jLen).fill(undefined)) for (let i = 0; i &lt; iLen; i++) &#123; for (let j = 0; j &lt; jLen; j++) &#123; if (matrix[i][j] === &#x27;S&#x27;) &#123; startX = i startY = j &#125; if (matrix[i][j] === &#x27;G&#x27;) &#123; endX = i endY = j &#125; &#125; &#125; queue.push([startX, startY]) dp[startX][startY] = 0 // 初始化开始坐标 while (queue.length &gt; 0) &#123; const [x, y] = queue.shift() if (x === endX &amp;&amp; y === endY) &#123; // 到达终点 break &#125; for (let i = 0; i &lt; 4; i++) &#123; const tempX = x + dx[i] const tempY = y + dy[i] if ( tempX &gt;= 0 &amp;&amp; // x 在范围内 tempX &lt; iLen &amp;&amp; tempY &gt;= 0 &amp;&amp; // y 在范围内 tempY &lt; jLen &amp;&amp; matrix[tempX][tempY] !== &#x27;#&#x27; &amp;&amp; // 不是墙 dp[tempX][tempY] === undefined // 没有访问过 ) &#123; queue.push([tempX, tempY]) dp[tempX][tempY] = dp[x][y] + 1 &#125; &#125; &#125; return dp[endX][endY]&#125;console.log( resolve([ &#x27;#S######.#&#x27;, &#x27;......#..#&#x27;, &#x27;.#.##.##.#&#x27;, &#x27;.#........&#x27;, &#x27;##.##.####&#x27;, &#x27;....#....#&#x27;, &#x27;.#######.#&#x27;, &#x27;....#.....&#x27;, &#x27;.####.###.&#x27;, &#x27;....#...G#&#x27;, ]),)"},{"title":"DP-划分数","path":"/algorithm/DP-划分数.html","content":"题目 分析 解答1234567891011121314151617181920212223242526272829/** * @param &#123;number&#125; n - 个数 * @param &#123;number&#125; m - 组数 * @param &#123;number&#125; mod */function solve(n, m, mod) &#123; const dp = new Array(m + 1).fill(null).map(() =&gt; new Array(n + 1).fill(0)) dp[0][0] = 1 for (let i = 1; i &lt;= m; i++) &#123; for (let j = 0; j &lt;= n; j++) &#123; if (j - i &gt;= 0) &#123; // 可以分成一组的情况 // (i-1,j) 上一组 // (i, j-i) 上一个 j-i 划分 dp[i][j] = (dp[i - 1][j] + dp[i][j - i]) % mod &#125; else &#123; // 不能分成一组，直接拿前一组 dp[i][j] = dp[i - 1][j] &#125; &#125; &#125; console.log(dp) return dp[m][n]&#125;console.log(solve(4, 3, 10000))"},{"title":"DP-01背包","path":"/algorithm/DP-01背包.html","content":"问题分析： 使用一个数组，将计算过的值存起来。如果之后再次访问，直接返回计算后的值。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * @param &#123;number[][]&#125; arr - (weight, value)[] * @param &#123;number&#125; maxHeavy - The max weight can be picked. */ function resolve(arr, maxHeavy) &#123; const len = arr.length const dp = new Array(10000).fill(null).map(() =&gt; new Array(10000).fill(-1)) /** * @param &#123;number&#125; index - Current index * @param &#123;number&#125; current - The last heavy. */ function traverse(index, current) &#123; if (dp[index][current] &gt;= 0) return dp[index][current] let res if (index === len) &#123; res = 0 &#125; else if (current &lt; arr[index][0]) &#123; res = traverse(index + 1, current) &#125; else &#123; res = Math.max( traverse(index + 1, current), traverse(index + 1, current - arr[index][0]) + arr[index][1], ) &#125; return (dp[index][current] = res) &#125; return traverse(0, maxHeavy)&#125;console.log( resolve( [ [2, 3], [1, 2], [3, 4], [2, 2], ], 5, ),) 目录 [[DP-多重部分合问题]] [[DP-划分数]] [[DP-完全背包]] [[DP-最长公共子序列]] [[DP-最长上升子序列问题]]"},{"title":"DP-多重部分合问题","path":"/algorithm/DP-多重部分合问题.html","content":"题目 分析 解答12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums - nums can use * @param &#123;number[]&#125; times - times each num can use * @param &#123;number&#125; target - target num */ function resolve(nums, times, target) &#123; const dp = new Array(target + 1).fill(-1) dp[0] = 0 for (let i = 0, len = nums.length; i &lt; len; i++) &#123; for (let j = 0; j &lt;= target; j++) &#123; if (dp[j] &gt;= 0) &#123; dp[j] = times[i] &#125; else if (j &lt; nums[i] || dp[j - nums[i]] &lt;= 0) &#123; dp[j] = -1 &#125; else &#123; dp[j] = dp[j - nums[i]] - 1 &#125; &#125; &#125; if (dp[target] &gt;= 0) &#123; return &#x27;Yes&#x27; &#125; return &#x27;No&#x27;&#125;console.log(resolve([3, 5, 8], [3, 2, 2], 17))"},{"title":"DP-完全背包","path":"/algorithm/DP-完全背包.html","content":"题目： 分析： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number[][]&#125; items - [weight, value] * @param &#123;number&#125; maxHeavy */function resolve(items, maxHeavy) &#123; const len = items.length const dp = new Array(len + 1) .fill(null) .map(() =&gt; new Array(maxHeavy + 1).fill(0)) for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt;= maxHeavy; j++) &#123; if (j &lt; items[i][0]) &#123; dp[i + 1][j] = dp[i][j] // 不拿这一个 &#125; else &#123; dp[i + 1][j] = Math.max( dp[i][j], // 不拿的情况 /** * dp[i+1][j - items[i][1]] 代表上一次这个重量的 max 价值 * 加上这次拿上的价值计算 max */ dp[i + 1][j - items[i][0]] + items[i][1], ) &#125; &#125; &#125; dp.forEach((i) =&gt; console.log(i.join(&#x27;, &#x27;))) return dp[len][maxHeavy]&#125;console.log( resolve( [ [3, 4], [4, 5], [2, 3], ], 7, ),)"},{"title":"LG-105","path":"/battery/LG-105.html","content":"基本信息 name：LG-105，3p7s，电芯满电 4.2v，空电 2.5v 工艺流程 电池分选：将不同电压、内阻的电池区别分选出来。 组装电池：将电池按照顺序安装到模具中，注意正负极不能装错。 点焊：先将纯镍连接片点焊到电池上，再将小连接片点焊到之前焊稳在电池上的连接片上。注意小连接片需要点焊在电池的负极处，并且注意每个点焊的位置不能错误。 点焊检查：每个焊点需要点焊两次，不能出现虚焊、炸焊等。用刀片对焊点进行撬动，检查是否存在虚焊、双层片（两个相同的片点在相同的位置）、炸焊等情况。如果出现虚焊的情况，需要及时反映到点焊处，对点焊机进行调整。 排线：将树脂板、青稞纸、双面胶等安装在电池组上，然后将线布置好，注意正负极。剥锡需要长度长一点（5mm 左右）。 焊线：将线按照要求焊接在电池组的连接片处。 焊接保护板：将保护板焊接在电池组上，并且将排线的插头插入保护板。 贴青稞纸：用青稞纸将电池组包裹住，进行绝缘。 电池综合测试：使用综合测试仪对电池组进行测试，将不良品选出。若良品率低，需要及时停止前面工序，检查问题。 电池老化测试：使用老化测试仪对电池进行老化测试。老化流程为充电 -&gt; 放电 -&gt; 归电（将电池充到来料时的电量）。通过老化测试可以测出之前肉眼无法观察到的问题，如虚焊、双层板等。通过观察电池的参数，测试数据（空电电压2.5*7、满电电压4.2*7、电容数据、电阻、过流等）。电池的充电电流一般为&lt;电池容量*并联数/2，如电池容量为 2500mah，3 并，则最大电流为2.5A*3/2=7.5A/2，低于这个电流较好。放电电流一般为2A~3A。 老化测试结束：将电池组的正极使用美纹纸包裹，防止电池组短路。 过塑：用 PVC 热缩锁膜对电池组进行热收缩包裹处理。 焊接充电口：将电池组正极与充电口正极焊接在一起，电池组负极与充电口负极焊接在一起。同时再焊接在放电口上。注意焊接之后，组装时正负线不许交叉。 打白胶：使用白胶包裹住电池的充电口与放电口，防止电池正负极短接发生短路。 贴 EVA：使用 EVA 对电池组进行包裹，并装入塑料壳中。使用厚度较厚的 EVA 贴在电池的电极处，使用较薄的 EVA 贴在电池的侧身处。每处 3 个，总共为两侧电极 3*2+一侧 3，9 个 EVA。 组装放电口：将电池的放电口组装在塑料壳上，注意正负极的位置。 贴遇水显红标：在标签上写下出货日期，并在统一位置处粘贴。 盒盖：在塑料壳的中间部分钉入两个铁钉，然后进行盒盖。 上大螺丝：对外壳的后盖进行螺丝固定，总共 5 个。 上小螺丝：对外壳的充电口进行螺丝固定，总共 2 个。 出货测试：使用外用表对电池的放电口与充电口进行测试，检查是否存在正负极反接，电压过低，电压过高等。放电口测试方法为正接正极，负接负极；充电口为卡农口，测试方法为 1 号为正极，3 号为负极，2 号有时与负极相连，有时为分口。所以测试 1、3 口即可。标准出货要求与老化阶段的归电电压相同。允许有0.2v的掉电。如果电压过高，需要上老化机进行放电；电压过低则需要进行充电。 贴防撕毁标：贴在固定位置即可。 装箱：需要尺寸为50cm*100cm的珍珠棉。 注意事项 点焊：虚焊、炸焊 焊接排线与保护板：注意正负极 综合测试仪：对电池进行测试，勿反接（老式测试仪无反接保护，会把测试仪直接烧坏） 老化结束：正极包裹美纹纸，防止短路 出厂测试：每个端口都需测试"},{"title":"DP-最长公共子序列","path":"/algorithm/DP-最长公共子序列.html","content":"题目 分析 代码实现 1234567891011121314151617181920212223242526/** * @param &#123;string&#125; str1 * @param &#123;string&#125; str2 * @return &#123;number&#125; */function resolve(str1, str2) &#123; const len1 = str1.length const len2 = str2.length const dp = new Array(len1 + 1) .fill(null) .map(() =&gt; new Array(len2 + 1).fill(0)) for (let i = 0; i &lt; len1; i++) &#123; for (let j = 0; j &lt; len2; j++) &#123; if (str1[i] === str2[j]) &#123; dp[i + 1][j + 1] = dp[i][j] + 1 &#125; else &#123; dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]) &#125; &#125; &#125; return dp[len1][len2]&#125;console.log(resolve(&#x27;abcd&#x27;, &#x27;becd&#x27;))"},{"title":"Depth-First Search","path":"/algorithm/Depth-First Search.html","content":"某个状态开始，不断地转移状态，直到状态无法转移，然后退回到前一个状态，继续转移其他状态。如此不断重复，直到找到最终解。根据 DFS 的特点，使用递归实现比较简单。 eg： 每一个分量都可以分为加与不加两种状态。 代码实现： 123456789101112131415161718192021222324/** * * @param &#123;number[]&#125; arr * @param &#123;number&#125; target * @return &#123;boolean&#125; */function test(arr, target) &#123; const len = arr.length /** * @param &#123;number&#125; index - Current index. * @param &#123;number&#125; sum - Current sum. */ function dfs(index, sum) &#123; if (index === len) return sum === target if (dfs(index + 1, sum)) return true // If is target when without current val. if (dfs(index + 1, sum + arr[index])) return true // If is target when with current val. return false &#125; return dfs(0, 0)&#125;console.log(test([1, 2, 4, 7], 15)) eg2: 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * * @param &#123;string[][]&#125; water */function test(water) &#123; let result = 0 const row = water.length const col = water[0].length /** * @param &#123;number&#125; x * @param &#123;number&#125; y */ function dfs(x, y) &#123; water[x][y] = &#x27;.&#x27; for (let dx = -1; dx &lt;= 1; dx++) &#123; for (let dy = -1; dy &lt;= 1; dy++) &#123; const xp = x + dx const yp = y + dy if ( xp &gt;= 0 &amp;&amp; xp &lt; row &amp;&amp; yp &gt;= 0 &amp;&amp; yp &lt; col &amp;&amp; water[xp][yp] === &#x27;w&#x27; ) &#123; dfs(xp, yp) &#125; &#125; &#125; &#125; /** * Print the `water` with beauty format. */ function print() &#123; console.log(&#x27;-------------------------&#x27;) for (let i = 0; i &lt; row; i++) console.log(water[i].join(&#x27;,&#x27;)) console.log(&#x27;-------------------------&#x27;) &#125; for (let i = 0; i &lt; row; i++) &#123; for (let j = 0; j &lt; row; j++) &#123; if (water[i][j] === &#x27;w&#x27;) &#123; print() dfs(i, j) result++ &#125; &#125; &#125; return result&#125;console.log( test([ [&#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;w&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], [&#x27;w&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;w&#x27;, &#x27;.&#x27;], ]),)"},{"title":"优先队列-汽车加油问题","path":"/algorithm/优先队列-汽车加油问题.html","content":"题目 分析 解答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const MaxHeap = require(&#x27;./template/maxheap&#x27;)/** * @param &#123;number&#125; init * @param &#123;number&#125; target * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; - 加油次数 */function solve(init, target, A, B) &#123; /** * 终点也设置为加油站 */ A[A.length] = target B[B.length] = 0 /** * priority_queue 优先队列 * @type &#123;MaxHeap&#125; */ const heap = new MaxHeap() /** * 加油次数 * @type &#123;number&#125; */ let res = 0 /** * 当前位置 * @type &#123;number&#125; */ let position = 0 /** * 剩余汽油量 * @type &#123;number&#125; */ let currentP = init for (let i = 0, len = A.length; i &lt; len; i++) &#123; /** * 下一个位置 * @type &#123;number&#125; */ let delta = A[i] - position /** * 油量不足以到这个加油站时 */ while (currentP - delta &lt; 0) &#123; if (heap.empty()) &#123; return -1 &#125; currentP += heap.top() heap.delete() res++ &#125; currentP -= delta position = A[i] heap.insert(B[i]) &#125; return res&#125;console.log(solve(10, 25, [10, 14, 20, 21], [10, 5, 2, 4]))"},{"title":"贪心-Saruman's Army","path":"/algorithm/贪心-Saruman's Army.html","content":"思路： 代码实现： 1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; points - Index of each point. * @param range - The range * @return &#123;number&#125; - The minimum num of point need to marked. */ function resolve(points, range) &#123; points.sort((a, b) =&gt; a - b) let i = 0 const len = points.length let result = 0 while (i &lt; len) &#123; let s = points[i++] // 起始点 while (i &lt; len &amp;&amp; points[i] &lt;= s + range) i++ // 找到需要标记的点 let p = points[i - 1] // 找到 range 之内的最后一个点坐标 while (i &lt; len &amp;&amp; points[i] &lt;= p + range) i++ // 找到需要标记的点，也是下一次循环的起始点 result++ &#125; return result&#125;console.log(resolve([1, 7, 15, 20, 30, 50], 10))"},{"title":"Algorithm Note","path":"/algorithm/index.html","content":"record the algorithm learning process."},{"title":"DP-最长上升子序列问题","path":"/algorithm/DP-最长上升子序列问题.html","content":"题目 分析 解答123456789101112131415161718192021/** * @param &#123;number[]&#125; nums */function solve(nums) &#123; let res = 0 const len = nums.length const dp = new Array(len) for (let i = 0; i &lt; len; i++) &#123; dp[i] = 1 for (let j = 0; j &lt; i; j++) &#123; // 从前往后遍历 if (nums[j] &lt; nums[i]) &#123; // 位置 i 的长度为 max（当前长度， 前一个位置长度+1） dp[i] = Math.max(dp[i], dp[j] + 1) &#125; // 更新 max res = Math.max(dp[i], res) &#125; &#125; return res&#125;"},{"title":"贪心-Fence Repair","path":"/algorithm/贪心-Fence Repair.html","content":"分析思路： 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;number[]&#125; woods * @return &#123;number&#125; - Times need to be cut. */ function resolve(woods) &#123; let len = woods.length let result = 0 while (len &gt; 1) &#123; let min1 = 0 let min2 = 1 if (woods[min1] &gt; woods[min2]) &#123; // swap the min one ;[woods[min1], woods[min2]] = [woods[min2], woods[min1]] &#125; for (let i = 2; i &lt; len; i++) &#123; // update the min 2 if (woods[i] &lt; woods[min1]) &#123; min2 = min1 min1 = i &#125; else if (woods[i] &lt; woods[min2]) &#123; min2 = i &#125; &#125; const val = woods[min1] + woods[min2] result += val if (min1 === len - 1) &#123; // the last one ;[woods[min1], woods[min2]] = [woods[min2], woods[min1]] &#125; woods[min1] = val woods[min2] = woods[len - 1] // delete the last one len-- &#125; return result&#125;console.log(resolve([8, 5, 8]))"},{"title":"贪心","path":"/algorithm/贪心.html","content":"遵循某种策略，不断地选取当前最优策略的算法设计方法。 代码实现： 123456789101112131415161718/** * * @param &#123;number[]&#125; coins - The coins already have. * @param &#123;number&#125; target - Target currency. * @return &#123;number&#125; - The minimum count of coins used. */ function resolve(coins, target) &#123; const coinAmount = [1, 5, 10, 50, 100, 500] let result = 0 for (let i = 5; i &gt;= 0; i--) &#123; const num = Math.min(Math.floor(target / coinAmount[i]), coins[i]) // 拿最大的数量 target -= num * coinAmount[i] result += num &#125; return result&#125;console.log(resolve([3, 2, 1, 3, 0, 2], 620)) eg：区间问题 代码实现： 12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; start - Start time of the each job. * @param &#123;number[]&#125; end - End time of the each job. * @return &#123;number&#125; - The maximum of jobs can be done. */ function resolve(start, end) &#123; let result = 0 let t = 0 // current time const arr = [] // [end, start] start.map((_, index) =&gt; &#123; arr.push([end[index], start[index]]) &#125;) // 按照字典序进行升序 arr.sort(([a1, a2], [b1, b2]) =&gt; &#123; if (a1 !== b1) return a1 - b1 return a2 - b2 &#125;) for (let i = 0, len = arr.length; i &lt; len; i++) &#123; const [end, start] = arr[i] if (t &lt; start) &#123; result++ // 任务数 + 1 t = end // 当前时间更新为任务结束时间 &#125; &#125; return result&#125;console.log(resolve([1, 2, 4, 6, 8], [3, 5, 7, 9, 10])) 目录 [[贪心-字典序最小问题]] [[贪心-Fence Repair]] [[贪心-Saruman’s Army]]"},{"title":"CLS-Cumulative Layout Shift","path":"/frontend/CLS-Cumulative Layout Shift.html","content":"什么是 CLS？CLS 是所有布局偏移分数的汇总，凡是在页面完整生命周期内预料之外的布局偏移都包括。 布局偏移发生在任意时间，当一个可见元素改变了它的位置，从一个渲染帧到下一个。 什么是一个好的 CLS 分数？75%以上的用户小于 0.1。 布局偏移的具体内容布局偏移是由 Layout Instability API 定义的。这个 API 会在任意时间上报 layout-shift 的条目，当一个可见元素在两帧之间，改变了它的起始位置（默认的 writing mode 下指的是 top 和 left 属性）。这些元素被当成不稳定元素。 需要注意的是，布局偏移只发生在已经存在的元素改变起始位置的时候。如果一个新的元素被添加到 dom 上，或者已存在的元素改变它的尺寸，除非改变了其他元素的起始位置，否则都不算布局偏移。 布局偏移分数为了计算布局偏移分数，浏览器看的是视图尺寸和两帧之间不稳定元素的移动。布局偏移的分数是两个度量的乘积：影响分数(impact fraction)和距离分数(distance fraction)。 1layout shift score = impact fraction * distance fraction 为什么是两个度量的乘积？因为如果是一个很大的元素移动了较小的距离，实际影响并不大，所以分数需要依赖两个度量。 影响分数影响分数测试的是两帧之间，不稳定元素在视图上的影响范围。 包含前后两帧，不稳定元素的可见区域的总和除以总的视图大小，就是当前帧的影响分数。 上图中，元素在一帧中占了屏幕的一半。下一帧，元素下移了 25%的视图高度。红色虚线框起来的部分就是不稳定元素在两帧的占的视图总和（75%），所以影响分数是 0.75。 距离分数距离分数测试的是两帧之间，不稳定元素在视图上移动的距离（水平和纵向取最大值）。如果有多个不稳定元素，也是取其中最大的一个。 上面的例子，不稳定元素在纵向移动了 25%，所以距离分数是 0.25。 所以布局偏移分数是 0.75 * 0.25 = 0.1875 。 下一个例子是在已存在的元素中插入一个新的元素，计算布局偏移分数: “Click Me!”按钮被插入到灰色盒子下方，把绿色盒子往下推了。 在这个例子中，灰色盒子只是改变了尺寸，所以不算不稳定元素。 “Click Me!”按钮因为是新插入的元素，所以也不算不稳定元素。 绿色盒子的起始位子改变了，但因为部分区域不在视图内，不在视图内的区域不算入影响分数，所以影响分数是 0.5。 距离分数是蓝色尖头的部分，绿色盒子往下移动了 14%，所以距离分数是 0.14。 布局偏移分数是 0.5 * 0.14 = 0.07 。 最后一个例子是多个不稳定元素: 第一帧中，API 结果返回了 4 个，按字母序排列。第二帧返回了更多，同样的是字母序。 第一个元素 “Cat” 前后没有改变起始位子，所以是稳定的。同样，新加入的元素，也是稳定的。只有 “Dog”, “Horse”, “Zebra” 这三个元素改变了起始位子，是不稳定元素。 红色虚线框起来的部分就是影响分数，表示所有不稳定元素可见区域占视图的比例，大概是 0.38。 蓝色箭头所指的就是距离分数，因为这是所有不稳定元素中最大的移动距离，大概是 0.3。 布局偏移分数是 0.38 x 0.3 = 0.1172 。 预料 vs 预料之外的布局偏移并非所有布局偏移都是不好的。实际上，很多动态 web 应用经常性的改变元素的起始位置。 用户启动的布局偏移用户预料之外的布局偏移才是不好的。换句话说，如果是为了响应用户的交互而产生的布局偏移通常是很好的。只要布局偏移与用户交互足够紧密，这两者之间的关系对用户而言是很明确的。 例如，用户触发了一个网络请求，可能需要花一段时间才能结束，最好的做法是创造一些空白区域或者展示 loading，避免请求结束后的预料之外的布局偏移。如果用户没有意识到正在加载数据，或者不知道资源是否加载完成，他们在等待的过程中会点击某些元素，这些元素后面可能会移动到了下方，就跟文章开头的图一样。 布局偏移如果发生在用户输入之后的 500ms 内，会有一个 hadRecentInput 的标记，这样就可以被排除在外。 动画和过渡动画和过渡，如果做得好，对用户而言是一个不错的更新内容的方式，这样不会给用户“惊喜”。突然出现的或者预料之外的内容，会给用户一个很差的体验。但如果是一个动画或者过渡，用户可以很清楚的知道发生了什么，在状态变化的时候可以很好的引导用户。 CSS 中的 transform 属性可以让你在使用动画的时候不会产生布局偏移。 用 transform:scale() 来替换 width 和 height 属性 用 transform:translate() 来替换 top, left, bottom, right 属性 如何测试 CLS？可以集成 web-vitals 的库，代码如下: 12345import &#123;getCLS&#125; from &#x27;web-vitals&#x27;;// Measure and log the current CLS value,// any time it&#x27;s ready to be reported.getCLS(console.log); CLS 是所有独立的 layout-shift 条目的汇总（排除掉用户输入近期的条目）。 比起统计每一个 layout-shift 条目，在页面隐藏之后，统计一个 CLS 的总分更合适。 如何改善 CLS？对大部分网站而言，可以参考以下: 对图片和视频元素总是设定好尺寸，否则保留所需的空间。这样可以保证浏览器给这些元素分配足够的空间，在加载之后，不会产生布局偏移。如果浏览器支持，可以开启 unsized-media feature policy 的策略。 永远不要把内容插入到已有元素的上方，除非为了响应用户交互。 如果需要用到动画，优先使用不会产生布局偏移的 CSS 属性。 更多 CLS 优化可以期待后面的文章。 总结CLS 是平时开发很少关注的点，页面视觉稳定性对很多 web 开发而言，可能没有加载性能那么关注度高，但对用户而言，这确实是很困扰的一点。平时开发中，尽可能的提醒自己，不管是产品交互图出来之后，或者是 UI 的视觉稿出来之后，如果出现了布局偏移的情况，都可以提出这方面的意见。开发过程中也尽可能的遵循上面提到的一些优化点，给用户一个稳定的视觉体验。"},{"title":"Fiber架构的实现原理","path":"/frontend/Fiber架构的实现原理.html","content":"Fiber 的起源 最早的Fiber官方解释来源于2016 年 React 团队成员 Acdlite 的一篇介绍 (opens new window)。 从上一章的学习我们知道： 在React15及以前，Reconciler采用递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。 为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟 DOM 数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。 Fiber 的含义Fiber包含三层含义： 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件&#x2F;类组件&#x2F;原生组件…）、对应的 DOM 节点等信息。 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除&#x2F;被插入页面中&#x2F;被更新…）。 Fiber 的结构你可以从这里看到Fiber 节点的属性定义 (opens new window)。虽然属性很多，但我们可以按三层含义将他们分类来看 12345678910111213141516171819202122232425262728293031323334353637383940414243function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,) &#123; // 作为静态数据结构的属性 this.tag = tag this.key = key this.elementType = null this.type = null this.stateNode = null // 用于连接其他Fiber节点形成Fiber树 this.return = null this.child = null this.sibling = null this.index = 0 this.ref = null // 作为动态的工作单元的属性 this.pendingProps = pendingProps this.memoizedProps = null this.updateQueue = null this.memoizedState = null this.dependencies = null this.mode = mode this.effectTag = NoEffect this.nextEffect = null this.firstEffect = null this.lastEffect = null // 调度优先级相关 this.lanes = NoLanes this.childLanes = NoLanes // 指向该fiber在另一次更新时对应的fiber this.alternate = null&#125; 作为架构来说每个 Fiber 节点有个对应的React element，多个Fiber节点是如何连接形成树呢？靠如下三个属性： 123456// 指向父级Fiber节点this.return = null// 指向子Fiber节点this.child = null// 指向右边第一个兄弟Fiber节点this.sibling = null 举个例子，如下的组件结构： 12345678function App() &#123; return ( &lt;div&gt; i am &lt;span&gt;KaSong&lt;/span&gt; &lt;/div&gt; )&#125; 对应的Fiber树结构： 这里需要提一下，为什么父级指针叫做return而不是parent或者father呢？因为作为一个工作单元，return指节点执行完completeWork（本章后面会介绍）后会返回的下一个节点。子Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用return指代父级节点。 作为静态的数据结构作为一种静态的数据结构，保存了组件相关的信息： 12345678910// Fiber对应组件的类型 Function/Class/Host...this.tag = tag// key属性this.key = key// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹this.elementType = null// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagNamethis.type = null// Fiber对应的真实DOM节点this.stateNode = null 作为动态的工作单元作为动态的工作单元，Fiber中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍 123456789101112131415// 保存本次更新造成的状态改变相关信息this.pendingProps = pendingPropsthis.memoizedProps = nullthis.updateQueue = nullthis.memoizedState = nullthis.dependencies = nullthis.mode = mode// 保存本次更新会造成的DOM操作this.effectTag = NoEffectthis.nextEffect = nullthis.firstEffect = nullthis.lastEffect = null 如下两个字段保存调度优先级相关的信息，会在讲解Scheduler时介绍。 123// 调度优先级相关this.lanes = NoLanesthis.childLanes = NoLanes 注意 在 2020 年 5 月，调度优先级策略经历了比较大的重构。以expirationTime属性为代表的优先级模型被lane取代。详见这个 PR(opens new window) 如果你的源码中fiber.expirationTime仍存在，请参照调试源码章节获取最新代码。 总结本节我们了解了Fiber的起源与架构，其中Fiber节点可以构成Fiber树。那么Fiber树和页面呈现的DOM树有什么关系，React又是如何更新DOM的呢？ 我们会在下一节讲解。 参考资料Lin Clark - A Cartoon Intro to Fiber - React Conf 2017"},{"title":"Fiber架构的工作原理","path":"/frontend/Fiber架构的工作原理.html","content":"什么是“双缓存”当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。 如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。 为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。 这种在内存中构建并直接替换的技术叫做双缓存 (opens new window)。 React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。 双缓存 Fiber 树在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。 current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。 12currentFiber.alternate === workInProgressFiberworkInProgressFiber.alternate === currentFiber React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。 即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。 每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。 接下来我们以具体例子讲解mount时、update时的构建&#x2F;替换流程。 mount 时考虑如下例子： 123456function App() &#123; const [num, add] = useState(0) return &lt;p onClick=&#123;() =&gt; add(num + 1)&#125;&gt;&#123;num&#125;&lt;/p&gt;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 首次执行ReactDOM.render会创建fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是&lt;App/&gt;所在组件树的根节点。 之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用ReactDOM.render渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。 fiberRootNode的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber树。 fiberRootNode.current = rootFiber 由于是首屏渲染，页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点（即current Fiber树为空）。 接下来进入render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。（下图中右侧为内存中构建的树，左侧为页面显示的树） 在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，在首屏渲染时只有rootFiber存在对应的current fiber（即rootFiber.alternate）。 图中右侧已构建完的workInProgress Fiber树在commit阶段渲染到页面。 此时DOM更新为右侧树对应的样子。fiberRootNode的current指针指向workInProgress Fiber树使其变为current Fiber 树。 update 时 接下来我们点击p节点触发状态改变，这会开启一次新的render阶段并构建一棵新的workInProgress Fiber 树。 和mount时一样，workInProgress fiber的创建可以复用current Fiber树对应的节点数据。 这个决定是否复用的过程就是 Diff 算法，后面章节会详细讲解 workInProgress Fiber 树在render阶段完成构建后进入commit阶段渲染到页面上。渲染完毕后，workInProgress Fiber 树变为current Fiber 树。 总结本文介绍了Fiber树的构建与替换过程，这个过程伴随着DOM的更新。 那么在构建过程中每个Fiber节点具体是如何创建的呢？我们会在架构篇的render 阶段讲解。"},{"title":"Fiber架构的心智模型","path":"/frontend/Fiber架构的心智模型.html","content":"React 核心团队成员Sebastian Markbåge (opens new window)（React Hooks的发明者）曾说：我们在React中做的就是践行代数效应（Algebraic Effects）。 那么，代数效应是什么呢？他和React有什么关系呢。 什么是代数效应代数效应是函数式编程中的一个概念，用于将副作用从函数调用中分离。 接下来我们用虚构的语法来解释。 假设我们有一个函数getTotalPicNum，传入 2 个用户名称后，分别查找该用户在平台保存的图片数量，最后将图片数量相加后返回。 123456function getTotalPicNum(user1, user2) &#123; const picNum1 = getPicNum(user1) const picNum2 = getPicNum(user2) return picNum1 + picNum2&#125; 在getTotalPicNum中，我们不关注getPicNum的实现，只在乎“获取到两个数字后将他们相加的结果返回”这一过程。 接下来我们来实现getPicNum。 “用户在平台保存的图片数量”是保存在服务器中的。所以，为了获取该值，我们需要发起异步请求。 为了尽量保持getTotalPicNum的调用方式不变，我们首先想到了使用async await： 123456async function getTotalPicNum(user1, user2) &#123; const picNum1 = await getPicNum(user1) const picNum2 = await getPicNum(user2) return picNum1 + picNum2&#125; 但是，async await是有传染性的 —— 当一个函数变为async后，这意味着调用他的函数也需要是async，这破坏了getTotalPicNum的同步特性。 有没有什么办法能保持getTotalPicNum保持现有调用方式不变的情况下实现异步请求呢？ 没有。不过我们可以虚构一个。 我们虚构一个类似try...catch的语法 —— try...handle与两个操作符perform、resume。 1234567891011121314151617function getPicNum(name) &#123; const picNum = perform name; return picNum;&#125;try &#123; getTotalPicNum(&#x27;kaSong&#x27;, &#x27;xiaoMing&#x27;);&#125; handle (who) &#123; switch (who) &#123; case &#x27;kaSong&#x27;: resume with 230; case &#x27;xiaoMing&#x27;: resume with 122; default: resume with 0; &#125;&#125; 当执行到getTotalPicNum内部的getPicNum方法时，会执行perform name。 此时函数调用栈会从getPicNum方法内跳出，被最近一个try...handle捕获。类似throw Error后被最近一个try...catch捕获。 类似throw Error后Error会作为catch的参数，perform name后name会作为handle的参数。 与try...catch最大的不同在于：当Error被catch捕获后，之前的调用栈就销毁了。而handle执行resume后会回到之前perform的调用栈。 对于case &#39;kaSong&#39;，执行完resume with 230;后调用栈会回到getPicNum，此时picNum === 230 注意 再次申明，try...handle的语法是虚构的，只是为了演示代数效应的思想。 总结一下：代数效应能够将副作用（例子中为请求图片数量）从函数逻辑中分离，使函数关注点保持纯粹。 并且，从例子中可以看出，perform resume不需要区分同步异步。 代数效应在 React 中的应用那么代数效应与React有什么关系呢？最明显的例子就是Hooks。 对于类似useState、useReducer、useRef这样的Hook，我们不需要关注FunctionComponent的state在Hook中是如何保存的，React会为我们处理。 我们只需要假设useState返回的是我们想要的state，并编写业务逻辑就行。 12345function App() &#123; const [num, updateNum] = useState(0) return &lt;button onClick=&#123;() =&gt; updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;&lt;/button&gt;&#125; 如果这个例子还不够明显，可以看看官方的Suspense Demo(opens new window) 在Demo中ProfileDetails用于展示用户名称。而用户名称是异步请求的。 但是Demo中完全是同步的写法。 1234function ProfileDetails() &#123; const user = resource.user.read() return &lt;h1&gt;&#123;user.name&#125;&lt;/h1&gt;&#125; 代数效应与 Generator从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。 异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。 这就是代数效应中try...handle的作用。 其实，浏览器原生就支持类似的实现，这就是Generator。 但是Generator的一些缺陷使React团队放弃了他： 类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。 Generator执行的中间状态是上下文关联的。 考虑如下例子： 12345678function* doWork(A, B, C) &#123; var x = doExpensiveWorkA(A) yield var y = x + doExpensiveWorkB(B) yield var z = y + doExpensiveWorkC(C) return z&#125; 每当浏览器有空闲时间都会依次执行其中一个doExpensiveWork，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。 只考虑“单一优先级任务的中断与继续”情况下Generator可以很好的实现异步可中断更新。 但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。 此时B组件接收到一个高优更新，由于Generator执行的中间状态是上下文关联的，所以计算y时无法复用之前已经计算出的x，需要重新计算。 如果通过全局变量保存之前执行的中间状态，又会引入新的复杂度。 更详细的解释可以参考这个 issue(opens new window) 基于这些原因，React没有采用Generator实现协调器。 代数效应与 FiberFiber并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。 在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。 所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。 React Fiber可以理解为： React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 其中每个任务更新单元为React Element对应的Fiber节点。 其他文章 [[Fiber架构的工作原理]] [[Fiber架构的实现原理]]"},{"title":"React Native Bug 定位","path":"/frontend/React Native Bug 定位.html","content":"checksums) as it has already been locked by this process.更新了 gradle 版本后，出现的问题。需要把 cache 给清除 1find ~/.gradle -type f -name &quot;*.lock&quot; -delete"},{"title":"贪心-字典序最小问题","path":"/algorithm/贪心-字典序最小问题.html","content":"代码实现： 1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; s - Original string. * @return &#123;string&#125; - Result. */ function resolve(s) &#123; const result = [] let left = 0 let right = s.length - 1 while (left &lt;= right) &#123; let flag = false // is less from left to right for (let i = 0; i + left &lt;= right; i++) &#123; if (s[left + i] &lt; s[right - i]) &#123; // is less from left to right flag = true break &#125; else if (s[left + i] &gt; s[right - i]) &#123; // is less from right to left flag = false break &#125; &#125; if (flag) result.push(s[left++]) else result.push(s[right--]) &#125; return result.join(&#x27;&#x27;)&#125;console.log(resolve(&#x27;acdbcb&#x27;))"},{"title":"Event Loop","path":"/frontend/Event Loop.html","content":"浏览器中的事件循环 JavaScript 代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。 macro-task 大概包括： script（整体代码） setTimeout setInterval setImmediate I&#x2F;O UI render micro-task 大概包括： process.nextTick Promise async&#x2F;await（还是 Promise） MutationObserver（HTML5） 整体流程大概为： 执行 macro-task，然后执行该任务产生的 micro-task，若 micro-task 在执行过程中新生成了 micro-task，则继续执行 micro-task。直到无 micro-task，返回 macro-task，进行 event loop。 答案为： async2 end Promise async1 end promise1 promise2 setTimeout async&#x2F;await 执行顺序 我们知道 async 隐式返回 Promise 函数，可以理解为 await 后的语句执行结束后，await 产生一个 micro-task。但是时机在与执行完 await 后的语句之后，会暂停当前执行，转而执行其他 loop。然后按照 micro-task 的注册顺序，继续执行。最后进入下一个 macro-task。 Node 和 Browser 的 EentLoop 差异 Browser 中的 micro-task 是在每个相应的 macro-task 中执行的。 NodeJS 中的 micro-task 是在不同阶段中执行的。 NodeJS 版本差异 NodeJS11 之后，会在执行一个 macro-task 之后立即执行他的 micro-task 队列。 123456789101112setTimeout(() =&gt; &#123; console.log(&#x27;timer1&#x27;) Promise.resolve().then(function () &#123; console.log(&#x27;promise1&#x27;) &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log(&#x27;timer2&#x27;) Promise.resolve().then(function () &#123; console.log(&#x27;promise2&#x27;) &#125;)&#125;, 0) node11 之前：timer1 -&gt; timer2 -&gt; promise1 -&gt; promise2 node11 之后：timer1 -&gt; promise1 -&gt; timer2 -&gt; promise2"},{"title":"React-新的架构","path":"/frontend/React-新的架构.html","content":"React16 架构可以分为三层： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 可以看到，相较于 React15，React16 中新增了 Scheduler（调度器），让我们来了解下他。 Scheduler（调度器）既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。 其实部分浏览器已经实现了这个 API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用： 浏览器兼容性 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的requestIdleCallback触发的频率会变得很低 基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。 Scheduler (opens new window)是独立于React的库 Reconciler（协调器）我们知道，在 React15 中 Reconciler 是递归处理虚拟 DOM 的。让我们看看React16 的 Reconciler (opens new window)。 我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。 1234567/** @noinline */function workLoopConcurrent() &#123; // Perform work until Scheduler asks us to yield while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; workInProgress = performUnitOfWork(workInProgress) &#125;&#125; 那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？ 在 React16 中，Reconciler 与 Renderer 不再是交替工作。当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟 DOM 打上代表增&#x2F;删&#x2F;更新的标记，类似这样： 1234export const Placement = /* */ 0b0000000000010export const Update = /* */ 0b0000000000100export const PlacementAndUpdate = /* */ 0b0000000000110export const Deletion = /* */ 0b0000000001000 全部的标记见这里(opens new window) 整个 Scheduler 与 Reconciler 的工作都在内存中进行。只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer。 你可以在这里 (opens new window)看到React官方对 React16 新 Reconciler 的解释 Renderer（渲染器）Renderer 根据 Reconciler 为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。 所以，对于我们在上一节使用过的 Demo 在 React16 架构中整个更新流程为： 其中红框中的步骤随时可能由于以下原因被中断： 有其他更高优任务需要先更新 当前帧没有剩余时间 由于红框中的工作都在内存中进行，不会更新页面上的 DOM，所以即使反复中断，用户也不会看见更新不完全的 DOM（即上一节演示的情况）。 实际上，由于 Scheduler 和 Reconciler 都是平台无关的，所以React为他们单独发了一个包react-Reconciler (opens new window)。你可以用这个包自己实现一个ReactDOM，具体见参考资料 参考资料「英文 外网」Building a Custom React Renderer | React 前经理 Sophie Alpert"},{"title":"React-Native错误采集原理 & 实现","path":"/frontend/React-Native错误采集原理 & 实现.html","content":"来源引用自 https://juejin.cn/post/7204756153414041637 Javascript ErrorSyntax Error 语法错误 词法、语法分析转换生成语法树时发生，此类异常一旦发生，导致整个 js 文件无法执行： const 1xx runtime error：JSON.parse(&#39;&#39;) Reference Error 引用错误const a = xxx; // ReferenceError: xxx is not defined Type Error 类型错误121() // TypeError: 1 is not a functionconst a = new 111() // TypeError: 111 is not a constructor Range Error 边界错误1;[].length = -1 // RangeError: Invalid array length URI Error调用 URI 相关函数中出现，包括 encodeURI、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和 unescape() 1decodeURI(&#x27;%&#x27;) // URIError: URI malformed 自定义错误继承 Error 实现 12345678910class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = &#x27;MyError&#x27;; &#125;&#125;function() &#123; throw new MyError(&#x27;error message&#x27;); // MyError: error message&#125; React-Native 中错误处理错误处理包括 JS 和 native 两部分，由 JS 捕获，抛给 Native 处理 JS 部分MessageQueue 消息队列Native 和 JS 通信的消息队列, 负责 Native 和 JS 通讯, 包括渲染、交互、各种互相调用等。所有的通信都会经过_guard 函数处理，在_guard 中会被 try-catch 住，出现异常后调用 ErrorUtils 处理 123456789101112// react-native/Libraries/BatchedBridge/MessageQueue.js__guard(fn: () =&gt; void) &#123; if (this.__shouldPauseOnThrow()) &#123; fn(); &#125; else &#123; try &#123; fn(); &#125; catch (error) &#123; ErrorUtils.reportFatalError(error); // 捕获异常，交给ErrorUtils &#125; &#125;&#125; ErrorUtilsErrorUtils 用于处理 RN 中所有的异常，它对暴露异常处理拦截接口 异常上报收到异常后调用_globalHandler 处理异常 123456789// 处理非fatal异常reportError(error: mixed): void &#123; _globalHandler &amp;&amp; _globalHandler(error, false);&#125;,// 处理fatal异常reportFatalError(error: mixed): void &#123; _globalHandler &amp;&amp; _globalHandler(error, true);&#125;, 异常处理所有异常通过_globalHandle 函数处理，默认情况下_globalHandler 会直接将错误抛出，ErrorUtils 对外提供了 setGlobalHanlder 做错误拦截处理，RN 重写_globalHandler 来做错误收集和处理 123456789101112131415// react-native/Libraries/polyfills/error-guard.jslet _globalHandler: ErrorHandler = function onError( e: mixed, isFatal: boolean,) &#123; throw e;&#125;;setGlobalHandler(fun: ErrorHandler): void &#123; _globalHandler = fun;&#125;,getGlobalHandler(): ErrorHandler &#123; return _globalHandler;&#125;, ExceptionsManagerExceptionsManager 是 RN 中异常管理模块，负责红屏处理、console.error、并将异常传给 Native 侧 异常处理器设置 调用 ErrorUtils.setGlobalHandler，把错误处理实现交给 ExceptionsManager.handleException console.error 处理：调用 ExceptionsManager.installConsoleErrorReporter 重写 console.error 12345678910111213141516171819// react-native/Libraries/Core/setUpErrorHandling.jsconst ExceptionsManager = require(&#x27;./ExceptionsManager&#x27;)// Set up console.error handlerExceptionsManager.installConsoleErrorReporter()// Set up error handlerif (!global.__fbDisableExceptionsManager) &#123; const handleError = (e, isFatal) =&gt; &#123; try &#123; ExceptionsManager.handleException(e, isFatal) &#125; catch (ee) &#123; console.log(&#x27;Failed to print error: &#x27;, ee.message) throw e &#125; &#125; const ErrorUtils = require(&#x27;../vendor/core/ErrorUtils&#x27;) ErrorUtils.setGlobalHandler(handleError)&#125; ExceptionsManager 处理异常 构建 Error：如果错误不是 Error 类型，构造一个 SyntheticError，方便日志输出和展示 调用错误处理 NativeExceptionsManager 调用 native 模块上报错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function handleException(e: mixed, isFatal: boolean) &#123; let error: Error if (e instanceof Error) &#123; error = e &#125; else &#123; error = new SyntheticError(e) &#125; reportException(error, isFatal)&#125;function reportException(e: ExtendedError, isFatal: boolean) &#123; const NativeExceptionsManager = require(&#x27;./NativeExceptionsManager&#x27;).default if (NativeExceptionsManager) &#123; // 解析错误，获取错误信息、堆栈 const parseErrorStack = require(&#x27;./Devtools/parseErrorStack&#x27;) const stack = parseErrorStack(e) const currentExceptionID = ++exceptionID const originalMessage = e.message || &#x27;&#x27; let message = originalMessage if (e.componentStack != null) &#123; message += ` This error is located at:$&#123;e.componentStack&#125;` &#125; const namePrefix = e.name == null || e.name === &#x27;&#x27; ? &#x27;&#x27; : `$&#123;e.name&#125;: ` const isFromConsoleError = e.name === &#x27;console.error&#x27; if (!message.startsWith(namePrefix)) &#123; message = namePrefix + message &#125; // 如果是console.error则输出 if (!isFromConsoleError) &#123; if (console._errorOriginal) &#123; console._errorOriginal(message) &#125; else &#123; console.error(message) &#125; &#125; message = e.jsEngine == null ? message : `$&#123;message&#125;, js engine: $&#123;e.jsEngine&#125;` // 抑制（不展示）红屏，不展示native红屏弹窗，forceRedbox默认为false const isHandledByLogBox = e.forceRedbox !== true &amp;&amp; global.__unstable_isLogBoxEnabled === true const data = preprocessException(&#123; message, originalMessage: message === originalMessage ? null : originalMessage, name: e.name == null || e.name === &#x27;&#x27; ? null : e.name, componentStack: typeof e.componentStack === &#x27;string&#x27; ? e.componentStack : null, stack, id: currentExceptionID, isFatal, extraData: &#123; jsEngine: e.jsEngine, rawStack: e.stack, // Hack to hide native redboxes when in the LogBox experiment. // This is intentionally untyped and stuffed here, because it is temporary. suppressRedBox: isHandledByLogBox, &#125;, &#125;) // 如果抑制native红屏，展示JS红屏提示错误 if (isHandledByLogBox) &#123; LogBoxData.addException(&#123; ...data, isComponentError: !!e.isComponentError, &#125;) &#125; // 把调用NativeExceptionsManager上报给native NativeExceptionsManager.reportException(data) &#125;&#125;// Native导出类，以Android为例，对应ExceptionsManagerModule.javaconst NativeModule = TurboModuleRegistry.getEnforcing&lt;Spec&gt;( &#x27;ExceptionsManager&#x27;,);const ExceptionsManager&#123; // 判断是否是fatal调用不同函数上报\treportException(data: ExceptionData): void &#123; if (data.isFatal) &#123; ExceptionsManager.reportFatalException(data.message, data.stack, data.id); &#125; else &#123; ExceptionsManager.reportSoftException(data.message, data.stack, data.id); &#125; &#125;, // 上报fatal异常 reportFatalException( message: string, stack: Array&lt;StackFrame&gt;, exceptionId: number, ) &#123; NativeModule.reportFatalException(message, stack, exceptionId); &#125;, // 上报soft异常\treportSoftException( message: string, stack: Array&lt;StackFrame&gt;, exceptionId: number, ) &#123; NativeModule.reportSoftException(message, stack, exceptionId); &#125;, // Android提供关闭红屏函数\tdismissRedbox(): void &#123; if (Platform.OS !== &#x27;ios&#x27; &amp;&amp; NativeModule.dismissRedbox) &#123; // TODO(T53311281): This is a noop on iOS now. Implement it. NativeModule.dismissRedbox(); &#125; &#125;,&#125; console.error 处理调用 ExceptionsManager.installConsoleErrorReporter 处理 console.error，处理成非 fatal 异常 123456789101112131415161718192021222324252627282930313233// react-native/Libraries/Core/ExceptionsManager.jsfunction installConsoleErrorReporter() &#123; // 如果设置过，return if (console._errorOriginal) &#123; return // already installed &#125; console._errorOriginal = console.error.bind(console) // 设置console.error处理函数 console.error = reactConsoleErrorHandler if (console.reportErrorsAsExceptions === undefined) &#123; console.reportErrorsAsExceptions = true &#125;&#125;// console.error处理函数，最终调用reportException上报成非fatal异常function reactConsoleErrorHandler() &#123; if (arguments[0] &amp;&amp; arguments[0].stack) &#123; // 上报 reportException(arguments[0], /* isFatal */ false) &#125; else &#123; // 构造一个SyntheticError const stringifySafe = require(&#x27;../Utilities/stringifySafe&#x27;) const str = Array.prototype.map .call(arguments, (value) =&gt; typeof value === &#x27;string&#x27; ? value : stringifySafe(value), ) .join(&#x27; &#x27;) const error: ExtendedError = new SyntheticError(str) error.name = &#x27;console.error&#x27; // 上报 reportException(error, /* isFatal */ false) &#125;&#125; 跟进上述源码可知，通过 isHandledByLogBox 参数可以禁止 native 红屏弹窗，isHandledByLogBox 是通过 global.__unstable_isLogBoxEnabled 控制，可以通过下面方式禁止 native 红屏展示，但是还是会展示 js 红屏来提示错误 12global.__unstable_isLogBoxEnabled = trueYellowBox.__unstable_enableLogBox() // 内部调用了上面的代码 Native 部分ExceptionsManagerModuleExceptionsManagerModule 是 native 处理异常模块，导出给 JS 类名为 ExceptionsManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 上报fatal异常@ReactMethodpublic void reportFatalException(String message, ReadableArray stack, int id) &#123; JavaOnlyMap data = new JavaOnlyMap(); data.putString(&quot;message&quot;, message); data.putArray(&quot;stack&quot;, stack); data.putInt(&quot;id&quot;, id); data.putBoolean(&quot;isFatal&quot;, true); reportException(data);&#125;// 上报soft异常@ReactMethodpublic void reportSoftException(String message, ReadableArray stack, int id) &#123; JavaOnlyMap data = new JavaOnlyMap(); data.putString(&quot;message&quot;, message); data.putArray(&quot;stack&quot;, stack); data.putInt(&quot;id&quot;, id); data.putBoolean(&quot;isFatal&quot;, false); reportException(data);&#125;// 最终调用reportException@ReactMethodpublic void reportException(ReadableMap data) &#123; // 错误堆栈 String message = data.hasKey(&quot;message&quot;) ? data.getString(&quot;message&quot;) : &quot;&quot;; ReadableArray stack = data.hasKey(&quot;stack&quot;) ? data.getArray(&quot;stack&quot;) : Arguments.createArray(); int id = data.hasKey(&quot;id&quot;) ? data.getInt(&quot;id&quot;) : -1; boolean isFatal = data.hasKey(&quot;isFatal&quot;) ? data.getBoolean(&quot;isFatal&quot;) : false; // dev模式，展示红屏dialog if (mDevSupportManager.getDevSupportEnabled()) &#123; // 获取是否抑制红屏参数，对应js侧传入的isHandledByLogBox boolean suppressRedBox = false; if (data.getMap(&quot;extraData&quot;) != null &amp;&amp; data.getMap(&quot;extraData&quot;).hasKey(&quot;suppressRedBox&quot;)) &#123; suppressRedBox = data.getMap(&quot;extraData&quot;).getBoolean(&quot;suppressRedBox&quot;); &#125; if (!suppressRedBox) &#123; mDevSupportManager.showNewJSError(message, stack, id); // 显示红屏弹窗 &#125; &#125; else &#123; // fatal抛出JavascriptException异常，非fatal打印出来 if (isFatal) &#123; throw new JavascriptException(jsStackTrace) .setExtraDataAsJson(extraDataAsJson); &#125; else &#123; logException(jsStackTrace, extraDataAsJson); &#125; &#125;&#125;@ReactMethodpublic void dismissRedbox() &#123; if (mDevSupportManager.getDevSupportEnabled()) &#123; mDevSupportManager.hideRedboxDialog(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 上报soft异常- (void)reportSoft: (NSString *)message stack:(NSArray&lt;NSDictionary *&gt; *)stack exceptionId:(double)exceptionId suppressRedBox: (BOOL) suppressRedBox &#123; if (!suppressRedBox) &#123; [_bridge.redBox showErrorMessage:message withStack:stack errorCookie:((int)exceptionId)]; &#125; if (_delegate) &#123; [_delegate handleSoftJSExceptionWithMessage:message stack:stack exceptionId:[NSNumber numberWithDouble:exceptionId]]; &#125;&#125;// 上报fatal异常- (void)reportFatal: (NSString *)message stack:(NSArray&lt;NSDictionary *&gt; *)stack exceptionId:(double)exceptionId suppressRedBox: (BOOL) suppressRedBox &#123; if (!suppressRedBox) &#123; [_bridge.redBox showErrorMessage:message withStack:stack errorCookie:((int)exceptionId)]; &#125; if (_delegate) &#123; [_delegate handleFatalJSExceptionWithMessage:message stack:stack exceptionId:[NSNumber numberWithDouble:exceptionId]]; &#125; static NSUInteger reloadRetries = 0; if (!RCT_DEBUG &amp;&amp; reloadRetries &lt; _maxReloadAttempts) &#123; reloadRetries++; RCTTriggerReloadCommandListeners(@&quot;JS Crash Reload&quot;); &#125; else if (!RCT_DEV || !suppressRedBox) &#123; NSString *description = [@&quot;Unhandled JS Exception: &quot; stringByAppendingString:message]; NSDictionary *errorInfo = @&#123; NSLocalizedDescriptionKey: description, RCTJSStackTraceKey: stack &#125;; RCTFatal([NSError errorWithDomain:RCTErrorDomain code:0 userInfo:errorInfo]); &#125;&#125;// reportExceptionRCT_EXPORT_METHOD(reportException:(JS::NativeExceptionsManager::ExceptionData &amp;)data)&#123; NSString *message = data.message(); double exceptionId = data.id_(); id&lt;NSObject&gt; extraData = data.extraData(); // Reserialize data.stack() into an array of untyped dictionaries. // TODO: (moti) T53588496 Replace `(NSArray&lt;NSDictionary *&gt; *)stack` in // reportFatalException etc with a typed interface. NSMutableArray&lt;NSDictionary *&gt; *stackArray = [NSMutableArray&lt;NSDictionary *&gt; new]; for (auto frame: data.stack()) &#123; NSMutableDictionary * frameDict = [NSMutableDictionary new]; if (frame.column().hasValue()) &#123; frameDict[@&quot;column&quot;] = @(frame.column().value()); &#125; frameDict[@&quot;file&quot;] = frame.file(); if (frame.lineNumber().hasValue()) &#123; frameDict[@&quot;lineNumber&quot;] = @(frame.lineNumber().value()); &#125; frameDict[@&quot;methodName&quot;] = frame.methodName(); if (frame.collapse().hasValue()) &#123; frameDict[@&quot;collapse&quot;] = @(frame.collapse().value()); &#125; [stackArray addObject:frameDict]; &#125; NSDictionary *dict = (NSDictionary *)extraData; BOOL suppressRedBox = [[dict objectForKey:@&quot;suppressRedBox&quot;] boolValue]; if (data.isFatal()) &#123; [self reportFatal:message stack:stackArray exceptionId:exceptionId suppressRedBox:suppressRedBox]; &#125; else &#123; [self reportSoft:message stack:stackArray exceptionId:exceptionId suppressRedBox:suppressRedBox]; &#125;&#125; DevSupportManager 处理红屏 12345678910111213141516171819202122232425262728293031@Override public void showNewJavaError(@Nullable String message, Throwable e) &#123; FLog.e(ReactConstants.TAG, &quot;Exception in native call&quot;, e); showNewError( message, StackTraceHelper.convertJavaStackTrace(e), JAVA_ERROR_COOKIE, ErrorType.NATIVE); &#125;// 展示红屏弹窗private void showNewError( @Nullable final String message, final StackFrame[] stack, final int errorCookie, final ErrorType errorType) &#123; UiThreadUtil.runOnUiThread( new Runnable() &#123; @Override public void run() &#123; if (mRedBoxDialog == null) &#123; Activity context = mReactInstanceManagerHelper.getCurrentActivity(); mRedBoxDialog = new RedBoxDialog(context, DevSupportManagerImpl.this, mRedBoxHandler); &#125; if (mRedBoxDialog.isShowing()) &#123; return; &#125; Pair&lt;String, StackFrame[]&gt; errorInfo = processErrorCustomizers(Pair.create(message, stack)); mRedBoxDialog.setExceptionDetails(errorInfo.first, errorInfo.second); mRedBoxDialog.resetReporting(); mRedBoxDialog.show(); &#125; &#125;); &#125; 线程异常捕获（Android）Handle 捕获异常RN 引擎创建的时候会初始化三个线程，UiThread、NativeModulesThread、JSThread，这些线程通过 MessageQueueThreadHandler 处理消息队列，MessageQueueThreadHandler 重写了 Handle 的 dispatchMessage 函数，函数通过 try-catch 包裹防止应用直接退出，出现异常时调用 QueueThreadExceptionHandler 处理（引擎实现此接口），这里能拦截所有的异常，包括上述 js 捕获传到 native 手动抛出的、yoga 布局过程中的等等。 12345678910111213141516public class MessageQueueThreadHandler extends Handler &#123; private final QueueThreadExceptionHandler mExceptionHandler; public MessageQueueThreadHandler(Looper looper, QueueThreadExceptionHandler exceptionHandler) &#123; super(looper); mExceptionHandler = exceptionHandler; &#125; @Override public void dispatchMessage(Message msg) &#123; try &#123; super.dispatchMessage(msg); &#125; catch (Exception e) &#123; mExceptionHandler.handleException(e); &#125; &#125;&#125; 引擎处理异常在引擎（CatalystInstanceImpl）的内部类 NativeExceptionHandler 中，实现了 QueueThreadExceptionHandler 接口，在引擎创建时初始化，出现异常时调用 NativeModuleCallExceptionHandler 处理，并销毁引擎。 12345678910111213141516171819202122232425262728293031323334353637383940// com.facebook.react.bridge.CatalystInstanceImpl（引擎实现类）// 内部类实现QueueThreadExceptionHandler，叫异常交给引擎的onNativeException处理private static class NativeExceptionHandler implements QueueThreadExceptionHandler &#123; @Override public void handleException(Exception e) &#123; if (ReactFeatureFlags.enableCatalystCleanupFix) &#123; CatalystInstanceImpl catalystInstance = mCatalystInstanceImplWeak.get(); if (catalystInstance != null) &#123; catalystInstance.onNativeException(e); &#125; &#125; else &#123; mCatalystInstanceImpl.onNativeException(e); &#125; &#125; &#125;// 调用NativeModuleCallExceptionHandler处理异常，并销毁引擎private void onNativeException(Exception e) &#123; mHasNativeError.set(true); boolean isAlive = !mDestroyed; if (isAlive) &#123; mNativeModuleCallExceptionHandler.handleException(e); &#125; mReactQueueConfiguration .getUIQueueThread() .runOnQueue( new Runnable() &#123; @Override public void run() &#123; // 销毁引擎 destroy(() -&gt; &#123; if (mDestroyFinishedCallback != null) &#123; mDestroyFinishedCallback.onDestroyFinished(); mDestroyFinishedCallback = null; &#125; &#125;); &#125; &#125;); &#125; 最终的异常处理默认处理方式引擎捕获异常后会调用 NativeModuleCallExceptionHandler.handleException 处理，它是个接口，引擎提供了默认实现类，默认实现类收到异常后是直接抛出，会导致应用退出。 123456789101112131415161718192021222324252627public interface NativeModuleCallExceptionHandler &#123; /** Do something to display or log the exception. */ void handleException(Exception e); void handleCaughtException(Exception e);&#125;// 默认实现类public class DefaultNativeModuleCallExceptionHandler implements NativeModuleCallExceptionHandler &#123; @Override public void handleException(Exception e) &#123; if (e instanceof RuntimeException) &#123; // Because we are rethrowing the original exception, the original stacktrace will be // preserved. throw (RuntimeException) e; &#125; else &#123; throw new RuntimeException(e); &#125; &#125; @Override public void handleCaughtException(Exception e) &#123; e.printStackTrace(); &#125;&#125; 自定义异常处理为了防止默认处理方式将异常直接抛出导致 crash，业务可以实现自定义的 NativeModuleCallExceptionHandler 接口来处理异常，将异常上报，并展示错误兜底页面。 整体流程基于上述源码解析可知，RN 错误采集流程由 JS 侧中 MessageQueue 发起，经过一系列处理和封装，传到 native 侧，再经过 native 一系列转发，最终交给由引擎（CatalyInstanceImple）处理，整体流程如下图所示 错误兜底页面出现异常后，对异常状态兜底是一种保障线上质量的常规手段。当页面发生严重 JS 错误（FatalError）时，会展示错误页面无法继续使用。这种方式在一些业务场景下并不友好。比如：页面上某一个次要模块发生异常，并不影响核心功能的使用，这种情况下展示出错页面有些不必要React 16 中引入了一个新概念——错误边界（Error Boundaries）。错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界能在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误基于这个特性，业务能够自定义控制接收到 JSError 的行为，能更优雅地处理错误兜底及展示 什么是错误边界错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JS 错误，并且它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界能在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。 错误边界的关键模块错误边界是通过 try-catch 方式捕获异常的，它在哪里进行捕获异常的呢？React 有三个重要组成模块，错误边界在 Reconciliation 中对异常进行捕获。 React 基础模块（这个模块定义了 React 的基础 API 及组件相关内容。对应我们开发页面时引入的 ‘react’ 模块） 渲染模块（这个模块对于不同类型的应用，采用不同的渲染方式。对应我们开发页面时引入的 ‘react-dom’ 模块） Reconciliation 模块（又叫“协调模块”，这个模块是上面两个模块的基础，主要负责任务协调、生命周期函数管理等） ReconciliationReconciliation 模块是 React 三个重要模块之一，又叫“协调模块”，这个模块是上面两个模块的基础，主要负责任务协调、生命周期函数管理等，它分为 render 和 commit 两个阶段 render 阶段：简单来说就是找到需要更新的工作，通过 Diff Fiber Tree 找出要做的更新工作，这是一个 js 计算过程，计算结果可以被缓存，计算过程可以被打断，也可以恢复执行。 commit 阶段：提交更新并调用对应渲染模块（react-dom）进行渲染，为了防止页面抖动，该过程是同步且不能被打断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// react-native/Libraries/Renderer/ReactFabric-dev.js// Reconciliation阶段开始，render阶段，performSyncWorkOnRoot（同步更新）、performConcurrentWorkOnRoot（异步）function performSyncWorkOnRoot(root) &#123; do &#123; try &#123; workLoopSync(); break; &#125; catch (thrownValue) &#123; handleError(root, thrownValue); &#125; &#125; while (true);&#125;function handleError(root, thrownValue) &#123; do &#123; try &#123; throwException( root, workInProgress.return, workInProgress, thrownValue, renderExpirationTime ); workInProgress = completeUnitOfWork(workInProgress); &#125; catch (yetAnotherThrownValue) &#123; thrownValue = yetAnotherThrownValue; continue; &#125; // Return to the normal work loop. return; &#125; while (true);&#125;function throwException( root, returnFiber, sourceFiber, value, renderExpirationTime) &#123; case ClassComponent: var _update2 = createClassErrorUpdate( workInProgress, errorInfo, renderExpirationTime ); enqueueCapturedUpdate(workInProgress, _update2); return;&#125;function createClassErrorUpdate(fiber, errorInfo, expirationTime) &#123; var update = createUpdate(expirationTime, null); update.tag = CaptureUpdate; var getDerivedStateFromError = fiber.type.getDerivedStateFromError; if (typeof getDerivedStateFromError === &quot;function&quot;) &#123; var error = errorInfo.value; update.payload = function() &#123; logError(fiber, errorInfo); return getDerivedStateFromError(error); &#125;; &#125; var inst = fiber.stateNode; if (inst !== null &amp;&amp; typeof inst.componentDidCatch === &quot;function&quot;) &#123; update.callback = function callback() &#123; &#123; markFailedErrorBoundaryForHotReloading(fiber); &#125; if (typeof getDerivedStateFromError !== &quot;function&quot;) &#123; markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined logError(fiber, errorInfo); &#125; var error = errorInfo.value; var stack = errorInfo.stack; this.componentDidCatch(error, &#123; componentStack: stack !== null ? stack : &quot;&quot; &#125;); &#123; if (typeof getDerivedStateFromError !== &quot;function&quot;) &#123; !(fiber.expirationTime === Sync) ? warningWithoutStack$1( false, &quot;%s: Error boundaries should implement getDerivedStateFromError(). &quot; + &quot;In that method, return a state update to display an error message or fallback UI.&quot;, getComponentName(fiber.type) || &quot;Unknown&quot; ) : void 0; &#125; &#125; &#125;; &#125; else &#123; update.callback = function() &#123; markFailedErrorBoundaryForHotReloading(fiber); &#125;; &#125; return update;&#125; 错误边界不支持 hooks 组件，因为错误边界的实现借助了 this.setState 可以传递 callback 的特性，useState 无法传入回调，所以无法完全对标 错误边界的使用如何定义一个错误边界如果一个组件重写了特定的方法，这个组件就是一个错误边界组件。定义：如果一个类组件定义了生命周期方法中的任何一个（或两个）static getDerivedStateFromError() 或 componentDidCatch()，那么它就成了一个错误边界。 使用 static getDerivedStateFromError()在抛出错误后渲染回退 UI。 使用 componentDidCatch() 来记录错误信息。如下： 123456789101112131415161718192021222324252627282930313233export class ErrorBoundary extends Component&lt;IProps, IState&gt; &#123; constructor(props) &#123; super(props) this.state = &#123; hasError: false, &#125; &#125; /** * 捕获异常，展示兜底控件。 * @param _error */ static getDerivedStateFromError(_error) &#123; return &#123; hasError: true, &#125; &#125; /** * * @param error 错误信息 */ componentDidCatch(error: Error) &#123; // 上报错误 &#125; render() &#123; if (this.state.hasError) &#123; return &lt;Text style=&#123;style.errorDesc&#125;&gt;出错了&lt;/Text&gt; &#125; return this.props.children &#125;&#125; 如何使用错误边界将要捕获的组件用错误边界组件包裹 1234567891011121314151617export default class Example extends PureComponent&lt;Props, State&gt; &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ErrorBoundary&gt;&#123;this.renderErrorBlock()&#125;&lt;/ErrorBoundary&gt; &lt;Text style=&#123;styles.other&#125;&gt;other block&lt;/Text&gt; &lt;/View&gt; ) &#125; renderErrorBlock = () =&gt; &#123; return ( &lt;View style=&#123;styles.errorBoundary&#125;&gt; &#x27;&#x27; &amp;&amp; &lt;Text style=&#123;styles.error&#125;&gt;error block&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; 适用范围错误边界不能捕获哪些异常 事件处理：点击事件 异步代码：setTimeout 或 requestAnimationFrame 回调函数等 错误边界自身抛出的错误 建议使用场景 将影响整体页面展示逻辑的模块使用错误边界包裹并设置宽高，防止其他模块计算出错 将非核心模块包裹，保障在非核心模块出错时核心模块展示不受影响 包裹外部依赖的组件，防止意外的错误 包裹独立展示模块，如广告，活动弹窗等"},{"title":"React-旧的架构","path":"/frontend/React-旧的架构.html","content":"在上一节中我们了解了React的理念，简单概括就是快速响应。 React从 v15 升级到 v16 后重构了整个架构。本节我们聊聊 v15，看看他为什么不能满足快速响应的理念，以至于被重构。 React15 架构React15 架构可以分为两层： Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Reconciler（协调器）我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等 API 触发更新。 每当有更新发生时，Reconciler 会做如下工作： 调用函数组件、或 class 组件的render方法，将返回的 JSX 转化为虚拟 DOM 将虚拟 DOM 和上次更新时的虚拟 DOM 对比 通过对比找出本次更新中变化的虚拟 DOM 通知 Renderer 将变化的虚拟 DOM 渲染到页面上 你可以在这里 (opens new window)看到React官方对 Reconciler 的解释 Renderer（渲染器）由于React支持跨平台，所以不同平台有不同的 Renderer。我们前端最熟悉的是负责在浏览器环境渲染的 Renderer —— ReactDOM (opens new window)。 除此之外，还有： ReactNative (opens new window)渲染器，渲染 App 原生组件 ReactTest (opens new window)渲染器，渲染出纯 Js 对象用于测试 ReactArt (opens new window)渲染器，渲染到 Canvas, SVG 或 VML (IE8) 在每次更新发生时，Renderer 接到 Reconciler 通知，将变化的组件渲染在当前宿主环境。 你可以在这里 (opens new window)看到React官方对 Renderer 的解释 React15 架构的缺点在 Reconciler 中，mount的组件会调用mountComponent (opens new window)，update的组件会调用updateComponent (opens new window)。这两个方法都会递归更新子组件。 递归更新的缺点由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。 在上一节中，我们已经提出了解决办法——用可中断的异步更新代替同步的更新。那么 React15 的架构支持异步更新么？让我们看一个例子： 我用红色标注了更新的步骤。 我们可以看到，Reconciler 和 Renderer 是交替工作的，当第一个li在页面上已经变化后，第二个li再进入 Reconciler。 由于整个过程都是同步的，所以在用户看来所有 DOM 是同时更新的。 接下来，让我们模拟一下，如果中途中断更新会怎么样？ 当第一个li完成更新时中断更新，即步骤 3 完成后中断更新，此时后面的步骤都还未执行。 用户本来期望123变为246。实际却看见更新不完全的 DOM！（即223） 基于这个原因，React决定重写整个架构。"},{"title":"React-native 环境","path":"/frontend/React-native 环境.html","content":"安装 iOS 依赖12pod install --verbose --no-repo-updatecocopads 最好和项目中的版本一致 打包安卓 release 版本1234567891011121314cd android# build google release./gradlew assembleGoogleRelease# pwd build fileapp/build/outputs/apk/google/release/# build google aab./gradlew bundleGoogleRelease# pwb google aabapp/build/outputs/bundle/googleRelease/# runcd ..npx react-native run-android --variant=release android gradle 版本设置1android studio -&gt; 右上角setting -&gt; project structure -&gt; project -&gt; Gradle Version 选择项目中对应版本 SDK 版本设置12setting -&gt; build tools -&gt; gradle -&gt; gradle project -&gt; gradle JDK使用项目对应的版本 gradle 更新依赖12file -&gt; sync project with gradle files需要连接国际互联网"},{"title":"实现JS compiler","path":"/frontend/实现JS compiler.html","content":"实现一个最小的JS编译器本文实现一个List-Style function call转化为C-Style的compiler。 natual language Lisp(prefix expression) C(function call) 2 + 2 (add 2 2) add(2, 2) 4 - 2 (substract 4 2) substract(4, 2) 2 + (4 - 2) (add 2 (substract(4 2)) add(2, substract(4, 2)) Compiler需要做什么工作 Parsing：将source code转化为更抽象的代码表示（AST）。 Transformation：对parsing后的代码，做一些转换操作（静态分析，代码优化）。 Code Generation：将转换后的代码生成新的所需代码。 Parsing 阶段Parsing通常分为两个阶段： 词法分析（lexical analysis）：获取原始代码并通过称为标记器（tokenizer）（或词法分析器（lexer））将其拆分为标记（Token）。 标记是一组微小的小对象，它们描述了语法的一个孤立部分。 它们可以是数字、标签、标点符号、运算符等等。 语法分析（syntax analysis）将Token重新格式化为描述语法的每个部分及其相互关系的表示，称为中间表示（representation）或抽象语法树（Abstract Syntax Tree）。 JS的在线parse网站 现在来看下面的代码： (add 2 (subtract 4 2)) 经过词法分析后，得到它的token： 1234567891011[ &#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;, &#123; type: &#x27;name&#x27;, value: &#x27;add&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;, &#123; type: &#x27;name&#x27;, value: &#x27;subtract&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;,] 它的AST长这样： 123456789101112131415161718192021&#123; type: &#x27;Program&#x27;, body: [&#123; type: &#x27;CallExpression&#x27;, name: &#x27;add&#x27;, params: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27;, &#125;, &#123; type: &#x27;CallExpression&#x27;, name: &#x27;subtract&#x27;, params: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;4&#x27;, &#125;, &#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27;, &#125;] &#125;] &#125;]&#125; 我们通过AST就可以发现代码执行顺序： 1. 进入程序2. 函数调用（add）- 进入 Program 的 body 的第一个对象3. 数字 - 来到 add 函数的 params 的第一个对象4. 函数调用（substract） - 来到 add 函数的 params 的第二个对象5. 数字 - 来到 substract 函数的 params 的第一个对象6. 数字 - 来到 substract 函数的 params 的第二个对象 通过遍历这个AST对象，我们就可以完成我们想要完成的操作。 Visitor为了遍历AST，我们可以创建一个 visitor 。我们需要针对不同的Token去调用不同的方法，同时为了方便，我们把 node 和他的 parent 也一起交给访问方法。 1234var visitor = &#123; NumberLiteral(node, parent) &#123; &#125;, CallExpression(node, parent) &#123; &#125;&#125; 现在，我们可以来描述AST的基本流程： 1. → Program (enter)2. → CallExpression (enter)3. → NumberLiteral (enter)4. ← NumberLiteral (exit)5. → CallExpression (enter)6. → NumberLiteral (enter)7. ← NumberLiteral (exit)8. → NumberLiteral (enter)9. ← NumberLiteral (exit)10. ← CallExpression (exit)11. ← CallExpression (exit)12. ← Program (exit) 所以我们需要去改造我们的 visitor： 12345678910var visitor = &#123; NumberLiteral: &#123; enter(node, parent) &#123; &#125;, exit(node, parent) &#123; &#125; &#125;, CallExpression: &#123; enter(node, parent) &#123; &#125;, exit(node, parent) &#123; &#125; &#125;&#125; 代码生成阶段编译器的最后阶段是代码生成。 有时编译器会做一些与转换之类的事情，但在大多数情况下，代码生成只是意味着将我们的 AST 和 String-ify code 取出来。 代码生成器有几种不同的工作方式，一些编译器会重用之前的Token，另一些编译器会创建代码的单独表示，以便它们可以线性地打印节点，但大多数将使用我们刚刚创建的相同 AST。 实际上，我们的代码生成器将知道如何“打印”AST 的所有不同节点类型，并且它将递归调用自身以打印嵌套节点，直到将所有内容输出成一长串目标代码。 现在我们就可以着手写自己的 compiler。 Source Codecompiler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/** * @author Edward &lt;wang.huiyang@outlook.com&gt; */&#x27;use strict&#x27;/** * 返回所有的 Token * @param &#123;string&#125; input - the code * @returns &#123;Token[]&#125; tokens */function tokenizer(input) &#123; let current = 0 // 目前所在位置 let tokens = [] // 存放所有 Token 的数组 const LEN = input.length while (current &lt; LEN) &#123; let char = input[current] // 拿到当前的字符 if (char === &#x27;(&#x27;) &#123; tokens.push(&#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;) current++ continue &#125; if (char === &#x27;)&#x27;) &#123; tokens.push(&#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;) current++ continue &#125; const WHITE_SPACE = /\\s/ if (WHITE_SPACE.test(char)) &#123; // 不处理空白字符 current++ continue &#125; // (add 1321 12341) let NUMBERS = /[0-9]/ if (NUMBERS.test(char)) &#123; let value = &#x27;&#x27; // 需要集中处理 // eg: 12341，得到1之后，2341需要一次读入 while (NUMBERS.test(char)) &#123; value += char char = input[++current] &#125; tokens.push(&#123; type: &#x27;number&#x27;, value &#125;) continue &#125; // (concat &quot;test&quot; &quot;foo&quot;) if (char === &#x27;&quot;&#x27;) &#123; let value = &#x27;&#x27; // 跳过 &quot; char = input[++current] while (char !== &#x27;&quot;&#x27;) &#123; value += char char = input[++current] &#125; // 跳过 &quot; char = input[++current] tokens.push(&#123; type: &#x27;string&#x27;, value &#125;) continue &#125; let LETTERS = /[a-z]/i if (LETTERS.test(char)) &#123; let value = &#x27;&#x27; while (LETTERS.test(char)) &#123; value += char char = input[++current] &#125; tokens.push(&#123; type: &#x27;name&#x27;, value &#125;) continue &#125; throw new TypeError(`Can&#x27;t parse this character: $&#123;char&#125;`) &#125; return tokens&#125;/** * parse tokens to AST. * @param &#123;Tokens&#125; tokens - the tokens. */function parser(tokens) &#123; let current = 0 function run() &#123; let token = tokens[current] // Number node if (token.type === &#x27;number&#x27;) &#123; current++ return &#123; type: &#x27;NumberLiteral&#x27;, value: token.value &#125; &#125; // String node if (token.type === &#x27;string&#x27;) &#123; current++ return &#123; type: &#x27;StringLiteral&#x27;, value: token.value &#125; &#125; // CallExpression if (token.type === &#x27;paren&#x27; &amp;&amp; token.value === &#x27;(&#x27;) &#123; token = tokens[++current] let node = &#123; type: &#x27;CallExpression&#x27;, name: token.value, params: [] &#125; token = tokens[++current] // focus here while ((token.type !== &#x27;paren&#x27;) || (token.type === &#x27;paren&#x27; &amp;&amp; token.value !== &#x27;)&#x27;)) &#123; node.params.push(run()) // 在这一步的结尾，current指向的是未遍历的token token = tokens[current] // 所以需要在这里给token归位 &#125; current++ return node &#125; throw new TypeError(token.type) &#125; const ast = &#123; type: &#x27;Program&#x27;, body: [] &#125; while (current &lt; tokens.length) &#123; ast.body.push(run()) &#125; return ast&#125;/** * 使用visitor访问AST的节点。 * 根据文章中给出的定义，调用方式为： * traverse(ast, &#123; * Program: &#123; * enter(node, parent) &#123;&#125;, * exit(node, parent) &#123;&#125; * &#125; * // etc. * &#125;) * @param &#123;ASTNode&#125; ast - the ast node. * @param &#123;*&#125; visitor - the visitor */function traverse(ast, visitor) &#123; function traverseArray(array, parent) &#123; array.forEach(child =&gt; traverseNode(child, parent)) &#125; function traverseNode(node, parent) &#123; let methods = visitor[node.type] // 根据type去拿不同的访问方法 if (methods &amp;&amp; methods.enter) &#123; methods.enter(node, parent) &#125; switch (node.type) &#123; case &#x27;Program&#x27;: traverseArray(node.body, node) break case &#x27;CallExpression&#x27;: traverseArray(node.params, node) break case &#x27;NumberLiteral&#x27;: case &#x27;StringLiteral&#x27;: break default: throw new TypeError(node.type) &#125; if (methods &amp;&amp; methods.exit) &#123; methods.exit(node, parent) &#125; &#125; traverseNode(ast, null)&#125;/** * 将ast转换为所需要的ast节点。 * @param &#123;*&#125; ast - the ast node. */function transformer(ast) &#123; const newAst = &#123; type: &#x27;Program&#x27;, body: [] &#125; ast.__context = newAst.body traverse(ast, &#123; NumberLiteral: &#123; enter(node, parent) &#123; parent.__context.push(&#123; type: &#x27;NumberLiteral&#x27;, value: node.value &#125;) &#125; &#125;, StringLiteral: &#123; enter(node, parent) &#123; parent.__context.push(&#123; type: &#x27;StringLiteral&#x27;, value: node.value &#125;) &#125; &#125;, CallExpression: &#123; enter(node, parent) &#123; let expression = &#123; type: &#x27;CallExpression&#x27;, callee: &#123; type: &#x27;Identifier&#x27;, name: node.name &#125;, arguments: [] &#125; node.__context = expression.arguments // 如果parent不是函数调用，代表是一个表达式块 if (parent.type !== &#x27;CallExpression&#x27;) &#123; expression = &#123; type: &#x27;ExpressionStatement&#x27;, expression: expression &#125; &#125; parent.__context.push(expression) &#125; &#125; &#125;) return newAst&#125;/** * 代码生成器 * @param &#123;*&#125; node */function codeGenerator(node) &#123; switch (node.type) &#123; case &#x27;Program&#x27;: return node.body.map(codeGenerator).join(&#x27; &#x27;) case &#x27;ExpressionStatement&#x27;: return `$&#123;codeGenerator(node.expression)&#125;;` case &#x27;CallExpression&#x27;: return `$&#123;codeGenerator(node.callee)&#125;($&#123;node.arguments.map(codeGenerator).join(&#x27;,&#x27;)&#125;)` case &#x27;Identifier&#x27;: return node.name case &#x27;NumberLiteral&#x27;: return node.value case &#x27;StringLiteral&#x27;: return `&quot;$&#123;node.value&#125;&quot;` default: throw new TypeError(node.type) &#125;&#125;function compiler(input) &#123; const tokens = tokenizer(input) const ast = parser(tokens) const newAst = transformer(ast) const output = codeGenerator(newAst) return output&#125;module.exports = &#123; tokenizer, parser, traverse, transformer, codeGenerator, compiler&#125; test.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const &#123; tokenizer, parser, transformer, codeGenerator, compiler&#125; = require(&#x27;./compiler.js&#x27;)const assert = require(&#x27;assert&#x27;)const input = &#x27;(add 2 (subtract 4 2))&#x27;const output = &#x27;add(2,subtract(4,2));&#x27;const tokens = [ &#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;, &#123; type: &#x27;name&#x27;, value: &#x27;add&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;, &#123; type: &#x27;name&#x27;, value: &#x27;subtract&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;];const ast = &#123; type: &#x27;Program&#x27;, body: [&#123; type: &#x27;CallExpression&#x27;, name: &#x27;add&#x27;, params: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;CallExpression&#x27;, name: &#x27;subtract&#x27;, params: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;4&#x27; &#125;, &#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27; &#125;] &#125;] &#125;]&#125;;const newAst = &#123; type: &#x27;Program&#x27;, body: [&#123; type: &#x27;ExpressionStatement&#x27;, expression: &#123; type: &#x27;CallExpression&#x27;, callee: &#123; type: &#x27;Identifier&#x27;, name: &#x27;add&#x27; &#125;, arguments: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;CallExpression&#x27;, callee: &#123; type: &#x27;Identifier&#x27;, name: &#x27;subtract&#x27; &#125;, arguments: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;4&#x27; &#125;, &#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27; &#125;] &#125;] &#125; &#125;]&#125;;assert.deepStrictEqual(tokenizer(input), tokens, &#x27;Parse token incorrect!&#x27;)assert.deepStrictEqual(parser(tokens), ast, &#x27;Parser token to ast incorrect!&#x27;)assert.deepStrictEqual(transformer(ast), newAst, &#x27;Transform ast incorrect!&#x27;)assert.deepStrictEqual(codeGenerator(newAst), output, &#x27;CodeGenerator incorrect!&#x27;)assert.deepStrictEqual(compiler(input), output, &#x27;Compiler incorrect!&#x27;)console.log(&#x27;Pass!&#x27;); 结语JS中许多的中间件、代码转化、优化、埋点方案都是通过转化AST实现的。不同的是不需要自己去实现compiler，业界有一套规范的compiler API。你只需要使用他们的api，去转化成自己所需的AST，就可以得到自己想要的代码。例如：自己动手实现一个babel插件？"},{"title":"移动端适配 Layout.js","path":"/frontend/移动端适配 Layout.js.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import &#123; Platform, Dimensions, StyleSheet &#125; from &#x27;react-native&#x27;import &#123; getStatusBarHeight, getBottomSpace &#125; from &#x27;../Util/IPhoneXHelper&#x27;let &#123; width: windowWidth, height: windowHeight &#125; = Dimensions.get(&#x27;window&#x27;)// 全面屏手机 window.height 不包含 statusBar.height 不是真实的屏幕高度let &#123; width: screenWidth, height: screenHeight &#125; = Dimensions.get(&#x27;screen&#x27;)// 适配横屏if (windowWidth &gt; windowHeight) &#123; ;[windowWidth, windowHeight] = [windowHeight, windowWidth]&#125;if (screenWidth &gt; screenHeight) &#123; ;[screenWidth, screenHeight] = [screenHeight, screenWidth]&#125;//像素比例const ratio_750 = windowWidth / 750const ratio_1080 = windowWidth / 1080/** * 布局工具 */export default class Layout &#123; /** * 是否是Android平台 */ static isAndroid = Platform.OS === &#x27;android&#x27; /** * 边缘距离 */ static edgeSize = Layout.DP(32) /** * 分割线高度 */ static dividerHeight = StyleSheet.hairlineWidth /** * 标题字体大小 */ static titleSize = Layout.DP(28) /** * 值字体大小 */ static valueSize = Layout.DP(26) /** * 子标题字体大小 */ static subTitleSize = Layout.DP(24) /** * 底部安全距离 */ static bottomSaveSpace = getBottomSpace() /** * 状态栏高度 */ static statusBarHeight = getStatusBarHeight(true) /** * 导航栏高度 */ static navbarHeight = 44 /** * 导航栏+状态栏高度 */ static totalNavHeight = 44 + getStatusBarHeight(true) /** * 窗口宽度 */ static windowWidth = windowWidth /** * 窗口高度 */ static windowHeight = windowHeight /** * 屏幕宽度 */ static screenWidth = screenWidth /** * 屏幕高度 */ static screenHeight = screenHeight /** * px像素转换成react-native用的dp * @param &#123;*&#125; num 像素 * @param &#123;*&#125; ratio 像素比例，默认750 */ static DP(num, ratio = null) &#123; let _ratio = ratio_750 if (ratio) &#123; _ratio = ratio &#125; if (num === 1) &#123; return StyleSheet.hairlineWidth &#125; if (num === 0) &#123; return 0 &#125; return num * _ratio &#125; /** * px像素转换成react-native用的dp，1080比例 * @param &#123;*&#125; num 像素 */ static DP3(num) &#123; return Layout.DP(num, ratio_1080) &#125;&#125;"},{"title":"编写一个babel插件","path":"/frontend/编写一个babel插件.html","content":"前置知识：实现一个最小的 JS 编译器 因为从 0 开始实现过于复杂，所以本文使用 bebel7 内置方法对输入代码进行修改。 babel7 内置包有： @babel/parser：将源码解析成 AST。对应 parse 阶段。 @babel/traverse：遍历 AST 节点，并调用 visitor。对应 transform 阶段。 @babel/generate：打印 AST，生成目标代码和 sourcemap。对应 generate 阶段。 @babel/types：创建、判断 AST。 @babel/template：根据模块批量创建 AST。 @babel/core：核心引擎，解析配置。 @babel/helpers：转换 esNext 所需的 AST。 @babel/helper-*：操作 AST 的公共函数。 @babel/runtime： helper：@bebel/helper-*的 runtime 版本。 corejs：esNext API 的实现。 regenerator：async、await 实现。 如何编写 babel 插件 去查找我们想修改的 Token 是属于什么类型的。可以在其他网站进行查看，或者使用 babel&#x2F;parse。 编写我们的 plugin 文件。在 visitor 里面写对应的 Token 的 visite 方法。 在bebel.config.json中使用我们编写的插件，babel&#x2F;core 会自动去导入执行。 查看输出的代码。 代码实现：123456789101112# 项目结构babel-demo│├─babel.config.json├─package.json├─pnpm-lock.yaml├─dist├─plugins│ └babel-plugin-test-1.js└─src └index.js 依赖： 123456789101112131415&#123; &quot;name&quot;: &quot;babel-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src -d dist&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;Edward Wang&lt;wang.huiyang@outlook.com&gt;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;@babel/cli&quot;: &quot;^7.14.8&quot;, &quot;@babel/core&quot;: &quot;^7.15.0&quot;, &quot;prettier&quot;: &quot;^2.3.2&quot; &#125;&#125; babel.config.json： 12345678910&#123; &quot;plugins&quot;: [ [ &quot;./plugins/babel-plugin-test-1&quot;, &#123; &quot;ignore&quot;: [&quot;info&quot;] &#125; ] ]&#125; plugins&#x2F;babel-plugin-test-1.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394module.exports = (&#123; types &#125;) =&gt; &#123; return &#123; visitor: &#123; /** * 内置变量 */ VariableDeclaration(path) &#123; const node = path.node; /** * deal with `const` */ if (node.kind === &quot;const&quot;) node.kind = &quot;var&quot;; // delete comments. delete node.leadingComments; delete node.trailingComments; &#125;, /** * 二元运算符 */ BinaryExpression(path) &#123; const node = path.node; const equalMap = &#123; &quot;==&quot;: &quot;===&quot;, &quot;!=&quot;: &quot;!==&quot;, &#125;; node.operator = equalMap[node.operator] || node.operator; &#125;, /** * 标识符 */ Identifier(path) &#123; const node = path.node; if (node.name === &quot;foo&quot;) node.name = &quot;bar&quot;; &#125;, /** * arrow function */ ArrowFunctionExpression(path) &#123; const node = path.node; if (node.type === &quot;ArrowFunctionExpression&quot;) &#123; const body = path.get(&quot;body&quot;).node; // get function body if (body.type !== &quot;BlockStatement&quot;) &#123; // 如果 arrow function 的 body 不是 block statement，需要特殊处理。 // 否则直接将 type 修改为 FunctionExpression的话 // const TrueID = () =&gt; true; // 编译后的结果为 // const TrueID = function () true; const statement = []; /** * types: 构造 Token */ statement.push(types.returnStatement(body)); node.body = types.blockStatement(statement); &#125; node.type = &quot;FunctionExpression&quot;; &#125; &#125;, /** * 表达式 */ ExpressionStatement(path, &#123; opts: options &#125;) &#123; const node = path.node; const &#123; object, property &#125; = node.expression.callee; console.log(options); if (object.name === &quot;console&quot;) &#123; // deal with console // options.ignore 来自 babel.config.json 中的 ignore const ignore = (options.ignore || []).find( (i) =&gt; i === property.name ); if (!ignore) &#123; path.remove(); &#125; &#125; // delete comments. delete node.leadingComments; delete node.trailingComments; &#125;, // .etc ... &#125;, &#125;;&#125;; src&#x2F;index.js： 1234567891011121314151617const foo = () =&gt; 1const b = () =&gt; &#123; console.log(&#x27;a&#x27;) // this will be remove after run. const c = foo() console.info(&#x27;test foo console&#x27;) // this will not be remove because it is in the ignore list.&#125;const obj = &#123;&#125;if (obj.a == obj.c) &#123; console.info(&#x27;equal&#x27;)&#125;if (obj.a != obj.c) &#123; console.err(&#x27;not equal&#x27;)&#125; dist&#x2F;index.js： 1234567891011121314151617var bar = function () &#123; return 1&#125;var b = function () &#123; var c = bar() console.info(&#x27;test foo console&#x27;)&#125;var obj = &#123;&#125;if (obj.a === obj.c) &#123; console.info(&#x27;equal&#x27;)&#125;if (obj.a !== obj.c) &#123;&#125;"},{"title":"TON 6 大核心竞争力","path":"/notes/TON 6 大核心竞争力.html","content":"TON (The Open Network) smart contract pay gas fee.太坊模式：bank，用户对 contract 发起 transfer，用户付 gas fee。TON 模式：每个 contract 自带 balance，用户对 contract 发起 transfer，由 contract 支付 gas fee。当 contract 的 balance 为 0 的时候，contract 自动被从链上移除。充值 balance 后，自动添加到链。这样做的好处是：当需要全网调整 Gas Fee 的时候，不会影响到用户和 Miner 的权益。 Calls between smart contracts are asynchronous and not atomic 异步 非原子 在 ETH 链上操作可以串联，并且在其中一个任务失败时，对整个事件进行回滚。 The whole process is even atomic - if any of these steps fails, even the last, the whole transaction rolls back like it never happened. 但是在 TON 中，合约之间的调用是异步的，导致回滚困难。但是也有好处，就是处理的速度变快了。 Your smart contract cannot run getter methods on other contracts"},{"path":"/notes/index.html","content":"This page is used to record some notes"},{"title":"输入URL，按下Enter之后，发生了什么。","path":"/frontend/输入URL，按下Enter之后，发生了什么。.html","content":"DNS 解析 向本地 DNS 发起请求，解析 ip。 采用递归或者迭代的方式，向根域名服务器、顶级域名服务器、权威域名服务器发起请求。 找到一组 ip，返回给浏览器。 解析失败，返回错误。 开始 HTTP 请求 建立连接 调用 socket、bind、listen 和 accept 四个函数完成绑定公网 ip、监听 443 和接收请求的任务。 客户端通过 socket 和 connect 函数主动打开连接，发送带有 SYN 标志位的分组。随机生成一个初始序号 x，附带 MSS（Maximum Segment Size， 最大段大小）等额外信息。MSS 的值一般为以太网 MTU（Maximum Transmission Unit， 最大传输单元）的值减去 IP 头部和 TCP 头部大小，等于 1460bytes。 服务器确认收到客户端的分组，发送带有 SYN+ACK 标志位的分组，随机生成一个序号 y，确认号为 x+1，以及额外的 MSS 信息。当一端收到另一端的 MSS 信息后，会取 MSS 的最小值来决定 TCP 最大报文的大小。 客户端确认收到服务器的分组，发送带有 SYN+ACK 标志位的分组，确认号为 y+1，建立 TCP 连接。 如果是初次会话，双方需要一次完整的四次握手。客户端首先向服务器发送 Client Hello 报文，包含一个随机数、TLS 协议版本、按优先级排列的加密套件列表。 服务器向客户端发送 Server Hello 报文，包含一个新的随机数、TLS 协议版本、选择后的加密套件。 服务器向客户端发送 Certificate 报文，包含服务器证书链。其中第一个为主证书，中间证书按照顺序跟在主证书后，根 CA 证书一般附加在浏览器里，无需发送。 如果选择 DH 加密算法，服务器会向客户端发送 Server Key Exchange 报文，包含 DH 密钥交换的所需参数。如果选择 RSA 算法，则跳过这一步。 服务器向客户端发送 Server Hello Done 报文，表示所有握手消息已经发送完毕。 客户端向服务器发送 Client Key Exchange 报文，如果密钥交换选择 RSA 算法，由客户端生成预主密钥，使用服务器证书中的公钥对其加密，包含在报文中，服务器只需使用自己的私钥解密就可以取出预主密钥；如果密钥交换选择 DH 算法，客户端会在报文中包含自己的 DH 参数，之后双方都根据 DH 算法计算出相同的预主密钥。需要注意的是，密钥交换的只是预主密钥，这个值还需进一步加工，结合客户端和服务器两个随机数种子，双方使用 PRF（pseudorandom function，伪随机函数）生成相同的主密钥。 客户端向服务器发送 Change Cipher Spec 报文，表明已经生成主密钥，在随后的传输过程中都使用这个主密钥加密。 客户端向服务器发送 Finished 报文，这条信息是经过加密的。如果服务器能解析出报文的内容，说明双方生成的主密钥是一致的。 服务器向客户端发送 New Session Ticket 报文，这个 Session Ticker 只有服务器能解密。客户端会将他保存下来，在之后的 TLS 重新握手过程中带上它进行快速会话恢复，减少往返时间。 14. 服务器向客户端发送 Change Cipher Spec 报文，同样表明已经生成主密钥在随后的传输过程中都使用这个主密钥加密。 15. 服务器向客户端发送 Finished 报文，如果客户端能解密出报文内容，则说明双方生成的主密钥是一致的。至此，完成所有握手协商。 发送 HTTP 请求 建立起安全的加密信道后，浏览器开始发送 HTTP 请求，一个请求报文由请求行、请求头、空行、实体（Get 请求没有）组成。请求头由通用首部、请求首部、实体首部、扩展首部组成。其中，通用首部表示无论是请求报文还是响应报文都可以使用，比如 Date；请求首部表示只有在请求报文中才有意义，分为 Accept 首部、条件请求首部、安全请求首部和代理请求首部这四类；实体首部作用于实体内容，分为内容首部和缓存首部这两类；扩展首部表示用户自定义的首部，通过 X- 前缀来添加。另外需要注意的是，HTTP 请求头是不区分大小写的，它基于 ASCII 进行编码，而实体可以基于其它编码方式，由 Content-Type 决定。 返回 HTTP 响应 服务器接受并处理完请求，返回 HTTP 响应，一个响应报文格式基本等同于请求报文，由响应行、响应头、空行、实体组成。区别于请求头，响应头有自己的响应首部集，比如 Vary、Set-Cookie，其它的通用首部、实体首部、扩展首部则共用。此外，浏览器和服务器必须保证 HTTP 的传输顺序，各自维护的队列中请求&#x2F;响应顺序必须一一对应，否则会出现乱序而出错的情况。 维持连接 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。在 HTTP&#x2F;1.1 中，Connection: keep-alive 是默认启用的，表示持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。注意，HTTP keep-alive 和 TCP keep-alive 虽然都是一种保活机制，但是它们完全不相同，一个作用于应用层，一个作用于传输层。 断开连接 服务器向客户端发送 Alert 报文，类型为 Close Notify，通知客户端不再发送数据，即将关闭连接，同样，这条报文也是经过加密处理的。 服务器通过调用 close 函数主动关闭连接，向客户端发送带有 FIN 标志位的分组，序列号为 m。 客户端确认收到该分组，向服务器发送带有 ACK 标志位的分组，确认号为 m+1。 客户端发送完所有数据后，向服务器发送带有 FIN 标志位的分组，序列号为 n。 服务器确认收到该分组，向客户端发送带有 ACK 标志位的分组，序列号为 n+1。客户端收到确认分组后，立即进入 CLOSED 状态；同时，服务器等待 2 个 MSL(Maximum Segment Lifetime，最大报文生存时间) 的时间后，进入 CLOSED 状态。 浏览器解析 现代浏览器是一个及其庞大的大型软件，在某种程度上甚至不亚于一个操作系统，它由多媒体支持、图形显示、GPU 渲染、进程管理、内存管理、沙箱机制、存储系统、网络管理等大大小小数百个组件组成。虽然开发者在开发 Web 应用时，无需关心底层实现细节，只需将页面代码交付于浏览器计算，就可以展示出丰富的内容。但页面性能不仅仅关乎浏览器的实现方式，更取决于开发者的水平，对工具的熟悉程度，代码优化是无止尽的。显然，了解浏览器的基本原理，了解 W3C 技术标准，了解网络协议，对设计、开发一个高性能 Web 应用帮助非常大。 当我们在使用 Chrome 浏览器时，其背后的引擎是 Google 开源的 Chromium 项目，而 Chromium 的内核则是渲染引擎 Blink（基于 Webkit）和 JavaScript 引擎 V8。在阐述浏览器解析 HTML 文件之前，先简单介绍一下 Chromium 的多进程多线程架构（图 5），它包括多个进程： 一个 Browser 进程 多个 Renderer 进程 一个 GPU 进程 多个 NPAPI Render 进程 多个 Pepper Plugin 进程 而每个进程包括若干个线程： 一个主线程 在 Browser 进程中：渲染更新界面 在 Renderer 进程中：使用持有的内核 Blink 实例解析渲染更新界面 一个 IO 线程 在 Browser 进程中：处理 IPC 通信和网络请求 在 Renderer 进程中：处理与 Browser 进程之间的 IPC 通信 一组专用线程 一个通用线程池 Chromium 支持多种不同的方式管理 Renderer 进程，不仅仅是每一个开启的 Tab 页面，iframe 页面也包括在内，每个 Renderer 进程是一个独立的沙箱，相互之间隔离不受影响。 Process-per-site-instance：每个域名开启一个进程，并且从一个页面链接打开的新页面共享一个进程（noopener 属性除外），这是默认模式 Process-per-site：每个域名开启一个进程 Process-per-tab：每个 Tab 页面开启一个进程 Single process：所有页面共享一个进程 当 Renderer 进程需要访问网络请求模块（XHR、Fetch），以及访问存储系统（同步 Local Storage、同步 Cookie、异步 Cookie Store）时，则调用 RenderProcess 全局对象通过 IO 线程与 Browser 进程中的 RenderProcessHost 对象建立 IPC 信道，底层通过 socketpair 来实现。正由于这种机制，Chromium 可以更好地统一管理资源、调度资源，有效地减少网络、性能开销。 主流程 页面的解析工作是在 Renderer 进程中进行的，Renderer 进程通过在主线程中持有的 Blink 实例边接收边解析 HTML 内容（图 6），每次从网络缓冲区中读取 8KB 以内的数据。浏览器自上而下逐行解析 HTML 内容，经过词法分析、语法分析，构建 DOM 树。当遇到外部 CSS 链接时，主线程调用网络请求模块异步获取资源，不阻塞而继续构建 DOM 树。当 CSS 下载完毕后，主线程在合适的时机解析 CSS 内容，经过词法分析、语法分析，构建 CSSOM 树。浏览器结合 DOM 树和 CSSOM 树构建 Render 树，并计算布局属性，每个 Node 的几何属性和在坐标系中的位置，最后进行绘制展示在屏幕上。当遇到外部 JS 链接时，主线程调用网络请求模块异步获取资源，由于 JS 可能会修改 DOM 树和 CSSOM 树而造成回流和重绘，此时 DOM 树的构建是处于阻塞状态的。但主线程并不会挂起，浏览器会使用一个轻量级的扫描器去发现后续需要下载的外部资源，提前发起网络请求，而脚本内部的资源不会识别，比如 document.write。当 JS 下载完毕后，浏览器调用 V8 引擎在 Script Streamer 线程中解析、编译 JS 内容，并在主线程中执行（图 7）。 渲染流程 当 DOM 树构建完毕后，还需经过好几次转换，它们有多种中间表示（图 8）。首先计算布局、绘图样式，转换为 RenderObject 树（也叫 Render 树）。再转换为 RenderLayer 树，当 RenderObject 拥有同一个坐标系（比如 canvas、absolute）时，它们会合并为一个 RenderLayer，这一步由 CPU 负责合成。接着转换为 GraphicsLayer 树，当 RenderLayer 满足合成层条件（比如 transform，熟知的硬件加速）时，会有自己的 GraphicsLayer，否则与父节点合并，这一步同样由 CPU 负责合成。最后，每个 GraphicsLayer 都有一个 GraphicsContext 对象，负责将层绘制成位图作为纹理上传给 GPU，由 GPU 负责合成多个纹理，最终显示在屏幕上。 另外，为了提升渲染性能效率，浏览器会有专用的 Compositor 线程来负责层合成（图 9），同时负责处理部分交互事件（比如滚动、触摸），直接响应 UI 更新而不阻塞主线程。主线程把 RenderLayer 树同步给 Compositor 线程，由它开启多个 Rasterizer 线程，进行光栅化处理，在可视区域以瓦片为单位把顶点数据转换为片元，最后交付给 GPU 进行最终合成渲染。 页面生命周期 页面从发起请求开始，结束于跳转、刷新或关闭，会经过多次状态变化和事件通知，因此了解整个过程的生命周期非常有必要。浏览器提供了 Navigation Timing 和 Resource Timing 两种 API 来记录每一个资源的事件发生时间点，你可以用它来收集 RUM（Real User Monitoring，真实用户监控）数据，发送给后端监控服务，综合分析页面性能来不断改善用户体验。图 10 表示 HTML 资源加载的事件记录全过程，而中间黄色部分表示其它资源（CSS、JS、IMG、XHR）加载事件记录过程，它们都可以通过调用 window.performance.getEntries() 来获取具体指标数据。 图 10：页面加载事件记录流程 衡量一个页面性能的方式有很多，但能给用户带来直接感受的是页面何时渲染完成、何时可交互、何时加载完成。其中，有两个非常重要的生命周期事件，DOMContentLoaded 事件表示 DOM 树构建完毕，可以安全地访问 DOM 树所有 Node 节点、绑定事件等等；load 事件表示所有资源都加载完毕，图片、背景、内容都已经完成渲染，页面处于可交互状态。但是迄今为止浏览器并不能像 Android 和 iOS app 一样完全掌控应用的状态，在前后台切换的时候，重新分配资源，合理地利用内存。实际上，现代浏览器都已经在做这方面的相关优化，并且自 Chrome 68 以后提供了Page Lifecycle API，定义了全新的浏览器生命周期（图 11），让开发者可以构建更出色的应用。 现在，你可以通过给 window 和 document 绑定上所有生命周期监听事件（图 12），来监测页面切换、用户交互行为所触发的状态变化过程。不过，开发者只能感知事件在何时发生，不能直接获取某一刻的页面状态（图 11 中的 STATE）。即使如此，利用这个 API，也可以让脚本在合适的时机执行某项任务或进行界面 UI 反馈。图 11：新版页面生命周期"},{"title":"各种支付方式对比","path":"/notes/各种支付方式对比.html","content":"EXW：出厂价 FCA：EXW+运输到出口港+出口报关费用 FOB：FCA+港杂费 CFB：FOB+海运费 CIF：CFB+保险 DAP：DDP-报关费 DDP：送货上门"},{"title":"aɪ & eɪ","path":"/spoken_english/aɪ & eɪ.html","content":"aɪ like guy hi site nice fight slight might bye eɪ hey may fake hate lake cake"},{"title":"R-coloured vowel","path":"/spoken_english/R-coloured vowel.html","content":"日化元音（儿化音） r /ɝː/ bird /bɝːd/ nurse /nɝːs/ first /ˈfɝːst/ hurt /hɝːt/ burn /bɝːn/ learn /lɝːn/ turn /tɝːn/ [ɑː] + [ɝ] = [ɑːr] heart /hɑːrt/ far /fɑːr/ large /lɑːrdʒ/ [ɔː] + [ɝ] = [ɔːr] more /mɔːr/ sure /ʃɔːr/ tour /tʊr/ [e] + [ɝ] = [er] air /er/ hair /her/ glare /ɡler/ care /ker/ [ɪr] 当做 [i:r] fear /fɪr/ hear /hɪr/ near /nɪr/"},{"title":"React源码的文件结构","path":"/frontend/React源码的文件结构.html","content":"顶层目录除去配置文件和隐藏文件夹，根目录的文件夹包括三个： 1234根目录├── fixtures # 包含一些给贡献者准备的小型 React 测试项目├── packages # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）├── scripts # 各种工具链的脚本，比如git、jest、eslint等 packages 目录目录下的文件夹非常多，我们来看下： react (opens new window)文件夹React 的核心，包含所有全局 React API，如： React.createElement React.Component React.Children 这些 API 是全平台通用的，它不包含ReactDOM、ReactNative等平台特定的代码。在 NPM 上作为单独的一个包 (opens new window)发布。 scheduler (opens new window)文件夹Scheduler（调度器）的实现。 shared (opens new window)文件夹源码中其他模块公用的方法和全局变量，比如在shared&#x2F;ReactSymbols.js (opens new window)中保存React不同组件类型的定义。 12345// ...export let REACT_ELEMENT_TYPE = 0xeac7export let REACT_PORTAL_TYPE = 0xeacaexport let REACT_FRAGMENT_TYPE = 0xeacb// ... Renderer 相关的文件夹如下几个文件夹为对应的 Renderer 12345- react-art- react-dom # 注意这同时是DOM和SSR（服务端渲染）的入口- react-native-renderer- react-noop-renderer # 用于debug fiber（后面会介绍fiber）- react-test-renderer 试验性包的文件夹React将自己流程中的一部分抽离出来，形成可以独立使用的包，由于他们是试验性质的，所以不被建议在生产环境使用。包括如下文件夹： 12345- react-server # 创建自定义SSR流- react-client # 创建自定义的流- react-fetch # 用于数据请求- react-interactions # 用于测试交互相关的内部特性，比如React的事件模型- react-reconciler # Reconciler的实现，你可以用他构建自己的Renderer 辅助包的文件夹React将一些辅助功能形成单独的包。包括如下文件夹： 1234- react-is # 用于测试组件是否是某类型- react-client # 创建自定义的流- react-fetch # 用于数据请求- react-refresh # “热重载”的React官方实现 react-reconciler (opens new window)文件夹我们需要重点关注 react-reconciler，在接下来源码学习中 80%的代码量都来自这个包。 虽然他是一个实验性的包，内部的很多功能在正式版本中还未开放。但是他一边对接 Scheduler，一边对接不同平台的 Renderer，构成了整个 React16 的架构体系。 其他文章 [[React-旧的架构]] [[React-新的架构]]"},{"title":"阿里钉钉团队前端考试卷","path":"/frontend/阿里钉钉团队前端考试卷.html","content":"3.什么是指令和指令集？答：指令一般是指机器指令，是计算机可完成一个独立计算逻辑所要执行的的命令；一台常规的计算机的所有指令的集合，就是该计算机的指令集。 4.JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？答：①JS 代码-&gt;解析成 AST (期间伴随词法分析、语法分析)-&gt;生成字节码（V8）-&gt;生成机器码（编译器） ② 很多资料会说，JavaScript、Python、Ruby 都是”解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。 例如说 C 一般被认为是“编译型语言”，但 C 的解释器也是存在的，例如 Ch。同样，C++也有解释器版本的实现，例如 Cint。 一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的 Scheme 就有好几种编译器实现，其中率先支持 R6RS 规范的大部分内容的是 Ikarus，支持在 x86 上编译 Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成 x86 机器码。 解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个 C 语言的解释器，里面只是先用普通的 C 编译器把源码编译为 in-memory image，然后直接调用那个 image 去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。 实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为 AST 或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。 这道题扯多了，肯定有掘金大佬来杠我。我的观点是如果一种语言的主流实现是解释器，其内部是编译器+虚拟机，而虚拟机又是采用解释方式实现的，或者内部实现是编译器+树遍历解释器，那它就是名副其实的“解释型语言”。如果内部用的虚拟机是用编译方式实现的，其实跟普遍印象中的”解释器”还是挺不同的。 可以举这样一个例子：ActionScript 3，一般都被认为是“解释型语言”对吧？但这种观点到底是把 FlashPlayer 整体看成一个解释器，因而 AS3 是”解释型语言”””呢？还是认为 FlashPlayer 中的虚拟机采用解释执行方案，因而 AS3 是解释型语言呢？ 5.简单描述一下 Babel 的编译过程？答：首先，Babel 的作用是 从一种源码到另一种源码，充当转换编译器的作用，可以简述为解析（解析 JS 代码）-&gt;转换（解析和修改 AST）-&gt;重建（将修改后的 AST 转换成另一种 JS 代码） 6.JavaScript 中的数组和函数在内存中是如何存储的？答：① 数组，JS 里的数组主要就是 以连续内存形式存储的FixedArray、以哈希表形式存储的HashTable。 ② 函数，函数属于引用数据类型，存储在堆中，在栈内存中只是存了一个地址来表示对堆内存中的引用。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 7.浏览器和 Node.js 中的事件循环机制有什么区别？答：① 浏览器中的事件循环：macrotasks(宏任务): script(整体代码) setTimeout setInterval setImmediate I/O UI rendering event listner microtasks(微任务): process.nextTick Promises Object.observe MutationObserver JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。 一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。 ②NodeJs 中的事件循环： timersj 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调 I&#x2F;O callbacks：执行一些系统调用错误，比如网络通信的错误回调 idle,prepare：仅 node 内部使用 poll：获取新的 I&#x2F;O 事件, 适当的条件下 node 将阻塞在这里 check：执行 setImmediate() 的回调 close callbacks：执行 socket 的 close 事件回调 ③ 区别：浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval 和 setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致。 123456789101112131415161718192021222324setTimeout(() =&gt; &#123; console.log(&#x27;timer1&#x27;) Promise.resolve().then(function () &#123; console.log(&#x27;promise1&#x27;) &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log(&#x27;timer2&#x27;) Promise.resolve().then(function () &#123; console.log(&#x27;promise2&#x27;) &#125;)&#125;, 0)// 浏览器环境：;(timer1) =&gt; (promise1) =&gt; (timer2) =&gt; promise2// node V11之后;(timer1) =&gt; (promise1) =&gt; (timer2) =&gt; promise2// node 10及其之前;(timer1) =&gt; (promise1) =&gt; (timer2) =&gt; promise2(如果是第二个定时器还未在完成队列中);(timer1) =&gt; (timer2) =&gt; (promise1) =&gt; promise2(如果是第二个定时器已经在完成队列中) 8.ES6 Modules 相对于 CommonJS 的优势是什么？答： CommonJS 和 ES6 Module 都可以对引入的对象进行赋值，即对对象内部属性的值进行改变； CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。即 ES6 Module 只存只读，不能改变其值，具体点就是指针指向不能变； CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。 import 的接口是 read-only（只读状态），不能修改其变量值。即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。 优势：CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 Modules 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 9.高级程序设计语言是如何编译成机器语言的？答：高级语言代码-&gt;解析成 AST (期间伴随词法分析、语法分析)-&gt;生成字节码（V8）-&gt;生成机器码（编译器） 10.编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？答：编译器一般由 4 个阶段工作完成： Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）； Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息； TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码； Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。 数据类型检查一般在 Parse 阶段之前 就进行了，因为在生成 AST 之前 就要进行语法分析，提取出句子的结构。广义来说输入一般是程序的源码，输出一般是语法树（syntax tree，也叫 parse tree 等）或抽象语法树（abstract syntax tree，AST）。进一步剥开来，广义的解析器里一般会有扫描器（scanner，也叫 tokenizer 或者 lexical analyzer，词法分析器），以及狭义的解析器（parser，也叫 syntax analyzer，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的 AST。 11.编译过程中虚拟机的作用是什么？答：虚拟机（VM），其意义是实现高级语言的语义。VM 既然被称为“机器”，一般认为输入是满足某种指令集架构（instruction set architecture，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标 ISA 可以是同一种，这是所谓 same-ISA VM。虚拟机 并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：“编译”，例如微软的.NET 中的 CLR；“解释”，例如 CPython、CRuby 1.9，许多老的 JavaScript 引擎等；也有介于两者之间的混合式，例如 Sun 的 JVM，HotSpot。如果采用编译方式，VM 会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是 native code），然后再执行之；如果采用解释方式，则 VM 会把输入的指令逐条直接执行。 12.什么是中间代码（IR），它的作用是什么？答：IR 是由 LLVM 生成的中间代码，作用是优化编译器或 VM，使优化后的机器代码执行效率更高，同时避免缓存编译后的二进制代码占用更多的内存。。 13.什么是交叉编译？答：是指是在一个平台上生成另一个平台上的可执行代码。 14.发布 &#x2F; 订阅模式和观察者模式的区别是什么？答：在观察者模式中，被观察者通常会维护一个观察者列表。当被观察者的状态发生改变时，就会通知观察者。 在发布订阅模式中，具体发布者会动态维护一个订阅者的列表：可在运行时根据程序需要开始或停止发布给对应订阅者的事件通知。 区别在于发布者本身并不维护订阅列表（它不会像观察者一样主动维护一个列表），它会将工作委派给具体发布者（相当于秘书，任何人想知道我的事情，直接问我的秘书就可以了）；订阅者在接收到发布者的消息后，会委派具体的订阅者来进行相关的处理。 15.装饰器模式一般会在什么场合使用？答：装饰器模式一般是指允许动态地向一个现有的对象添加新的功能，同时又不改变其结构，相当于对现有的对象进行了一个包装。 使用场景很多，比如以前写 jQ 项目，可以自己快速动态拓展 jQ 上面的方法，或者 vue 的自定义指令，主要是希望通过继承的方式扩展老旧功能。 16.谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？答：① 代码解耦、一定要按模块划分而不是按功能划分 各个模块的生命周期（初始化、销毁）统一由框架进行管理：通过提供通用类 Disposable，统一管理相关资源的注册和销毁。 模块间不直接引入和调用，而是通过声明依赖的方式，从框架中获取相应的服务并使用。 不直接使用全局事件进行通信，而是通过订阅具体服务的方式来处理：通过使用同样的方式 this._register()注册事件和订阅事件，将事件相关资源的处理统一挂载到 dispose()方法中 ② 各个部分各个模块开发职责的仔细拆分 ③ 代码开发尽快组件化、提高可复用性，避免业务逻辑过度耦合臃肿，最终难以拓展 Ioc 是指依赖注入，简单理解就是借助于”第三方”实现具有依赖关系的对象之间的解耦。一般使用代理模式。 17.列举你所了解的编程范式？答：声明式、命令式、函数式 18.什么是面向切面（AOP）的编程？答：面向切面编程是面向对象中的一种方式而已。在代码执行过程中，动态嵌入其他代码，叫做面向切面编程。 19.什么是函数式编程？什么是响应式编程？什么是函数响应式编程？答：函数式编程是面向数学的抽象，关心数据（代数结构）之间的映射关系。函数式编程将计算描述为一种表达式求值。 响应式编程是一种基于数据流和变化传递的声明式的编程范式。 函数响应式编程是一种混合体，响应式编程思想为体, 函数式编程思想为用。 20.如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应?答： 1// 见试卷背面。 21.如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip?答：可以用元素的 scrollHeight 属性和 clientHeight 属性来判断, 当 scrollHeight 大于 clientHeight 的时候，元素就是可以垂直滚动的；如果检测水平滚动的话，可以用 scrollWidth 和 clientWidth。 22.如何让 CSS 元素左侧自动溢出（… 溢出在左侧）？答：左侧宽度自动增长，右侧宽度自动增长并且不可溢出省略。当左侧文字长度超出的时候，左侧文字溢出省略。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=&quot;footer&quot;&gt; &lt;style&gt; /* css */ .footer &#123; width: 300px; height: 20px; display: flex; overflow: hidden; &#125; .left &#123; background: #3cc8b4; flex: 1 1 auto; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 50px; &#125; .right &#123; background: #9bc; max-width: 250px; &#125; .right-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; leftleftleftleftleftleftleftleftleftleftleftleftleft &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;right-ellipsis&quot;&gt; rightrightrightrightrightrightrightrightright &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 23.什么是沙箱？浏览器的沙箱有什么作用？答：沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源。 24.如何处理浏览器中表单项的密码自动填充问题？答：表单中当 input 是 password 类型时，打开浏览器会自动填充浏览器存储的密码，在 input 中加入 autocomplete&#x3D;”new-password”即可解决。之所以 new-password 能够解决 off 失效的原因是 autocomplete 属性的有效值只有 on 和 off，默认值是 on，如果 autocomplete 的属性是除 on 和 off 外的值，那么就是个无效值，那么浏览器就会放弃对该属性的执行。 123456&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;new-password&quot;/&gt; 25.Hash 和 History 路由的区别和优缺点？答：hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 26.JavaScript 中的 const 数组可以进行 push 操作吗？为什么？答：可以，也可以进行 splice()操作。 const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。 27.JavaScript 中对象的属性描述符有哪些？分别有什么作用？答： Configurable(可配置性) 可配置性决定是否可以使用 delete 删除属性，以及是否可以修改属性描述符的特性，默认值为 true Enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过 for-in 循环返回该属性，默认值为 true Writable(可写性) 可写性决定是否可以修改属性的值，默认值为 true Value(属性值) 属性值包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined getter 在读取属性时调用的函数。默认值为 undefined setter 在写入属性时调用的函数。默认值为 undefined 28.JavaScript 中 console 有哪些 api ?答：我只用过 console.clear()、console.log()、console.info()、console.warn()、console.error()、console.time()、console.timeEnd()。其他的不知道，我也不常用 29.简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？答：首先 callback 不是异步 API，它是早年 JS 异步编程实现的一种手段。 Promise 是社区为了解决回调地狱的问题在 ES6 版本提出的一种解决方案； Generator 也是一种异步编程解决方案，它最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注； Async&#x2F;await 是 ES7 中提出的新的异步解决方案，async 是 Generator 函数的语法糖，async&#x2F;await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链）。async&#x2F;await 不仅仅是 JS 的异步编程的一种方式，其可读性也接近于同步代码，让人更容易理解。 30.Object.defineProperty 有哪几个参数？各自都有什么作用？答：首先它的用法是 Object.defineProperty(object, propertyname, descriptor) object 必需。要在其上添加或修改属性的对象。这可能是一个本机 JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。 propertyname 必需。一个包含属性名称的字符串。 descriptor 必需。属性描述符。它可以针对数据属性或访问器属性。 它内部的 descriptor 参数如下： value 属性的值，默认为 undefined。 writable 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 configurable 如果为 false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。。 enumerable 是否能在 for-in 循环中遍历出来或在 Object.keys 中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 get 一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 set 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。 31.Object.defineProperty 和 ES6 的 Proxy 有什么区别？答：Proxy 的优势如下 Proxy 可以直接监听整个对象而非属性。 Proxy 可以直接监听数组的变化。 Proxy 有 13 中拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。 Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改; Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。 Object.defineProperty 的优势如下 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。 Object.defineProperty 不足在于： Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。 Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。 Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。 Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。 32.ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？答：使用场景太多了，业务上也天天用，略。 33.为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？答：首先，不一定非要用 TS，大型业务产品、多人协作写大堆的业务代码不适合 TS。 优势：1.为 JavaScript、IDE 和实践（如静态检查）提供了高效的开发工具。（主要） 2.其他的比如强大的类型系统，泛型支持、模块支持等等（次要） 34.TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？答：const 和 readonly 的区别： const 是一个编译期常量， readonly 是一个运行时常量 const 只能声明基元类型，枚举类型，字符串类型。readonly 则无限制 const 天生为静态数据，无需再添加 static 标识 readonly 是运行时变量，只能赋值一次。特例是可以定义时赋值一次，构造函数中再赋值一次 枚举和常量枚举的区别：常量枚举通过在枚举上使用 const 修饰符来定义，常量枚举不同于常规的枚举，他们会在编译阶段被删除。常量枚举成员在使用的地方会被内联进来，之所以可以这么做是因为，常量枚举不允许包含计算成员；如上例所示，在运行时是没有 Size 变量的，因此常量枚举会带来一个对性能的提升。 接口和类型别名的区别： 类型别名可以用于其它类型 （联合类型、元组类型、基本类型（原始值）），interface 不支持 nterface 可以多次定义 并被视为合并所有声明成员 type 不支持 type 能使用 in 关键字生成映射类型，但 interface 不行。 默认导出方式不同 35.TypeScript 中 any 类型的作用是什么？答：Any 就是任意类型，可以将 TypeScript 进化成强大的 AnyScript。 36.TypeScript 中 any、never、unknown 和 void 有什么区别？答：any 顾名思义就是任意类型。never 表示永不存在的值的类型。unknown 表示未知类型，即写代码的时候还不清楚会得到怎样的数据类型，它能被赋值为任何类型，但不能被赋值给除了 any 和 unknown 之外的其他类型，同时，不允许执行 unknown 类型变量的方法（any 可以）。void 表示无任何类型，正好与 any 相反，没有类型，如果是函数则应没有返回值或者返回 undefined 37.TypeScript 中 interface 可以给 Function &#x2F; Array &#x2F; Class（Indexable）做声明吗？答：可以，interface 能够描述 JavaScript 对象的任何形式，包括函数。 interface 也可以被 class 类 implements，这里相当于声明了一个 interface 包含了各种属性，需要 class 去实现，注意给类本身声明类型，其实就是给构造器进行类型声明，不能添加其他属性。 38.TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？答：可以 39.TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？答：this 无法在未声明的情况下使用，在编写函数是需要在函数里首位声明 this 40.TypeScript 中使用 Unions 时有哪些注意事项？答：联合类型表示取值可以为多种类型中的一种，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法（交集）。 41.TypeScript 如何设计 Class 的声明？答：TypeScript 类型声明非常灵活，这也意味着一千个莎士比亚就能写出一千个哈姆雷特。在团队协作中，为了更好的可维护性， 我们应该尽可能地践行以下 3 条原则： 泛型优于联合类型 第一，类型定义使 getSmallPet 变得局限。从代码逻辑看，它的作用是返回一个不下蛋的动物，返回的类型指向的是 Fish 或 Bird。但我如果只想在一群鸟中挑出一个不下蛋的鸟呢？通过调用这个方法，我只能得到一个 可能是 Fish、或者是 Bird 的神奇生物。 第二，代码重复、难以扩展。比如，我想再增加一个乌龟，我必须找到所有类似 Fish | Bird 的地方，然后把它修改为 Fish | Bird | Turtle 第三，类型签名无法提供逻辑相关性。我们再审视一下类型签名，完全无法看出这里为什么是 Fish | Bird 而不是其他动物，它们两个到底和逻辑有什么关系才能够被放在这里 善用 typeof 推导优于自定义类型 善用内置工具函数优于重复声明 42.TypeScript 中如何联合枚举类型的 Key?答：用 mapped type，用完之后不能加额外的属性，用类型并运算解决。 123type Props = &#123; [key in Link]: U&#125; &amp; &#123; type: string &#125; 43.TypeScript 中 ?.、??、!.、_、** 等符号的含义？答：？：表示该属性或参数为可选项 ！：表示强制解析（告诉 typescript 编译器，这里一定有值）,变量后使用 ！：表示类型推断排除 null、undefined ?? 如果??运算符左侧的表达式求值为 undefined 或 null，则返回其右侧的值；否则，返回其左侧的值 44.TypeScript 中预定义的有条件类型有哪些？答： 12345Exclude&lt;T, U&gt; -- 从T中剔除可以赋值给U的类型。Extract&lt;T, U&gt; -- 提取T中可以赋值给U的类型。NonNullable&lt;T&gt; -- 从T中剔除null和undefined。ReturnType&lt;T&gt; -- 获取函数返回值类型。InstanceType&lt;T&gt; -- 获取构造函数类型的实例类型。 45.简单介绍一下 TypeScript 模块的加载机制？答：Typescrit 的模块机制与 es6 的模块基本类似，也提供了转换为 amd，es6，umd，commonjs，system 的转换。typescript 的按需加载，也叫动态加载，编译器会检测是否每个模块都会在生成的 JavaScript 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成require这个模块的代码。省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。这种模式的核心是import id = require(&quot;...&quot;)语句可以让我们访问模块导出的类型。模块加载器会被动态调用（通过require）。 模块加载的最佳实践 1、尽可能地在顶层导出 用户应该更容易地使用你模块导出的内容。嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。 2、模块里避免使用命名空间 模块中使用命名空间是不必要的，在模块中导出的东西肯定不能重名，而导入时使用者肯定会为其命名或者直接使用，也不存在重名，使用命名空间是多余的。 3、如果仅导出单个 class 或 function，使用 export default。如刚才所说，default 是比较好的实践。 4、如果要导出多个对象，把它们放在顶层里导出 5、导入时明确地列出导入的名字 6、导入大量模块时使用命名空间 7、使用重新导出进行扩展 你可能经常需要去扩展一个模块的功能。JS 里常用的一个模式是 JQuery 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间对象那样去合并。推荐的方案是不要去改变原来的对象，而是导出一个新的实体来提供新的功能。 46.简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？答：TypeScript 里的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。它正好与名）类型形成对比。TypeScript 的结构性子类型是根据 JavaScript 代码的典型写法来设计的。因为 JavaScript 里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。 协变 (Covariant) ：协变表示Comp&lt;T&gt;类型兼容和T的一致。 逆变 (Contravariant) ：逆变表示Comp&lt;T&gt;类型兼容和T相反。 双向协变 (Covariant) ：双向协变表示Comp&lt;T&gt;类型双向兼容。 不变 (Bivariant) ：不变表示Comp&lt;T&gt;双向都不兼容。 47.TypeScript 中对象展开会有什么副作用吗？答：展开操作符正与解构相反。它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。对象展开还有其它一些意想不到的限制。首先，它仅包含对象 自身的可枚举属性[1]。大体上是说当你展开一个对象实例时，你会丢失其方法： 48.TypeScript 中 interface、type、enum 声明有作用域的功能吗？答：有，叫类作用域，类变量 也可以称为 字段。类变量 声明在一个类里头，但在类的方法外面，可以通过类的实例化对象来访问。静态变量 静态的类变量，静态的变量可以通过类名直接访问 49.TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？答：同名 interface 接口会自动合并，interface 同名的 class 也会自动聚合。但 type 不能自动聚合，因为 type 声明不能重名。 50.如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？答：可以选择安装其 npm 包的 typescript 版本，npm install @types/包名 \\--save，一般都是这样命名。如果是自己写的 js 库 可以单独编写.d.ts 文件 51.TypeScript 的 tsconfig.json 中有哪些配置项信息？答： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; &quot;files&quot;: [ # 指定需要编译文件，相对配置文件所在 &quot;core.ts&quot;, &quot;sys.ts&quot;, &quot;types.ts&quot;, &quot;scanner.ts&quot;, &quot;parser.ts&quot;, &quot;utilities.ts&quot;, &quot;binder.ts&quot;, &quot;checker.ts&quot;, &quot;emitter.ts&quot;, &quot;program.ts&quot;, &quot;commandLineParser.ts&quot;, &quot;tsc.ts&quot;, &quot;diagnosticInformationMap.generated.ts&quot; ], &quot;exclude&quot;: [ # 指定不需要编译文件 &quot;node_modules&quot;, &quot;**/*.spec.ts&quot; ], &quot;include&quot;: [ # 指定需要编译文件; 不配置files,include，默认除了exclude的所有.ts,.d.ts,.tsx &quot;src/**/*&quot; ], # 指定基础配置文件路径 大部分配置 compilerOptions, files, include, and exclude。切忌循环引用。 &quot;extends&quot;: &quot;./configs/base&quot;, &quot;compilerOptions&quot;: &#123; # 告知TypeScript 编译器怎么编译 &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; # 相对于baseUrl配置 &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery&quot;] , &quot;*&quot;: [ &quot;*&quot;, &quot;generated/*&quot; ] &#125;, &quot;rootDirs&quot;:[ # 找平路径配置依赖 &quot;src/views&quot;, &quot;generated/templates/views&quot; ], &quot;module&quot;: &quot;commonjs&quot;, &quot;noImplicitAny&quot;: true, &quot;removeComments&quot;: true, # 移除代码注解 &quot;preserveConstEnums&quot;: true, &quot;sourceMap&quot;: true &quot;types&quot;: [] #不会自动导入@types定义的包 &quot;noResolve&quot;:true , # 不会自动导入import 依赖, 编译会报错 &quot;downlevelIteration&quot;:true # 进行js 语法降级 for..of &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;strictNullChecks&quot;: true # 开启null，检测 &quot;target&quot;:&#x27;ES5&#x27; &quot;strictBindCallApply&quot;:true &quot;skipLibCheck&quot;:true, &#125;, # 以上属性，为常用配置属性 &quot;compileOnSave&quot;: false, # 整个工程而言，需要编译器支持，譬如Visual Studio 2015 with TypeScript 1.8.4+ &quot;typeAcquisition&quot;:&#123; # 整个工程的类型定义.d.ts &quot;enable&quot;:false, # 默认值 false &quot;include&quot; : [&quot;jquery&quot;, &quot;lodash&quot;] &quot;exclue&quot;：[&quot;jquery&quot;, &quot;lodash&quot; ] &#125;, &quot;references&quot;:[&#123; # 引用的工程 path: &#x27;xxxx&#x27; &#125;] &#125; 52.TypeScript 中如何设置模块导入的路径别名？答：通过 tsconfig.json 中的 paths 项来配置 53.React Class 组件有哪些周期函数？分别有什么作用？答： constructor() 挂载类组件的时候，先执行构造函数 static getDerivedStateFromProps()会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 render() 渲染真实的 DOM 节点 componentDidMount()会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。 更新： static getDerivedStateFromProps() 同一次挂载时的 getDerivedStateFromProps() 一致 shouldComponentUpdate() 可以在这里进行性能优化，减少浅层比较 render() 插入真实的DOM节点树上 getSnapshotBeforeUpdate() 能在最近一次渲染中，从之前的DOM拿到一些有用的信息，比如滚动位置等 componentDidUpdate() 当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求） 卸载： componentWillUnmount() 这里是卸载及销毁组件前的调用方法 可以在这里清空一些数据，比如取消网络请求、 componentDidmount中创建的一些数据等等 54.React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？答：看情况，如果是服务端渲染会拿不到数据。 componentWillMount 方法的调用在 constructor 之后，在 render 之前，在这方法里的代码调用 setState 方法不会触发重渲染，所以它一般不会用来作加载数据之用，它也很少被使用到。 一般的从后台(服务器)获取的数据，都会与组件上要用的数据加载有关，所以都在 componentDidMount 方法里面作。虽然与组件上的数据无关的加载，也可以在 constructor 里作，但 constructor 是作组件 state 初绐化工作，并不是设计来作加载数据这工作的，所以所有有副作用的代码都会集中在 componentDidMount 方法里。 55.React Class 组件和 React Hook 的区别有哪些？答：Hook 代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护; 组件树层级变浅，在原本的代码中，我们经常使用 HOC&#x2F;render&#x2F;Props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实。 hooks 组件其实是降低了 react 开发的使用难度的，让新手可以在不使用 class 组件的情况下依然可以进行项目开发。 56.React 中高阶函数和自定义 Hook 的优缺点？答： 高阶组件实际上就是把一个组件当参数传入，再返回一个新的组件出来。业务过度封装的高阶组件，可能会导致组件层次嵌套变深。 而自定义 Hook 可以不用使用高阶组件依然可以进行功能复用。 57.简要说明 React Hook 中 useState 和 useEffect 的运行原理？答：useState 返回一个有状态值和一个函数来更新它。在初始渲染期间，返回的状态（状态）与作为第一个参数（initialState）传递的值相同。setState 函数用于更新状态。它接受一个新的状态值，并排队等待重新渲染该组件。在更新过程中， 首次渲染，render() render 会调用 App 函数，得到虚拟 DIV，创建真实 DIV 用户点击 Button，调用 setN(n+1)，render 函数被再一次调用 render 进一步调用 App 函数，得到虚拟 DIV，Diff，更新真实 DIV 每一次 setN 都会再次调用 render，进而调用 App 而 useEffect 的运行流程 初次渲染的时候，按照 useState，useEffect 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。 更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。 useState，useEffect 和使用的不是同一个数据 核心就在于每次更新把 cursor 赋值为零，然后更新时按照 hooks 顺序，依次从 memoizedState 中把上次记录的值拿出来，useEffect 接受 useState(返回新值)和旧值进行比较 58.React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？答：当内部 data 发生改变，state 发生改变(通过调用 this.setState()) 以及父组件传过来的 props 发生改变时，会导致组件重新渲染。 react 生命周期中有这样一个钩子，叫 shouldComponentUpdate 函数，是重渲染时 render()函数调用前被调用的函数，两个参数 nextProps 和 nextState ，分别表示下一个 props 和 state 的值。当函数返回 false 时，阻止接下来的 render()函数的调用，阻止组件重渲染，返回 true 时，组件照常渲染。前后不改变 state 的值的 setState 和无数据交换的父组件的重渲染都会导致组件的重渲染，但我们可以通过 shouldComponentUpdate 来阻止这两种情况，shouldComponentUpdate 并不是完美的，只能阻止扁平的对象，这时候可以考虑Immutable.js(Immutable.js 的基本原则是对于不变的对象返回相同的引用，而对于变化的对象，返回新的引用)或者PureRenderMixin 插件。 59.React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？答：不传参数、空数组、有一个或者多个值得数组、返回一个函数。 useEffect 的第二个参数可用于定义其依赖的所有变量。如果其中一个变量发生变化，则 useEffect 会再次运行。如果包含变量的数组为空，则在更新组件时 useEffect 不会再执行，因为它不会监听任何变量的变更。 60.React 的 useEffect 是如何监听数组依赖项的变化的？答：useEffect 的第二个参数可用于定义其依赖的所有变量。如果其中一个变量发生变化，则 useEffect 会再次运行。如果包含变量的数组为空，则在更新组件时 useEffect 不会再执行，因为它不会监听任何变量的变更。 61.React Hook 和闭包有什么关联关系？答： 首先闭包是由函数以及创建该函数的词法环境组合而成。这个词法环境包含了该闭包创建时所能访问的所有局部变量。划重点是闭包创建时的变量值，闭包创建之后即使这些变量值改变了也不会影响到闭包内保存的这个变量。 而 useEffect、useMemo、useCallback 都是自带闭包的。每一次组件的渲染，它们都会捕获当前组件函数上下文中的状态(state, props)，所以每一次这三种 hooks 的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。 对 Hook 过时闭包的解决办法： 添加依赖项 注意依赖项为空和不传依赖项是两个概念，前者是传了依赖项但它是一个空数组，后者是直接不传这个参数。前者只有依赖项改变时才会执行函数，后者只要组件数据改变了就执行。 以函数的形式更新 state 以函数的形式更新 state，同 react 的 setState 一样，useState Hook 也可以通过函数的形式来修改 state，并且使用当前的 state 值作为函数参数。 使用 useRef 通过 useRef 生成的对象来绑定 state，这样更新 state 的时候就可以不用依赖于该 state，而是直接在该绑定对象上的基础上更新即可。 使用 useReducer useReducer 可以达到和使用函数形式更新的 useState 一样的效果，也是在更新时在当前的 state 基础上进行操作。 62.React 中 useState 是如何做数据初始化的？答：一个函数组件，在 react 执行渲染时该函数都会被调用，所以函数内的 useState 在每次都会被调用。useState 在不同阶段，其对应的实现不一样，在 onMount 阶段：初始化 state；在 onUpdate 阶段：更新 state。useState 返回的是一个数组，数组的第二项是一个函数，该函数每次被调用后，都会触发 react 的更新。 63.列举你常用的 React 性能优化技巧？答： 使用 shouldComponentUpdate 规避冗余的更新逻辑 PureComponent + Immutable.js React.memo 与 useMemo 64.Vue 2.x 模板中的指令是如何解析实现的？答：指令本质上就是一个 JavaScript 对象，对象上挂着一些钩子函数，无论是官方提供的指令，还是自定义指令，一个指令从第一次被绑定到元素上到最终与被绑定的元素解绑，它会经过以下几种状态： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 了每个状态的钩子函数，这样我们就可以让指令在不同状态下做不同的事情。当虚拟 DOM 渲染更新的时候会触发 create、update、destory 这三个钩子函数，从而就会执行 updateDirectives 函数来处理指令的相关逻辑，执行指令函数，让指令生效。 65.简要说明 Vue 2.x 的全链路运作机制？答： 初始化以及挂载 init, mount 在进行模板编译 compile，将 template 编译为渲染函数 render function 执行 render function 生成 Virtual DOM, render function &#x3D;&gt; VNode tree 再进行响应式依赖收集，render function &#x3D;&gt; getter, setter &#x3D;&gt; Watcher.update &#x3D;&gt; patch。以及使用队列进行异步更新的策略。 最后通过 diff 算法后进行 patch 更新视图 66.简单介绍一下 Element UI 的框架设计？答： 一个被阿里放弃维护的 UI 库。 67.如何理解 Vue 是一个渐进式框架？答： 渐进式代表的含义是：没有多做职责之外的事。 你可以使用 jsx 开发，你也可以写 template；你可以使用 vue 全家桶，你也可以把它做为某个业务的轻量视图，随你，不强求不主张。 68.Vue 里实现跨组件通信的方式有哪些？答： 父子通信： 父向子传递数据是通过 props，子向父是通过 events（emit）；通过父链&#x2F;子链也可以通信（emit）；通过父链 &#x2F; 子链也可以通信（emit）；通过父链&#x2F;子链也可以通信（parent &#x2F; children）；ref 也可以访问组件实例；provide&#x2F;injectAPI；children）；ref 也可以访问组件实例；provide &#x2F; inject API；children）；ref 也可以访问组件实例；provide&#x2F;injectAPI；attrs&#x2F;$listeners 兄弟通信： Bus；Vuex 跨级通信： Bus；Vuex；provide &#x2F; inject API、attrs&#x2F;attrs&#x2F;attrs&#x2F;listeners 69.Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？答： 使用 watch 并且搭配 deep:true 就可以实现对对象的深度监听 70.MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、答： MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式。 耦合性低 重用性高 生命周期成本低 MVP 是从经典的模式 MVC 演变而来，它们的基本思想有相通的地方 Controller&#x2F;Presenter 负责逻辑的处理，Model 提供数据，View 负责显示。 模型与视图完全分离，我们可以修改视图而不影响模型 可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter 内部 我们可以将一个 Presenter 用于多个视图，而不需要改变 Presenter 的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。 如果我们把逻辑放在 Presenter 中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试） MVVM 本质上就是 MVC 的改进版。MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。 低耦合 可重用性 独立开发 可测试 71.什么是 MVVM 框架？答：MVVM，特点是采用双向绑定(data-binding): View 的 变动，自动反映在 View Model，反之亦然。这样开发者就不用处理接收事件和 View 更新的工作，框架已经帮你做好了。 72.Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？答： 插件系统是给 vue 项目提供可选功能的 npm 包，如：Babel&#x2F;TypeScript 转译、ESLint 集成、unit 和 e2e 测试 等 73.Vue CLI 3.x 中的 Webpack 是如何组装处理的？答： 对比 vue-cli2，cli3 最主要的就是生成的项目中，进行 webpack 配置的文件没有了。cli3 的脚手架封装了 webpack 绝大部分配置，使得生成的项目更加清晰，但是在开发中免不了会有自己的个性需求，来添加一些自己的项目配置，此时只需在项目的根目录下新建一个 vue.config.js 文件即可。而 webpack 中是通过 resolve.alias 来实现此功能的。在 vue.config.js 中修改 webpack 的配置，可以通过 configureWebpack 方法。 74.Vue 2.x 如何支持 TypeScript 语法？答： 配置 ts-loader，tsconfig 增加类型扩展，让 ts 识别 vue 文件 vue 文件中 script 里面换成 ts 写法， 需要增加几个 ts 扩展的 package， 比如 vue-property-decorator 75.如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？答： 利用 Babel 的 @babel&#x2F;plugin-transform-typescript 插件来实现。 利用 ts-loader 结合官方 typescript 库来实现。 76.如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？答： ESLint 和 TSLint 都是 Javascript 的语法检查器，通常使用 ESLint 或 TSLint 用于解决团队开发上不同代码风格所带来的一系列不和谐的问题。 ESLint 支持几种格式的配置文件： JavaScript：使用 .eslintrc.js 然后输出一个配置对象。 YAML：使用 .eslintrc.yaml 或 .eslintrc.yml 去定义配置的结构。 JSON：使用 .eslintrc.json 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。 (弃用)：使用 .eslintrc，可以使 JSON 也可以是 YAML。 package.json：在 package.json 里创建一个 eslintConfig 属性，在那里定义你的配置。 TSLint 是配合 Typescript 来使用的。TSLint 执行规则的方式存在一些框架问题，从而影响性能，而修复这些问题会破坏现有的规则。ESLint 的性能更好，并且社区用户通常拥有 ESLint 的规则配置（比如 React 和 Vue 的配置），而不会拥有 TSLint 的规则配置。 77.Node.js 如何支持 TypeScript 语法？答： Node 是基于 Chrome V8 引擎开发的能使 JavaScript 在服务器端运行的运行时环境，TS 最终编译成 JS，然后生成字节码-&gt;机器码。Node.js 支持 TS 语法，有什么疑问吗，毕竟最终都是编译成 JS？ 78.TypeScript 如何自动生成库包的声明文件？答： 编译选项，在这里找到与生成相应的 .d.ts 文件和 声明文件 相关的选项，其中包括： declaration declarationDir types typeRoots 配置完 tsconfig.json 文件后，再次执行 npm run build 会在项目根目录下生成 types 文件夹，该文件夹主要存放自动生成的 TypeScript 声明文件。 79.Babel 对于 TypeScript 的支持有哪些限制？答： 在使用 babel-preset-typescript 可以使 JavaScript 与 TypeScript 并存，且在编译过程是同一阶段进行的。透过 Babel preset 配置，可以更容易的实现我们所需的 JS 项目平滑转移到 TS 项目过程。 但是，这对 Babel 有一定的要求，而不同版本的 Babel 对于 monorepo 存在相容性问题，特别是要从 subrepo 引用 module 时，会导致 Babel 的配置无法正确取得。 80.Webpack 中 Loader 和 Plugin 的区别是什么？答： 在 webpack 中 Loader 就是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，对比 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节。 81.在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？答： 1// 见试卷背面 82.发布 Npm 包如何指定引入地址？答： 1// 见试卷背面 83.如何发布开发项目的特定文件夹为 Npm 包的根目录？答： 一般情况下，npm 包的根目录时 node_modules，可以使用 package.json 的 directories 属性里的 directories.lib，更改 Npm 包的根目录。 84.如何发布一个支持 Tree Shaking 机制的 Npm 包？答： 通常人们在使用打包工具的 babel 插件编译代码时都会屏蔽掉 node_modules 目录下的文件。因为按照约定大家发布到 npm 的模块代码都是基于 ES5 规范的，因此配置 babel 插件屏蔽 node_modules 目录可以极大的提高编译速度。但用户如果使用了我们发布的基于 ES6 规范的包就必须配置复杂的屏蔽规则以便把我们的包加入编译的白名单。 如果用户是在 NodeJS 环境使用我们的包，那么极有可能连打包这一步骤都没有。如果用户的 NodeJS 环境又恰巧不支持 ES6 模块规范，那么就会导致代码报错。 基于以上两个原因，pkg.module 字段要指向的应该是一个基于 ES6 模块规范的使用 ES5 语法书写的模块。基于 ES6 模块规范是为了用户在使用我们的包时可以享受 Tree Shaking 带来的好处；使用 ES5 语法书写是为了用户在配置 babel 插件时可以放心的屏蔽 node_modules 目录。相当于在一个包内同时发布了两种模块规范的版本。 当打包工具遇到我们的模块时： 如果它已经支持 pkg.module 字段则会优先使用 ES6 模块规范的版本，这样可以启用 Tree Shaking 机制。 如果它还不识别 pkg.module 字段则会使用我们已经编译成 CommonJS 规范的版本，也不会阻碍打包流程。 85.Npm 包中 peerDependencies 的作用是什么？答： peerDependencies 的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。 86.如何优雅的调试需要发布的 Npm 包？答： 在需要调试的 npm 包目录下结构下的控制台输入 npm link 这个命令会把当前包映射到本地的一个全局的 npm 包里面； 在引用的目录结构下的控制台输入 npm link 包名称 这个命令会把本地引用的这个 npm 包的路径定位到全局的 npm 包下； 全局的 npm 包相当于一个中转站，在编辑区域与引用区域之间中转。 87.在设计一些库包时如何生成版本日志？答： npm run changelog 自动生成的版本日志信息 88.了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？答： 子模块是进行开发和需求进行对接将需求文档作为子模块项目，嵌入开发人员的项目中。子模块的使用既可以减少需求或设计人员的 git 操作，又可以及时的将 doc 文档发布到项目的目录文件下，而且不会对开发人员的项目产生任何影响。 89.Git 如何修改已经提交的 Commit 信息？答： git rebase -i &lt;commit id&gt; 列出 commit 列表 找到需要修改的 commit 记录，把 pick 修改为 edit 或 e，:wq 保存退出 修改 commit 的具体信息 git commit –amend，保存并继续下一条 git rebase –continue，直到全部完成 中间也可跳过或退出 git rebase (–skip | –abort) 90.Git 如何撤销 Commit 并保存之前的修改？答： 查看 commit git log --pretty=oneline 撤销到上一个 commit，但是保存当前的修改。git reset --soft &lt;commit&gt; 修改成功。重建分支，进行提交。 91.Git 如何 ignore 被 commit 过的文件？答： 删除 track 的文件 (已经 commit 的文件) 在 .gitignore 文件中添加忽略规则 在 .gitignore 文件中添加 ignore 条目, 如: .DS_Store 提交 .gitignore 文件: git commit -a -m “添加 ignore 规则” 推送到远程仓库让 ignore 规则对于其他开发者也能生效 92.在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？答： 用 Commitizen，Commitizen 是一个撰写符合上面 Commit Message 标准的一款工具。在 push 操作时检查 commit 的信息，使用正则检查是否匹配（比如使用 angular 的 git 规范），不符合的不允许 Push。 93.简述符合 Angular 规范的提交说明的结构组成？答： commit 格式如下: 1&lt;type&gt;: &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;type - 提交 commit 的类型 feat: 新功能 fix: 修复问题 docs: 修改文档 style: 修改代码格式(不影响逻辑功能，比如格式化、补充分号等等) refactor: 重构代码(fix bug 或增加新功能不属于此范围) perf: 提升页面性能 test: 增加&#x2F;修改测试用例 chore: 修改工具相关（包括但不限于文档、代码生成等, 比如修改了 README，webpack 配置文件等等） deps: 升级依赖 subject - 用一句话清楚的描述这次提交做了什么 body - 补充 subject，适当增加原因、目的等相关因素，可选。 94.Commit 信息如何和 Github Issues 关联？答： 当你提交一个 commit 的时候在 commit message 里面使用#issue, 比如#8, github 就会自动关联 issue 8 跟这个 commit. 当然在 github 上面写 comment 的时候使用这个也是有效的，在 confirm merge 的时候可以使用一下命令来关闭相关 issue。 1fixes #xxxfixed #xxxfix #xxxcloses #xxxclose #xxxclosed #xxx 95.Git Hook 在项目中哪些作用？答： Git Hooks 是定制化的脚本程序，所以它实现的功能与相应的 git 动作相关,如下几个简单例子： 多人开发代码语法、规范强制统一 commit message 格式化、是否符合某种规范 如果有需要，测试用例的检测 服务器代码有新的更新的时候通知所有开发成员 代码提交后的项目自动打包（git receive 之后） 等等… 96.Git Hook 中客户端和服务端钩子各自用于什么作用？答： 客户端钩子由诸如提交和合并这样的操作所调用， 而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 97.Git Hook 中常用的钩子有哪些？答： ClientSide hooks： pre-commit，当执行 commit 动作时先执行此 hook，可以用此 hook 做一些检查，比如代码风格检查，或者先跑测试。 prepare-commit-msg， 当 commit 时需要输入 message 前会触发此 hook，可以用此 hook 来定制自己的 default message 信息。 commit-msg，当用户输入 commit 的 message 后被触发，可以用此 hook 校验 message 的信息，比如是否符合规定，有没有 cr 等。 post-commit, 当 commit 完成后被触发，可以用此 hook 发送 notification 等。 pre-rebase, rebase 之前会被触发，可以用此 hook 来拒绝所有的已经 push 的 commits 进行 rebase 操作。 post-merge, 当 merge 成功后，会触发此 hook。 pre-push, 当 push 时，remote refs 被更新，但是在所有的 objects 传输前被触发。 pre-auto-gc, 当 git gc –auto 执行前被触发。在垃圾回收之前做一些验证或备份是挺不错的。 ServerSide hooks: pre-receive, 当收到 push 动作之前会被执行。 update, 也是收到 push 动作之前被执行，但是有可能被执行多次，每个 branch 一次。 post-receive, 当 push 动作已经完成的时候会被触发，可以用此 hook 来 push notification 等，比如发邮件，通知持续构建服务器等。 98.pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？答： pre-commit 是客户端 hooks 之一，也是接下来要介绍的钩子。pre-commit 在 git add 提交之后，然后执行 git commit 时执行，脚本执行没报错就继续提交，反之就驳回提交的操作。这个钩子中可以实现：对将要提交的代码进行检查、优化代码格式、或者对提交的图片进行压缩等等任务。 Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。 99.husky 以及 ghook 等工具制作 Git Hook 的原理是什么？答： 代码提交之前会通过 husky 配合 git hook 进行提交信息校验，一旦提交信息不符合 Angular 规范，则提交会失败。 100.如何设计一个通用的 Git Hook ？答： 借助 Commitizen，使用 git cz 代替 git commit 进行复合 Angular 规范的 Commit Message 信息提交，规范团队的 git 规范。代码提交之前会通过 husky 配合 git hook 进行提交信息校验，一旦提交信息不符合 团队的 git 规范，正则匹配失败，则提交会失败。 101.Git Hook 可以采用 Node 脚本进行设计吗？如何做到？答： 可以。钩子都被存储在 Git 目录下的 hooks 子目录中。也即绝大部分项目中的 .git&#x2F;hooks 。当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。 比如说用 Node.js 来写一个拒绝提交没有被解决的冲突的文件的钩子，写这个钩子的初衷是因为在多人合作项目中，总是难免会遇到文件冲突的情况，而有些同事没有找到全部的冲突文件并一一解决，这个钩子就会在 commit 的时候检查是否有冲突，如果有冲突，就会把所有冲突找到，并提示出错文件后，拒绝 commit。 12345678910111213141516171819202122232425#!/usr/bin/env node// 在 commit 之前检查是否有冲突，如果有冲突就 process.exit(1)const execSync = require(&#x27;child_process&#x27;).execSync// git 对所有冲突的地方都会生成下面这种格式的信息，所以写个检测冲突文件的正则const isConflictRegular = &quot;^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\\\s&quot;let resultstry &#123; // git grep 命令会执行 perl 的正则匹配所有满足冲突条件的文件 results = execSync(`git grep -n -P &quot;$&#123;isConflictRegular&#125;&quot;`, &#123;encoding: &#x27;utf-8&#x27;&#125;)&#125; catch (e) &#123; console.log(&#x27;没有发现冲突，等待 commit&#x27;) process.exit(0)&#125;if(results) &#123; console.error(&#x27;发现冲突，请解决后再提交，冲突文件：&#x27;) console.error(results.trim()) process.exit(1)&#125;process.exit(0) 把这个文件拷贝到 .git&#x2F;hooks&#x2F;pre-commit 下，并执行 chmod 777 pre-commit 就可以在每次 commit 的情况下检查之前文件是否有冲突。 102.如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？答： 在使用 cli 构建项目时，勾选 Use ESLint to lint your code。在 .eslintrc.js 文件里，找到文件中的 rules，我们可以在其中定义一些代码检查的规则 1&#x27;semi&#x27;: [&#x27;error&#x27;, &#x27;always&#x27;] 常用规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&#x27;rules&#x27;: &#123; &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;never&quot;], //是否允许对象中出现结尾逗号 &quot;no-cond-assign&quot;: 2, //条件语句的条件中不允许出现赋值运算符 &quot;no-console&quot;: 2, //不允许出现console语句 &quot;no-constant-condition&quot;: 2, //条件语句的条件中不允许出现恒定不变的量 &quot;no-control-regex&quot;: 2, //正则表达式中不允许出现控制字符 &quot;no-debugger&quot;: 2, //不允许出现debugger语句 &quot;no-dupe-args&quot;: 2, //函数定义的时候不允许出现重复的参数 &quot;no-dupe-keys&quot;: 2, //对象中不允许出现重复的键 &quot;no-duplicate-case&quot;: 2, //switch语句中不允许出现重复的case标签 &quot;no-empty&quot;: 2, //不允许出现空的代码块 &quot;no-empty-character-class&quot;: 2, //正则表达式中不允许出现空的字符组 &quot;no-ex-assign&quot;: 2, //在try catch语句中不允许重新分配异常变量 &quot;no-extra-boolean-cast&quot;: 2, //不允许出现不必要的布尔值转换 &quot;no-extra-parens&quot;: 0, //不允许出现不必要的圆括号 &quot;no-extra-semi&quot;: 2, //不允许出现不必要的分号 &quot;no-func-assign&quot;: 2, //不允许重新分配函数声明 &quot;no-inner-declarations&quot;: [&quot;error&quot;, &quot;functions&quot;], //不允许在嵌套代码块里声明函数 &quot;no-invalid-regexp&quot;: 2, //不允许在RegExp构造函数里出现无效的正则表达式 &quot;no-irregular-whitespace&quot;: 2, //不允许出现不规则的空格 &quot;no-negated-in-lhs&quot;: 2, //不允许在in表达式语句中对最左边的运算数使用取反操作 &quot;no-obj-calls&quot;: 2, //不允许把全局对象属性当做函数来调用 &quot;no-regex-spaces&quot;: 2, //正则表达式中不允许出现多个连续空格 &quot;quote-props&quot;: 2, //对象中的属性名是否需要用引号引起来 &quot;no-sparse-arrays&quot;: 2, //数组中不允许出现空位置 &quot;no-unreachable&quot;: 2, //在return，throw，continue，break语句后不允许出现不可能到达的语句 &quot;use-isnan&quot;: 2, //要求检查NaN的时候使用isNaN() &quot;valid-jsdoc&quot;: [&quot;error&quot;, &#123; &quot;requireReturn&quot;: false, &quot;requireParamDescription&quot;: false, &quot;requireReturnDescription&quot;: true &#125;], //强制JSDoc注释 &quot;valid-typeof&quot;: [&quot;error&quot;, &#123; &quot;requireStringLiterals&quot;: true &#125;], //在使用typeof表达式比较的时候强制使用有效的字符串 &quot;block-scoped-var&quot;: 2, //将变量声明放在合适的代码块里 &quot;complexity&quot;: 0, //限制条件语句的复杂度 &quot;consistent-return&quot;: 2, //无论有没有返回值都强制要求return语句返回一个值 &quot;curly&quot;: [&quot;error&quot;, &quot;all&quot;], //强制使用花括号的风格 &quot;default-case&quot;: 0, //在switch语句中需要有default语句 &quot;dot-notation&quot;: [&quot;error&quot;, &#123;&quot;allowKeywords&quot;: false, &quot;allowPattern&quot;: &quot;&quot;&#125;], //获取对象属性的时候使用点号 &quot;eqeqeq&quot;: [&quot;error&quot;, &quot;smart&quot;], //比较的时候使用严格等于 &quot;no-alert&quot;: 1, //不允许使用alert，confirm，prompt语句 &quot;no-caller&quot;: 2, //不允许使用arguments.callee和arguments.caller属性 &quot;guard-for-in&quot;: 0, //监视for in循环，防止出现不可预料的情况 &quot;no-div-regex&quot;: 2, //不能使用看起来像除法的正则表达式 &quot;no-else-return&quot;: 0, //如果if语句有return，else里的return不用放在else里 &quot;no-labels&quot;: [&quot;error&quot;, &#123; &quot;allowLoop&quot;: false, &quot;allowSwitch&quot;: false &#125;], //不允许标签语句 &quot;no-eq-null&quot;: 2, //不允许对null用==或者!= &quot;no-eval&quot;: 2, //不允许使用eval() &quot;no-extend-native&quot;: 2, //不允许扩展原生对象 &quot;no-extra-bind&quot;: 2, //不允许不必要的函数绑定 &quot;no-fallthrough&quot;: 2, //不允许switch按顺序全部执行所有case &quot;no-floating-decimal&quot;: 2, //不允许浮点数缺失数字 &quot;no-implied-eval&quot;: 2, //不允许使用隐式eval() &quot;no-iterator&quot;: 2, //不允许使用__iterator__属性 &quot;no-lone-blocks&quot;: 2, //不允许不必要的嵌套代码块 &quot;no-loop-func&quot;: 2, //不允许在循环语句中进行函数声明 &quot;no-multi-spaces&quot;: 2, //不允许出现多余的空格 &quot;no-multi-str&quot;: 2, //不允许用\\来让字符串换行 &quot;no-global-assign&quot;: 2, //不允许重新分配原生对象 &quot;no-new&quot;: 2, //不允许new一个实例后不赋值或者不比较 &quot;no-new-func&quot;: 2, //不允许使用new Function &quot;no-new-wrappers&quot;: 2, //不允许使用new String，Number和Boolean对象 &quot;no-octal&quot;: 2, //不允许使用八进制字面值 &quot;no-octal-escape&quot;: 2, //不允许使用八进制转义序列 &quot;no-param-reassign&quot;: 0, //不允许重新分配函数参数&quot;no-proto&quot;: 2, //不允许使用__proto__属性 &quot;no-redeclare&quot;: 2, //不允许变量重复声明 &quot;no-return-assign&quot;: 2, //不允许在return语句中使用分配语句 &quot;no-script-url&quot;: 2, //不允许使用javascript:void(0) &quot;no-self-compare&quot;: 2, //不允许自己和自己比较 &quot;no-sequences&quot;: 2, //不允许使用逗号表达式 &quot;no-throw-literal&quot;: 2, //不允许抛出字面量错误 throw &quot;error&quot; &quot;no-unused-expressions&quot;: 2, //不允许无用的表达式 &quot;no-void&quot;: 2, //不允许void操作符 &quot;no-warning-comments&quot;: [1, &#123;&quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;any other term&quot;]&#125;], //不允许警告备注 &quot;no-with&quot;: 2, //不允许使用with语句 &quot;radix&quot;: 1, //使用parseInt时强制使用基数来指定是十进制还是其他进制 &quot;vars-on-top&quot;: 0, //var必须放在作用域顶部 &quot;wrap-iife&quot;: [2, &quot;any&quot;], //立即执行表达式的括号风格 &quot;yoda&quot;: [2, &quot;never&quot;, &#123;&quot;exceptRange&quot;: true&#125;], //不允许在if条件中使用yoda条件 &quot;strict&quot;: [2, &quot;function&quot;], //使用严格模式 &quot;no-catch-shadow&quot;: 2, //不允许try catch语句接受的err变量与外部变量重名&quot;no-delete-var&quot;: 2, //不允许使用delete操作符 &quot;no-label-var&quot;: 2, //不允许标签和变量同名 &quot;no-shadow&quot;: 2, //外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2, //js关键字和保留字不能作为函数名或者变量名 &quot;no-undef&quot;: 2, //不允许未声明的变量 &quot;no-undef-init&quot;: 2, //不允许初始化变量时给变量赋值undefined &quot;no-undefined&quot;: 2, //不允许把undefined当做标识符使用 &quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;], //不允许有声明后未使用的变量或者参数 &quot;no-use-before-define&quot;: [2, &quot;nofunc&quot;], //不允许在未定义之前就使用变量&quot;indent&quot;: 2, //强制一致的缩进风格 &quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123; &quot;allowSingleLine&quot;: false&#125;], //大括号风格 &quot;camelcase&quot;: [2, &#123;&quot;properties&quot;: &quot;never&quot;&#125;], //强制驼峰命名规则 &quot;comma-style&quot;: [2, &quot;last&quot;], //逗号风格 &quot;consistent-this&quot;: [0, &quot;self&quot;], //当获取当前环境的this是用一样的风格 &quot;eol-last&quot;: 2, //文件以换行符结束 &quot;func-names&quot;: 0, //函数表达式必须有名字 &quot;func-style&quot;: 0, //函数风格，规定只能使用函数声明或者函数表达式 &quot;key-spacing&quot;: [2, &#123;&quot;beforeColon&quot;: false, &quot;afterColon&quot;: true&#125;], //对象字面量中冒号的前后空格 &quot;max-nested-callbacks&quot;: 0, //回调嵌套深度 &quot;new-cap&quot;: [2, &#123;&quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false&#125;], //构造函数名字首字母要大写 &quot;new-parens&quot;: 2, //new时构造函数必须有小括号 &quot;newline-after-var&quot;: 0, //变量声明后必须空一行 &quot;no-array-constructor&quot;: 2, //不允许使用数组构造器 &quot;no-inline-comments&quot;: 0, //不允许行内注释 &quot;no-lonely-if&quot;: 0, //不允许else语句内只有if语句 &quot;no-mixed-spaces-and-tabs&quot;: [2, &quot;smart-tabs&quot;], //不允许混用tab和空格 &quot;no-multiple-empty-lines&quot;: [2, &#123;&quot;max&quot;: 2&#125;], //空行最多不能超过两行 &quot;no-nested-ternary&quot;: 2, //不允许使用嵌套的三目运算符 &quot;no-new-object&quot;: 2, //禁止使用new Object() &quot;fun-call-spacing&quot;: 2, //函数调用时，函数名与()之间不能有空格 &quot;no-ternary&quot;: 0, //不允许使用三目运算符 &quot;no-trailing-spaces&quot;: 2, //一行最后不允许有空格 &quot;no-underscore-dangle&quot;: 2, //不允许标识符以下划线开头 &quot;no-extra-parens&quot;: 0, //不允许出现多余的括号 &quot;one-var&quot;: 0, //强制变量声明放在一起 &quot;operator-assignment&quot;: 0, //赋值运算符的风格 &quot;padded-blocks&quot;: [2, &quot;never&quot;], //块内行首行尾是否空行 &quot;quote-props&quot;: 0, //对象字面量中属性名加引号 &quot;quotes&quot;: [1, &quot;single&quot;, &quot;avoid-escape&quot;], //引号风格 &quot;semi&quot;: [2, &quot;always&quot;], //强制语句分号结尾 &quot;semi-spacing&quot;: [2, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;], //分后前后空格 &quot;sort-vars&quot;: 0, //变量声明时排序 &quot;space-before-blocks&quot;: [2, &quot;always&quot;], //块前的空格 &quot;space-before-function-paren&quot;: [2, &#123;&quot;anonymous&quot;: &quot;always&quot;, &quot;named&quot;: &quot;never&quot;&#125;], //函数定义时括号前的空格 &quot;space-infix-ops&quot;: [2, &#123;&quot;int32Hint&quot;: true&#125;], //操作符周围的空格 &quot;keyword-spacing&quot;: 2, //关键字前后的空格 &quot;space-unary-ops&quot;: [2, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false&#125;], //一元运算符前后不要加空格 &quot;wrap-regex&quot;: 2, //正则表达式字面量用括号括起来 &quot;no-var&quot;: 0, //使用let和const代替var &quot;generator-star-spacing&quot;: [2, &quot;both&quot;], //生成器函数前后空格 &quot;max-depth&quot;: 0, //嵌套块深度 &quot;max-len&quot;: 0, //一行最大长度，单位为字符 &quot;max-params&quot;: 0, //函数最多能有多少个参数 &quot;max-statements&quot;: 0, //函数内最多有几个声明 &quot;no-bitwise&quot;: 0, //不允许使用位运算符 &quot;no-plusplus&quot;: 0 //不允许使用++ --运算符 &#125; 103.如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？答： 打开终端，运行 npm install eslint -g 全局安装 ESLint。 vscode 安装插件 scode 扩展设置 104.ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？答： 这俩解决的不是一个问题，ESLint 主要解决的是代码质量问题;Prettier 主要解决的是代码风格问题。两者在一起会产生问题。 需要解决：首先我们需要使用 eslint-config-prettier 来关掉 (disable) 所有和 Prettier 冲突的 ESLint 的配置（这部分配置就是上面说的，格式问题的配置，所以关掉不会有问题），方法就是在 .eslintrc 里面将 prettier 设为最后一个 extends。 1234// .eslintrc&#123; &quot;extends&quot;: [&quot;prettier&quot;] // prettier 一定要是最后一个，才能确保覆盖&#125; (可选，推荐) 然后再启用 eslint-plugin-prettier ，将 prettier 的 rules 以插件的形式加入到 ESLint 里面。这里插一句，为什么”可选” ？当你使用 Prettier + ESLint 的时候，其实格式问题两个都有参与，disable ESLint 之后，其实格式的问题已经全部由 prettier 接手了。那我们为什么还要这个 plugin？其实是因为我们期望报错的来源依旧是 ESLint ，使用这个，相当于把 Prettier 推荐的格式问题的配置以 ESLint rules 的方式写入，这样相当于可以统一代码问题的来源。 1234567// .eslintrc&#123; &quot;plugins&quot;: [&quot;prettier&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot; &#125;&#125; 将上面两个步骤和在一起就是下面的配置，也是官方的推荐配置 1234// .eslintrc&#123; &quot;extends&quot;: [&quot;plugin:prettier/recommended&quot;]&#125; 105.如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？答： 鼠标右键，选择文档格式设置方式。 在弹出的下拉列表中选择 prettier。这时已经使用了 prettier 格式化了代码。 ctrl+shift+p,然后下拉列表中选择格式化文档。 假设你的默认格式化程序是 prettier，那么稍作改变即可，相信你已经知道怎样操作，不再赘述。这样，你先使用 prettier 格式化了代码，再使用 eslint 去纠正了不符合 eslint 规则的部分，就实现了两者冲突的解决。 106.在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？答： Ctrl+s &#x2F; command+s 时自动修复代码的格式错误,自动修复的规则是读取项目根目录的 Eslint 规则。 107.谈谈你对 SourceMap 的了解？答： sourceMap 就是一个信息文件，里面储存着打包前的位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，浏览器控制台将直接显示原始代码出错的位置，而不是转换后的代码，点击出错信息将直接跳转到原始代码位置。方便定位和解决问题。 108.如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？答： 从 nodejs8 开始,node 去掉了_debugger , 内部集成了 inspect , 以往使用 node-inspect 实现的在线调试不再可用.node8 开始要用新方法了。 在服务端用 inspect 模式运行 nodejs 1node --inspect-brk=0.0.0.0:8080 index.js 打开 chrome 浏览器 地址栏输入chrome://inspect,在弹出的界面中输入 ip:port 即可调试。 109.列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？答： Grunt、Gulp、Webpack、vite、Rollup 110.VS Code 配置中的用户和工作区有什么区别？答： VS Code 提供了两种设置方式： 用户设置：这种方式进行的设置，会应用于该用户打开的所有工程； 工作空间设置：工作空间是指使用 VS Code 打开的某个文件夹，在该文件夹下会创建一个名为.vscode 的隐藏文件夹，里面包含着仅适用于当前目录的 VS Code 的设置，工作空间的设置会覆盖用户的设置。 “用户设置”会应用于用户打开的所有工程； “工作区设置”仅适用于当前目录的 VS Code 的设置。 111.VS Code 的插件可以只对当前项目生效吗？答： 当然不是。 112.你所知道的测试有哪些测试类型？答： 功能测试,性能测试,界面测试 113.你所知道的测试框架有哪些？答： Selenium、cypress、Appium 、Requests、Jmeter、Mitmproxy 114.什么是 e2e 测试？有哪些 e2e 的测试框架？答： 端到端测试； cypress 、Selenium 、puppeteer、nightwatch 115.假设现在有一个插入排序算法，如何对该算法进行单元测试？答： 1// 见试卷背面 116.CDN 服务如何实现网络加速？答： CDN 的工作原理就是将您源站的资源缓存到位于全球各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。 117.WebSocket 使用的是 TCP 还是 UDP 协议？答： 是基于 TCP 的,websocket 的协议是在 TCP&#x2F;IP 协议簇的应用层，和 http 在同一层。 118.什么是单工、半双工和全双工通信？答： 单工数据传输只支持数据在一个方向上传输; 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信； 全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 119.简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路）答：略（内容太多） 简单回答一个不全的答案，剩下需要深入的等面试官一个一个问： 浏览器通过请求得到一个 HTML 文本 渲染进程解析 HTML 文本，构建 DOM 树 解析 HTML 的同时，如果遇到内联样式或者样式脚本，则下载并构建样式规则（stytle rules），若遇到 JavaScript 脚本，则会下载执行脚本。 DOM 树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree） 渲染进程开始对渲染树进行布局，生成布局树（layout tree） 渲染进程对布局树进行绘制，生成绘制记录 渲染进程的对布局树进行分层，分别栅格化每一层，并得到合成帧 渲染进程将合成帧信息发送给 GPU 进程显示到页面中 120.什么是正向代理？什么是反向代理？答： 代理其本质上可以理解为中介。当 A 和 B 不方便进行交互时，往往会引入一个中间角色 C，那么 C 便是中介，便是代理。 正向代理服务器通常位于客户端和服务器之间，类似一个跳板机，通过代理服务器可以访问到目标服务器。 正向代理时，通常，客户端发送对目标服务器的请求，代理服务器在中间将请求转发给目标服务器，并将结果返回给客户端。 反向代理与正向代理恰好相反，代理服务位于服务器端。 对客户端来说，反向代理服务器就好像是目标服务器。反向代理服务器接收客户端发来的请求，然后将其分发到内网的服务器，并将内网服务器返回的结果返回给客户端。 整个过程客户端并不会感知到反向代理后面的服务，也不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就行。 121.Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？答： 可以。HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。 122.Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？答： Session 客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。 Cookies HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。 服务器端 session,如果你不指定 session 的存储时间，在你打开的浏览器中存储的值，是可以在新打开的框口内得到的，关闭后就自动消失（消失的其实是 session_id,因为 session 的机制是依赖于 cookie 的（还可以依赖其他的）。 123.设置 Cookie 时候如何防止 XSS 攻击？答： 在服务器端设置 cookie 的时候设置 http-only, 这样就可以防止用户通过 JS 获取 cookie。对 cookie 的读写或发送一般有如下字段进行设置： http-only: 只允许 http 或 https 请求读取 cookie、JS 代码是无法读取 cookie 的(document.cookie 会显示 http-only 的 cookie 项被自动过滤掉)。发送请求时自动发送 cookie. secure-only: 只允许 https 请求读取，发送请求时自动发送 cookie。 host-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie。 设置 Cookie，可以防止攻击者拿到正常用户的 Cookie 冒充身份非法调用网站接口。 124.简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？答： 在用户第一次登录成功的时候，后端会返回一个 Token，这个值 Token 主要的作用就是用于识别用户的身份。相当于账号密码。正常情况下，前端给后端发送请求的时候，后端都需要先判断用户的身份，来返回相应的数据给用户。获取到 Token 后，你需要把 Token 存在 Cookie 中。接着向服务器发送请求时，你从 Cookie 中取出 Token，在请求头中携带上 Token 。Token 过期时间设置足够长，只要 token 没过期，这段时间用户都是免登录。 安全问题：其他人使用本机，实现免登录，无法在每次使用应用时验证用户的身份。提供了便捷，失去了安全校验。 对用户登录的密码进行加密，密码 MD5 化，不使用明文传输。 125.HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？答： 使用压缩技术把实体主体压小，在客户端再把数据解析。 使用分块传输编码，将实体主体分块传输，当浏览器解析到实体主体就能够显示了。 常用的内容编码方式： 非归零码 曼彻斯特编码 差分曼彻斯特编码 126.传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？答： 文件的断点续传， 前端工作 为每一个文件切割块添加不同的标识 当上传成功的之后，记录上传成功的标识 当我们暂停或者发送失败后，可以重新发送没有上传成功的切割文件 后端工作 接收每一个切割文件，并在接收成功后，存到指定位置，并告诉前端接收成功 收到合并信号，将所有的切割文件排序，合并，生成最终的大文件，然后删除切割小文件，并告知前端大文件的地址 127.什么是代理？什么是网关？代理和网关的作用是什么？答： 代理是中间人，使用代理的主机发出的 IP 报文的目的 IP 是代理的，但是会在应用层里明确告诉代理，自己真实需求是什么。网关即 Gateway，它是连接基于不同通信协议的网络的设备，使文件可以在这些网络之间传输。 128.HTTPS 相比 HTTP 为什么更加安全可靠？答： 因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性（具体细节二面再说）。不过需要注意的是，即便使用 HTTPS 仍可能会被抓包，因为 HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。 129.什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？答： 传统的对称式加密需要通讯双方都保存同一份密钥，通过这份密钥进行加密和解密。所以非对称加密也称为单密钥加密。在非对称加密中，加密和解密使用的是不同的密钥。非对称加密中的密钥分为公钥和私钥。公钥顾名思义就是公开的，任何人都可以通过公钥进行信息加密，但是只有用户私钥的人才能完成信息解密。非对称加密带来了一个好处，避免了对称式加密需要传输和保存同一份密钥的痛苦。 非对称加密一定比对称加密机密性更高吗? 不一定, 因为机密性高低是根据秘钥长度而变化的。而且非对称加密最大的问题，就是性能较差，无法应用于长期的通信。 130.你觉得 HTTP 协议目前存在哪些缺点？答： HTTP 不具备必要的安全功能，与最初的设计相比，现今的 Web 网站应用的 HTTP 协议的使用方式已发生了翻天覆地的变化。几乎现今所有的 Web 网站都会使用会话(session)管理、加密处理等安全性方面的功能，而 HTTP 协议内并不具备这些功能。 从整体上看，HTTP 就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势。就拿远程登录时会用到的 SSH 协议来说，SSH 具备协议级别的认证及会话管理等功能，HTTP 协议则没有。另外在架设 SSH 服务方面，任何人都可以轻易地创建安全等级高的服务，而 HTTP 即使已架设好服务器，但若想提供服务器基础上的 Web 应用，很多情况下都需要重新开发。 因此，开发者需要自行设计并开发认证及会话管理功能来满足 Web 应用的安全。而自行设计就意味着会出现各种形形色色的实现。结果，安全等级并不完备，可仍在运作的 Web 应用背后却隐藏着各种容易被攻击者滥用的安全漏洞的 Bug。 131.在 React 中如何识别一个表单项里的表单做到了最小粒度 &#x2F; 代价的渲染？答： 首先，最小粒度 &#x2F; 代价的渲染的表单项 or 组件应该具备什么样的特性: 简单易用 父组件可通过代码操作表单数据 避免不必要的组件重绘 支持自定义组件 支持表单校验 而这个表单项 or 组件实现起来主要分为三部分： Form：用于传递表单上下文。 Field：表单域组件，用于自动传入 value 和 onChange 到表单组件。 FormStore：存储表单数据，封装相关操作。 为了能减少使用 ref，同时又能操作表单数据（取值、修改值、手动校验等），我将用于存储数据的 FormStore，从 Form 组件中分离出来，通过 new FormStore()创建并手动传入 Form 组件。 符合以上标准，就可以认为这个表单做到了最小粒度&#x2F;最小代价的渲染。 对于有大量表单的页面，可以使用 Lighthouse 作为衡量工具，来排查和优化页面。 132.在 React 的开发的过程中你能想到哪些控制渲染成本的方法？答： 使用 shouldComponentUpdate 规避冗余的更新逻辑 PureComponent + Immutable.js React.memo 与 useMemo 使用 useMemo，我们可以对函数组件的执行逻辑进行更加细粒度的管控（尤其是定向规避掉一些高开销的计算），同时也弥补了 React.memo 无法感知函数内部状态的遗憾，这对我们整体的性能提升是大有裨益的。 133.Vue CLI 3.x 的插件系统是如何设计的？答： Vue-cli@3.0[2] 采用了一套基于插件的架构，它将部分核心功能收敛至 CLI 内部，同时对开发者暴露可拓展的 API 以供开发者对 CLI 的功能进行灵活的拓展和配置。 整个插件系统当中包含 2 个重要的组成部分： @vue&#x2F;cli，提供 cli 命令服务，例如 vue create 创建一个新的项目； @vue&#x2F;cli 提供 vue cli 命令，负责偏好设置，生成模板、安装插件依赖的工作，例如 vue create &lt;projectName&gt; 、 vue add &lt;pluginName&gt; @vue&#x2F;cli-service，提供了本地开发构建服务。 @vue&#x2F;cli-service 作为 @vue&#x2F;cli 整个插件系统当中的内部核心插件，提供了 webpack 配置更新，本地开发构建服务 前者主要完成了对于插件的依赖管理，项目模板的拓展等，后者主要是提供了在运行时本地开发构建的服务，同时后者也作为 @vue&#x2F;cli 整个插件系统当中的内部核心插件而存在。在插件系统内部也对核心功能进行了插件化的拆解，例如 @vue&#x2F;cli-service 内置的基础 webpack 配置，npm script 命令等。 @vue&#x2F;cli-service 插件系统当中几个核心的模块： Service.js 提供服务的基类，它提供了 @vue&#x2F;cli 生态当中本地开发构建时：插件加载(包括内部插件和项目应用插件)、插件的初始化，它的单例被所有的插件所共享，插件使用它的单例去完成 webpack 的更新。 PluginAPI.js 提供供插件使用的对象接口，它和插件是一一对应的关系。所有供 @vue&#x2F;cli-service 使用的本地开发构建的插件接收的第一个参数都是 PluginAPI 的实例（ api ），插件使用这个实例去完成 CLI 命令的注册及对应服务的执行、webpack 配置的更新等。 134.Webpack 中的插件机制是如何设计的？答： Webpack 插件机制的目的是为了增强 Webpack 在项目自动化构建方面的能力。在 webpack 中 Loader 就是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，对比 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节。 Webpack 的插件机制就是我们在软件开发中最常见的钩子机制。钩子机制也特别容易理解，它有点类似于 Web 中的事件。在 Webpack 整个工作过程会有很多环节，为了便于插件的扩展，Webpack 几乎在每一个环节都埋下了一个钩子。这样我们在开发插件的时候，通过往这些不同节点上挂载不同的任务，就可以轻松扩展 Webpack 的能力。 135.\\r （CRLF） 和 （LF）的区别是什么？(Vs Code 的右下角可以切换)答： \\r 表示回车并换行 (则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧) 表示换行 136.&#x2F;dev&#x2F;null 的作用是啥？答： &#x2F;dev&#x2F;null:表示 的是一个黑洞，通常用于丢弃不需要的数据输出， 或者用于输入流的空文件 将无用的输出流写入到黑洞丢弃。 curl -Iwww.baidu.com 2&gt;&#x2F;dev&#x2F;null | head -l 错误信息定位到黑洞 清空文件 cat &#x2F;dev&#x2F;null &gt; &#x2F;home&#x2F;omc&#x2F;h.txt 在书写定时任务总，规范的写法就是将所有定时任务脚本结尾加上&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃。 137.如何在 Mac 的终端中设置一个命令的别名？答： 打开编辑.bash_profile 配置别名 1alias dev=&quot;npm run dev&quot; 保存之后重新打开 terminal 或者执行 138.如何在 Windows 中设置环境变量？答： 查看当前所有可用的环境变量：输入 set 即可查看。 查看某个环境变量：输入 “set 变量名”即可，比如想查看 path 变量的值，即输入 set path 修改环境变量 ：输入 “set 变量名&#x3D;变量内容”即可 修改变量（设置为空：如果想将某一变量设置为空，输入“set 变量名&#x3D;”即可。修改成其他值：输入“set 变量名&#x3D;%变量名%;变量内容”） 139.Mac 的文件操作系统默认区分文件路径的大小写吗？答： 默认不区分，想要区分，就在重装系统 or 单独分区的时候，选择 MAC OS 扩展（区分大小写，日志格式） 140.编写 Shell 脚本时如何设置文件的绝对路径？答： 1SHELL_FOLDER=$(dirname $(readlink -f &quot;$0&quot;)) 141.Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？答： Session 客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。 Cookies HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。 服务器端 session,如果你不指定 session 的存储时间，在你打开的浏览器中存储的值，是可以在新打开的框口内得到的，关闭后就自动消失（消失的其实是 session_id,因为 session 的机制是依赖于 cookie 的（还可以依赖其他的）。 142.如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？答： 题目太大，篇幅有限，略。 143.如何提升 Node.js 代码的运行稳定性？答： 保障进程安全 由于一个用户的异常访问或者数据异常，加上没有做好异常处理和安全保护，直接导致了整个 Node.js 服务重启了，从而中断了所有人的请求，用户体验非常差。① 由于 Node.js 使用的是 JavaScript，而 JavaScript 是一个弱类型语言，因此在现网经常会引发一些由代码逻辑的异常导致的进程异常退出。② 其次在 Node.js 中也经常会因为内存的使用不当，导致内存泄漏，当在 64 位系统中达到 1.4 G（32 位系统 0.7 G）时，Node.js 就会异常崩溃。③ 再而由于 Node.js 的 I&#x2F;O 较多也较为频繁，当启用较多 I&#x2F;O 句柄，但是没有及时释放，同样会引发进程问题。 parameters error 关于 JSON.parse 很多时候我们都比较自然地将其他接口或者第三方的数据拿来解析，但是这里往往会忽略其非 JSON 字符串的问题，在这里需要进行 try catch 异常判断。 other errors 当前 Node.js 的 Promise 应用越来越广泛了，因此对于 Promise 的 catch 也应该多进行重视，对于每个 Promise 都应该要处理其异常 catch 逻辑，不然系统会提示 warning 信息。还有一些常见的长连接的服务，比如 Socket、Redis、Memcache 等等，我们需要在连接异常时进行处理，如果没有处理同样会导致异常，比如 Socket 提供了 Socket.on(‘error’) 的监听。 注意服务异常方面的内存泄露 设置最大临时缓存数，超出则不使用缓存；设置最大缓存句柄数，超出则不使用缓存；定时清理当前的临时缓存和句柄缓存。 避免全局变量 一般情况下不建议使用全局变量，全局变量必须要有一定的上限和清理规则才能保证服务的安全。 避免单例模块中的变量内存泄漏 要注意一个点，有些模块我们使用单例的模式，就是在每次 require 后都返回这个对象，这种情况也比较容易引发内存泄漏的问题。因为单例模式会引发每个用户访问的数据的叠加。 主动关闭打开文件后未关闭的情况 一般打开文件句柄后，我们都应该主动关闭，如果未主动关闭，就会导致文件句柄越来越多，从而引发句柄泄漏问题。 144.GraphQL 与 Restful 的区别，它有什么优点？答： QraphQL 是对后端 REST API 向业务层的聚合与裁剪，REST 更关注对业务细粒度的拆分与重用。 其实就是增加了一个中间层对前端的请求和响应做预处理和后处理，前端的工作少了，后端的工作也没多，却加入了中端的依赖，好处是避免前端和后端的多次远距离的交互。而 graphql 存在一个很难控制的问题就是查询复杂度。在开发过程中需要把控好解析粒度，而就目前主流关系型数据库，restful api 依旧是最好的选择。graphql 准确的说在查询图结构数据时更有优势，这也是其名称的主意。 145.Vue SSR 的工作原理？Vuex 的数据如何同构渲染？答： 在 Vue SSR 中，创建 Vue 实例、创建 store 和创建 router 都是套了一层工厂函数的，目的就是避免数据的交叉污染。在服务端只能执行生命周期中的 created 和 beforeCreate，原因是在服务端是无法操纵 dom。服务端渲染和客户端渲染不同，需要创建两个 entry 分别跑在服务端和客户端，并且需要 webpack 对其分别打包；SSR 服务端请求不带 cookie，需要手动拿到浏览器的 cookie 传给服务端的请求。SSR 要求 dom 结构规范，因为浏览器会自动给 HTML 添加一些结构比如 tbody，但是客户端进行混淆服务端放回的 HTML 时，不会添加这些标签，导致混淆后的 HTML 和浏览器渲染的 HTML 不匹配。 对于同构应用来说，我们必须实现客户端与服务端的路由、模型组件、数据模型的共享。Vuex 是实现我们客户端和服务端的状态共享的关键，我们可以不使用 vuex，但是我们得去实现一套数据预取的逻辑；可以尝试封装一个可以给组件们共享的 EventBus，在 main.js 中 export 出我们的 EventBus 以便两个 entry 使用，接下来是我们的两个 entry 了。server 用来匹配我们的组件并调用组件的 asyncData 方法去获取数据，client 用来将预渲染的数据存储到我们 eventBus 中的 data 中。这样就相当于实现类 Vuex 的功能。 146.SSR 技术和 SPA 技术的各自的优缺点是什么？答： SSR： 更利于 SEO。 更利于首屏渲染 服务端压力较大 SPA： 页面之间的切换非常快 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染） 后端程序只需要提供 API，完全不用管客户端到底是 Web 界面还是手机等 不利于 SEO 首屏加载压力大 147.如何处理 Node.js 渲染 HTML 压力过大问题？答： 暂时没遇到慢的情况，无法回答，放弃此题。 148.你所知道的 CI &#x2F; CD 工具有哪些？在项目中有接触过类似的流程吗？答： CICD，持续集成和持续交付,各个部门合作同一个项目时，各种管理的仓库发生变更，就会自动对代码进行测试和构建，等 Pipline 跑完之后，反馈运行结果，自动打出最新的 master 包。 常用的 CICD 工具有 Jenkins 、Travis 等等。 149.如果让你实现一个 Web 前端的 CI &#x2F; CD 工程研发平台，你会如何设计？答： 题目太大，篇幅有限，略。 150.如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？答： 不知道这道题是想问我如何把线上已有的资源重新搜集成本地的素材中心，还是单纯的把 显示资源换成本地的。我对这道题目的理解是：比如一个页面内有一个 el-table，5000 页，每页 20 个商品，你也不知道每个商品的链接，每个商品后面的 URL 还没有规律，此时对于开发者而言，你所知道的也就是页面的节点、接口的 API 这两个关键信息了。想要把这 20*5000 个商品的商品详情图重新整理本地素材中心，那就手写一个爬虫，一次性爬完，把所有的资源路径拿下来。或者写一个 chrome 一键收集。 如果只是单纯的想把本应用的生产环境静态资源换成本地的，直接找到 应用的静态资源链接，找到它的 baseUrl，换成本地的 dev 环境下的 baseUrl 就可以了。一般项目的静态资源和服务端服务都是分开发的，两者独立，分开推送。并且每次发版，静态资源都有自己所属的版本号。 151.如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？答： 1// 见试卷背面 152.Jenkins 如何配合 Node.js 脚本进行 CI &#x2F; CD 设计？答： 1// 见试卷背面 153.如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？答： 参考 vue-cli，至少满足以下几点： 解耦：脚手架与模板分离 脚手架负责构建流程，通过命令行与用户交互，获取项目信息 模板负责统一项目结构、工作流程、依赖项管理 脚手架需要检测模板的版本是否有更新，支持模板的删除与新建 154.如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？答： 至少满足 4 个条件 选择通用、合适、便捷的构建工具，方便打包代码，并且易于调试； 注重代码质量和开发效率，有类型推断及静态检查能力（提前写好 TS）； api 简单易用，易于上手，文档实时更新； 易于开发者拓展、版本升级保持向前兼容。 155.假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？答： 写代码之前就要写好文档，没有文档的组件库&#x3D;白写。文档不仅仅是给使用者看的，同时也是维护者给自己产品的一种宏观把控。文档第一要实时、简洁，易于上手；第二要做好版本控制，无论是 Vue 组件库，还是小程序组件库，很多时候都要考虑大环境的限制（比如 Vue 的 api 变动、小程序基础库的变动），要实时更新和兼容，遇到无法兼容的版本隔阂，要特别说明，适当的地方 throw waring；第三，要支持按需加载和通用性和高拓展性，我曾经也只是一个组件库 api 调用大师，现在也在维护自己的组件库，我深知 UI 库最大的问题不是样式不全，而是别人觉得你的不好用，为了用你一个 toast 而要下载整个组件库，得不偿失，按需加载很重要，支持拓展更重要，方便其他的开发者在你的组件库上打补丁。 156.在设计工具库包的时候你是如何设计 API 文档的？答： 这个不算是问题，设计和整理 API 文档，能体现维护者对自己产品的态度，在开发之时就要开始整理，而不是等全部开发完。在写 API 文档的同时还可以帮助你从旁观者的角度审核你的产品功能。具体 API 文档的实现方案，可以使用 vuepress、rap2 等等之类的。 157.什么是单点登录？如何做单点登录？答：单点登录是指在同一帐号平台下的多个应用系统中，用户只需登录一次，就可访问所有相互信任的应用系统。比如你在网页中登录了百度云盘，随后你再去贴吧发帖 是不需要二次登录的。 单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。 因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是一个企业不同应用的域名不同，依然可能出现跨站 or 跨域。 前端方面的实现方式: 父域 Cookie 认证中心 LocalStorage 跨域 158.如何做一个项目的国际化方案？答： 方式有 2 类， 一、通过 i18 等插件，在项目代码中定义语言环境，通过通用的语言翻译函数，提供的功能就是静态和动态文案的翻译。主要思路就是通过构建工具去完成样式, 图片替换, class 属性等的替换工作，在业务代码中不会出现过多的因国际化而多出的变量名，同时使用一个通用的翻译函数去完成静态文案及动态文案的翻译工作，而不用使用不同框架提供的相应的国际化插件。 二、在项目中不使用插件，而是封装一套通用的翻译函数，在后台服务那边定义语言环境，通过 API 服务调用不同的主题和语言环境，返回不同的字段和页面内容。（项目代码中无中文，全是用翻译函数包裹后的变量） 159.如何做一个项目的监控和埋点方案？答： 监控是做法，埋点是工具，数据分析是目的。这三者一条道上的不同角色。 监控什么，一般前端项目所要监控的数据主要分为 5 种： 系统的生命周期数据，可用于观察页面性能情况、整体访问情况等。 HTTP 测速数据，可用于观察外部服务调用情况 、页面性能优化等。 系统异常数据，可用于观察系统稳定性、系统异常问题。 用户行为数据，可用于观察页面稳定性、整体访问情况等。 用户日志，用于进行用户反馈的问题排查。 前端常见的埋点方案有三种：代码埋点、可视化埋点、无痕埋点。不管使用哪种埋点方式，我们都需要对数据进行标准化处理。由于最终的数据需要落盘到服务端并进行计算和监控，因此我们需要将采集的数据，按照与服务端约定好的协议格式来进行转换。 为了快速发现并定位问题，我们需要将这些埋点的数据、运行的日志上报发送到服务端，服务端再进行转换、存储、计算和监控。一般采用 new 一个 gif 的形式上报，同时为了避免数据的上报过于频繁、增加服务端的压力，我们可以在本地进行数据的整合，比如通过队列或数组的方式进行维护，然后选择以下方式&#x2F;时机进行上报。 插一句话，有些场景我们需要知道用户设备崩溃or异常的数据情况，但往往这种情况下埋点没有触发，或者该触发的时候用户退出应用了，所以这里建议把需要埋点上报的数据离线上传，就是把埋点上报队列，放在缓存里，慢慢吐泡泡，同时不跟主业务流程中的API服务竞争资源。 数据上报完成后，一般来说需要搭建可视化的管理端，来对这些数据进行直观的监控。在日常监控中，我们还会通过对监控数据、配置告警阈值等方式，结合邮件、机器人等方式推送到相关的人员，来及时发现并解决问题。比如如果 5 分钟的异常数量大于阀值，就钉钉 or 短信报警，让相关同事及时修复功能异常。如果想要做得更多，我们甚至可以结合其他系统来进行协作，比如关联 BUG 管理系统、自动生成 BUG 单，将 BUG 单绑定到对应的版本分支上，通过提交对应的修复分支、进行测试验证后，自动地扭转 BUG 单状态，等等。 160.如何建设项目的稳定性（监控、灰度、错误降级、回滚…）？答： 我没有当过 Leader，以下纯从队友角度回答。 事前：进行合理的分工排期，对项目风险进行把控，学会自测，不要把所有的风险都抛给测试同学处理。 事后：对发布上线的产品及时监控，观察是否运行正常，是否符合预期。遇到上线后带了 bug，或者上线版本异常，此时首要目标时恢复业务，及时回滚，不要尝试用新版本覆盖。 复盘：及时发现自己的问题并改进，避免掉进同一个坑；让团队成员和管理者知道自己在做什么；整理沉淀和分享项目经验，不奢求让整个团队都得到成长，至少自己在这个产品开发周期内有所收获。 161.一般管理后台型的应用需要考虑哪些性能方面的优化？答： 一般的管理后台应用，基本就是 Vue+Element，或者 React+antd 这样的组件，并且业务还是 toB，to 内部使用的这种，一般都是 SPA，在性能方面，也不是那么讲究， 代码角度的优化： 各个模块间解耦，将各个模块统一交由框架处理，梳理各个模块的职责，明确每个模块负责的工作和提供的功能，确定各个模块间的边界和调用方式。 模块以服务的方式进行注册，通过声明依赖的方式来获取需要使用的服务，框架会对模块间依赖关系进行分析，判断某个服务是否需要初始化和销毁，从而避免了不必要的服务被加载。 拆公共库、拆组件库，代码复用，对重复逻辑进行组件和公共库的抽象和封装。避免出现一个方法重复到处 copy 的情况；UI 库按需引用，移除不必要的代码（比如使用 Tree-shaking）。异步加载模块，根据业务需要将模块拆分成多个步骤加载（比如优化依赖注入框架对模块分批初始化）。 差异化服务，对于不同场景只加载所需要的模块内容（比如读写分离）。 工程角度的优化： 静态资源使用 CDN 压缩文件 对于图表比较多的 CRM 管理平台应用，考虑图片优化，比如精灵图、懒加载 HTTP2 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码 骚操作禁区： 不要在后台管理仪表盘首页一次性请求大量的 echart 图表数据，如果这个页面的访问量不多，不要尝试在登录后自动跳转到这个页面，除非它真的很快，不然就是无效加载。 前端不要尝试请求 第 0 页第 100000 条 数据来尝试读取某个表的全部数据，问后端要接口，别自己浪，等页面卡死了，运营拿小锅锅敲你头。 162.简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试…）？答： 直播活动，商品详情页访问量大，页面加骨骼屏，等待时间过长时 loading 引导客户先去其他活动转转，不让用户盲等。 对于无论是 H5 还是小程序，埋点数据全部走离线上传，把埋点队列里的埋点请求全部放在缓存里，一个一个慢慢发送慢慢吐泡泡，既保证了不与主流程业务请求竞争，也不会因为用户设备退出应用闪退，而侦测不到数据，因为下次进入时只要缓存里有没吐完的泡泡（埋点请求队列）就继续发送。 应用的业务 http 请求封装一层 熔断任务队列，增加重试机制，增加 token 自动刷新请求等等。 应用页面适当的缓动动画，不仅可以为请求数据争取时间，还可以提高用户体验，不那么突兀。 H5 可使用龙骨动画、spine 动画，小程序可以使用帧动画、css animation 提高页面的动感，以及一定的互动营销效果。从实现和编码方面都比裸写 DOM 要好得多。 163.假设需要对页面设计一个水印方案，你会如何设计？答： 通过 canvas 生成水印，用 canvas 来生成 base64 图片，通过 CanIUse 网站查询兼容性。 通过 SVG 生成水印，相比 Canvas，SVG 有更好的浏览器兼容性，使用 SVG 生成水印的方式与 Canvas 的方式类似，只是 base64Url 的生成方式换成了 SVG。 服务端画图，通过 NodeJS 生成水印。前端发一个请求，参数带上水印内容，后台返回图片内容。 164.如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？答： 1// 见试卷背面 165.一般的低代码平台需要具备哪些能力？答： 阿里的 imgCook、云凤蝶、京东的通天塔、满帮的码良、徐小夕的 H5 Doring 等等，无一例外，至少都满足一下几种能力： 面向业务的软件设计模式，低代码主要是给运营用的，通过模块 or 组件的使用，给运营人员提供物料，搭建他们自己想要的营销活动页面。 能够提供可复用业务组件的知识库，组件之间可以相互联合，组成新的业务组件，而不是单一独立的基础组件，可复用性、可拓展性非常高。 能够方便实现与第三方系统整合的流程整合能力与数据整合能力等，能够以 SDK，或者 npm 包的形式嵌入到其他应用，或者其他应用嵌入进来，支持数据之间的整合。 能够支持多种部署模式，不受平台本身的限制 支持高度可配置化，以满足不同环境、不同规模、不同业务场景的特定要求 166.使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据答： 1// 见试卷背面 167.实现一个简易的模板引擎答： 1// 见试卷背面 168.简单实现一个发布 &#x2F; 订阅模式答： 1// 见试卷背面 169.匹配出字符串中 const a &#x3D; require(‘xxx’) 中的 xxx答： // 见试卷背面 参考文献考试大纲如下 基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用 框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用 工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI &#x2F; CD 了解和使用 网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解 性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解 插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解 系统：Mac、Windows、Linux 系统配置的实践 后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用"},{"title":"e","path":"/spoken_english/e.html","content":"/e/口型不变，舌头放松 eg： bed /bed/ let /let/ leg /leg/ beg /beg/ guess /ges/ less /les/"},{"title":"aʊ","path":"/spoken_english/aʊ.html","content":"双元音，横开口 how now wow cow down found shout allow"},{"title":"f & v","path":"/spoken_english/f & v.html","content":"f unvoicedv voiced flavor enough live value life wife fresh"},{"title":"i & ɪ","path":"/spoken_english/i & ɪ.html","content":"/i:/ 和 /ɪ/ eg: ɪ 可看做 [ɪ] = [i] + [e] big /bɪɡ/ it /ɪt/ is /ɪz/ (strong) hit /hɪt/ fit /fɪt/ sit /sɪt/ shit /ʃɪt/ sick /sɪk/ it is so big /i:/ be /biː/ (strong) /bi/ (weak) bee /bi:/ eat /i:t/ heat /hiːt/ feet /fi:t/ seat /si:t/ sheet /ʃiːt/ seek /si:k/"},{"title":"juː","path":"/spoken_english/juː.html","content":"元音：声带直接震动辅音：声带不震动，用于把元音连贯起来 ew &#x2F;iːuː&#x2F; few &#x2F;juː&#x2F; u shoe huge puke"},{"title":"p & b","path":"/spoken_english/p & b.html","content":"p 清音 unvoiced b 浊音 voiced stop p&#x2F;b结尾的 p&#x2F;b 不发音 sto(p) the carwhat’s u(p) 不送气清音s(p)iders(t)udent paper pee pipe poke pink pen stop bee bay buy boat bad best bob club"},{"title":"k & g","path":"/spoken_english/k & g.html","content":"k unvoicedg voiced key kite code cute gay geek guide go good 不送气清音 skate scar sky scale ski score"},{"title":"s & z","path":"/spoken_english/s & z.html","content":"s unvoicedz voiced some zip soup zu sing cuisine news newspaper [s] + [juː] &#x3D; [ʃ] mi(ss y)ou tissue [z] &#x3D; [juː] &#x3D; [ʒ] clo(se y)our door"},{"title":"schwa sound","path":"/spoken_english/schwa sound.html","content":"&#x2F;ə&#x2F; 央元音 央化现象 非重读音节的字的发音会向 /ə/ 靠拢。 eg： - family /ˈfæməli/中i央化成了/ə/ - hello /həˈloʊ/ - accept /əkˈsept/ is different from except /ɪkˈsept/ - believe /bɪˈliːv/，发音跑到 /bəˈliːv/ - little /lɪt(ə)l/，发音跑到/lət(ə)l/ - computer /kəmˈpjuːtər/ - until /ʌnˈtɪl/，发音跑到 /ənˈtɪl/ - protect /prəˈtekt/ - banana /bəˈnænə/ - sofa /ˈsoʊfə/"},{"title":"oʊ","path":"/spoken_english/oʊ.html","content":"双元音 go alone toe window home phone"},{"title":"t & d","path":"/spoken_english/t & d.html","content":"t unvoicedd voiced true t&#x2F;d test desk stop t&#x2F;d mad not i(t)’s no(t) my faul(t) flap t&#x2F;d pre(tt)y ci(t)y no(t) a(t) all wri(t)er li(tt)le par(t)y la(dd)er le(tt)er le(t) her go tol(d) her drop t 非重读音节 exac(t)ly in(t)ernet cen(t)er [t] + [j] &#x3D; [tʃ] mee(t y)ou [d] + [j] &#x3D; [dʒ] nee(d y)ou glottal t&#x2F;d 喉塞音 co(tt)on &#x2F;ko n&#x2F; Bri(t)ain &#x2F;bri en&#x2F; stu(d)ent &#x2F;stu ent&#x2F; moun(t)ain &#x2F;mou n"},{"title":"æ","path":"/spoken_english/æ.html","content":"与 /e/ 非常相似，发音比较靠后。\\ eg: hat /hæt/ bad /bæd/ map /mæp/ 语流音变 [æ] + [n]/[m]：当做[æ + ə + n]的读音 man /mæn/ fan /fæn/ can /kæn/ (strong) /kən/ (weak) ham /hæm/ sample /&#39;sæm.pəl/ band /bænd/ [æ] + [ŋ] = [eɪŋ] bank /bæŋk/ thank /θæŋk/ language /&#39;læŋ.ɡwɪdʒ/"},{"title":"tʃ & dʒ","path":"/spoken_english/tʃ & dʒ.html","content":"tʃ unvoiceddʒ voiced chase attach teacher danger just juice image manage manager"},{"title":"ɔɪ","path":"/spoken_english/ɔɪ.html","content":"双元音 toy boy joy boil oil loyal"},{"title":"uː & ʊ","path":"/spoken_english/uː & ʊ.html","content":"uː 紧元音 tooth /tuːθ/ boom /buːm/ goose /ɡuːs/ food /fuːd/ woo /wuː/ fool /fuːl/ pool /puːl/ poo /puː/ ʊ 松元音 look /lʊk/ took /tʊk/ book /bʊk/ good /ɡʊd/ foot /fʊt/ wood /wʊd/ would (strong) /wʊd/ (weak) /wəd/ full /fʊl/ pull /pʊl/ push /pʊʃ/"},{"title":"ɔː & ɑː","path":"/spoken_english/ɔː & ɑː.html","content":"美音里，两个音区别不大。 eg： hot dog not talk walk all law lot father god"},{"title":"ʌ","path":"/spoken_english/ʌ.html","content":"/ʌ/ &#x3D; 大 /ə/这两个读音在美音中界限很模糊。 不强调时，可以读成 /ə/。eg： bus /bʌs/ /bəs/ but nut mother hug touch gut suck"},{"title":"ʃ & ʒ","path":"/spoken_english/ʃ & ʒ.html","content":"ʃ unvoicedʒ voiced shape sheep ship show shoot should wash hush asia measure usual"},{"title":"θ & ð","path":"/spoken_english/θ & ð.html","content":"θ unvoicedð voiced think brother thought throw birthday worth that"},{"title":"长短元音","path":"/spoken_english/长短元音.html","content":"长元音 long vowels A [eɪ]: late; hate; make; take; name; fake; plane; plate E [i:] I [aɪ] O [oʊ] U [juː] 短元音 short vowels 上述原因除了 long vowels 读音之外都是短元音 A: apple; acid; glad; mad; hat; cat; ax; at A: about; arrange; banana; advance; approach; account; away; available; Y 特殊 开头作为辅音 中间或结尾作为元音"},{"title":"GPIO位结构","path":"/stm32/GPIO位结构.html","content":"最右边为引脚。两个保护二极管，VDD 接 3.3V，VSS 接 0V。如果流入的电压大于 3.3V，会击穿 VDD 处的二极管，电流会顺着流出，不会流入电路中。如果流入的电压小于 0V（负电压），电流会从 VSS 流出，不会流入电路中。 右上方，上拉电阻和下拉电阻。若接了引脚，则电平由引脚端控制；未接引脚时，由上拉电阻、下拉电阻进行控制，否则电路状态为悬空状态，容易发生改变。上拉电阻保证引脚高电平，下拉电阻保证引脚低电平（默认高低电平）。 施密特触发器：用于整流（整形），如果电压高于阈值，输出高电平；低于阈值，输出低电平。 输出控制： 推挽输出（强推输出）：P-MOS 和 N-MOS 均有效。数据寄存器为 1 时，上通下断，引脚接 VDD，输出高电平。数据寄存器为 0 时，下通上断，引脚接 VSS，输出低电平。 开漏输出：P-MOS 无效。数据寄存器为 1 时，下断开，输出高阻；数据寄存器为 0 时，下通路，输出低电平。"},{"title":"STM32片上资源","path":"/stm32/STM32片上资源.html","content":""},{"title":"STM32芯片系统结构","path":"/stm32/STM32芯片系统结构.html","content":""},{"title":"STM32芯片命名规则","path":"/stm32/STM32芯片命名规则.html","content":""},{"title":"GPIO输入","path":"/stm32/GPIO输入.html","content":"硬件电路 工作模式 浮空&#x2F;上拉&#x2F;下拉输入 模拟输入 开漏&#x2F;推挽输出 复用开漏&#x2F;推挽输出（使用片上外设控制）"},{"title":"中断系统","path":"/stm32/中断系统.html","content":"中断执行流程 STM32 中断 NVIC 基本结构 NVIC 优先级分组 EXIT（Extern Interrupt）中断 EXIT 基本结构 EXIT 框图 AFIO 复用 IO 口"},{"title":"对射式红外传感器","path":"/stm32/对射式红外传感器.html","content":"接线图"},{"title":"按键抖动","path":"/stm32/按键抖动.html","content":"按键内部使用机械式弹簧判断通断，在按下和松手的瞬间会发生抖动。"},{"title":"旋转编码器","path":"/stm32/旋转编码器.html","content":"接线图 硬件电路"},{"title":"STM32 Notes","path":"/stm32/index.html","content":"This page is used to record some notes"},{"title":"安星决","path":"/ziwei/安星决.html","content":"定地支 12 宫| || :-: | :-: | :-: | :-: || 巳 | 午 | 未 | 申 || 辰 | | | 酉 || 卯 | | | 戌 || 寅 | 丑 | 子 | 亥 | 定宫干出生年甲乙丙丁戊己庚辛壬葵↓↓↓↓↓丙戊庚壬甲 得到 丙戊庚壬甲 五个干后，放在寅位 安命 身宫命宫的含义：命宫为命主先天运势，命运的主轴，行运的源头。可以看出个人的个性特质、行为、长相。以命宫为主，配合其他宫位的组合，会显现出个人的格局，了解终生的命运，是整个命盘的核心。吉凶祸福以此宫为枢纽，若有忌星、煞星冲会，通常会有较严重的灾祸。 身宫的含义：身宫代表后天运势，由后天的努力，往往可以改造命运，为辅助命宫之宫垣。身宫并不独立存在，必须依附于人事十二宫中的命宫、夫妻宫、财帛宫、迁移宫、官禄宫及福德宫，宫位不同而性质不同、影响不同。后面会详解。 寅正顺数生月逢，生月起子两头通。逆至生时为命垣，顺到生时安身宫。 凡是闰月出生的人，均按下个月算，如闰二月，按三月算，其余类推。 定十二宫安定好了命、身二宫之后，就应以命宫为主，继续在地支十二宫中填满人生十二中重要条件，亦即人事十二宫（也称为命盘十二宫），分别是命宫、兄弟宫、夫妻宫、子女宫、财帛宫、疾厄宫、迁移宫、奴仆宫、官禄宫、田宅宫、福德宫、父母宫。 定五行局命宫宫干去定火（戊己）水（丙丁） 土（庚辛）金（甲乙） 木（壬葵） 如命宫干支为丁亥开始位置为水，下面的位置是顺序是：水，火，土（3 次 1 轮）水（子丑），火（寅卯），土（辰巳），水（午未），火（申酉），土（戌亥） 所以为土 根据顺序：水二，木三，金四，土五，火六 得出为：土五局 定阴阳阳天干：丙戊庚壬甲阴天干：乙丁己辛葵 甲子年，男，即为：阳男 起紫微星生日除局商为月，一自寅起紫微定。只加不减到整除，阳退阴进记心中。 起紫微星的时候，用命主的生日数（如农历二十一）来除以命主的五行局局数（如水二局），得出来的商就是月数（这里的月数并不是实际月数，实际月数最大是十二，但我们得出来的月数可能比十二大）。有了月数（就是生日除以局数的商）后，就从寅宫起一月，以顺时针方向，数到我们得出的月数位置，落在哪一个宫位，就在这里起紫微星。 当然我们也有生日除以局数除不尽的时候，这时我们就要在原本的生日数上加上一定的数字，使它能够与局数刚好整除，然后再从寅宫起一月，数到我们得出的月数为止。这里我么特别需要注意，此时我们得出的月数是我们在生日数上添加了一个数字后求得的（只加不减到整除），所以不能马上起紫微星。我们需要查看我们所添加的是阳数还是阴数（单数为阳，双数为阴），若是阳数，我们就从月数所落宫位逆数到你所添加的那个数字落宫并起紫微星；若是阴数，与阳数方法相反。 定天府星紫薇天赋根据寅申这条线镜面对称，在寅申宫同宫。 定十四正耀 紫薇系：紫薇、天机、太阳、武曲、天同廉贞紫薇天机星逆行，隔一阳武天同情。又隔二宫廉贞位，空三便是紫微星。 天府系：天府、太阴、贪狼、巨门、天相、天梁、七杀、破军天府太阴顺贪狼，巨门天相与天粱，七杀空三是破军，隔宫望见天府乡。 紫微系逆向安置，天府系顺向安置 定六吉星六吉星：左辅、右弼、文昌、文曲、天魁、天钺 左辅右弼（生月） 辰上顺正寻左辅，戌上逆正右弼当。 文昌文曲（生时） 辰上顺时文曲位，戌上逆时觅文昌。 天魁天钺（以生年干） 甲戌庚牛羊，乙己鼠猴乡，壬癸兔蛇藏，丙丁猪鸡位，六辛逢马虎，此是贵人乡。 甲、戌、庚三天干，天魁在丑，天钺在未；乙、己二天干，天魁在子，天钺在申；壬、癸二天干，天魁在卯，天钺在巳；丙、丁二天干，天魁在亥，天钺在酉；辛天干，天魁在午，天钺在寅。 定六煞星六煞星：擎羊、陀罗、火星、铃星、地空、地劫 定禄存星：甲禄在寅宫，乙禄居卯府。丙戊禄在巳，丁己禄居午。庚禄定居申，辛禄酉上补。壬禄亥中藏，癸禄在子库。 擎羊陀罗（以禄存星） 禄前擎羊当，禄后陀罗府。 顺时针 火星铃星（生年地支和生时） 申子辰人寅火戌铃，寅午戌人丑火卯铃。 亥卯未人酉火戌铃，巳酉丑人卯火戌铃。 注：如“申子辰人寅火戌铃”，其中申、子、辰为命主生年地支，若是这三个地支出生的人，火星由“寅宫”起子时，铃星由“戌宫”起子时，全部以顺时针方向数到命主出生时辰为止，各安火星、铃星。故口诀中的“寅火戌铃”中“寅”、“戌”为起始宫。 地空地劫（以生时） 亥上子时顺安劫，逆回便是地空亡。 从亥宫起子时，以顺时针方向数到命主出生时辰安地劫；再从亥宫起子时，以逆时针方向数到命主出生时辰安地空。 定四化四化：化禄、化权、化科、化忌 以生年天干 甲廉破武阳，乙机梁紫月，丙同机昌廉，丁月同巨机，戊贪月右机，己武贪梁曲，庚阳武月同，辛巨阳曲昌，壬梁紫府武，癸破巨月贪。 安天马、天空（1）天马（以生年地支） 口诀： 申子辰人寅，寅午戌人申。 巳酉丑人亥，亥卯未人巳。 （3） 天空（以生年地支） 口诀： 驾前一位是天空，身命原来不可逢。 或年支前一宫，落位即天空。 注：天空在生年地支的前一个宫位，如午年生人，天空在未宫。 安天官、天福（以生年天干）口诀： 甲喜羊鸡乙龙猴，丙年蛇鼠一窝谋。 丁虎擒猪戊玉兔，巳鸡居然与虎俦。 庚猪骂辛鸡蛇走，壬犬马癸马蛇游。 注：羊、鸡即申宫、酉宫，前者安天官，后者安天福，其余类推。 安天哭、天虚（以生年地支）口诀： 天哭天虚起午宫，午宫子年两头通。 哭逆巳兮虚顺未，生年寻得便居中。 解： 由午宫起子年逆行，数到命主生年地支安天哭；由午宫起子年顺数，数到命主生年地支安天虚。 安红鸾、天喜（以生年地支）口诀： 卯上子年逆数之，数到当生太岁支。 坐守此宫红鸾位，对宫天喜不差移。 解： 红鸾、天喜是一对对星，如紫微、天府，只要找到其中之一，就能快速找到另外一个。口诀中“当生太岁支”，即命主出生年份的地支。十二地支相对关系如下：子对午，丑对未，寅对申，卯对酉，辰对戌，巳对亥。若红鸾在丑宫，天喜必定在未宫，其余类推。 安龙池、凤阁（以生年地支）口诀： 龙池辰上子顺行，生年到处福元真。 凤阁戌宫逆起子，遇到生年是此神。 注解： 从辰宫起子年，顺数到命主生年地支安龙池；从戌宫起子年，逆数到命主生年地支安凤阁。 安孤辰、寡宿（以生年地支）口诀： 亥子丑寅孤戌寡，寅卯辰巳孤丑寡。 巳午未审孤辰寡，申酉戌亥孤未寡。 注解： 出生年份地支为亥、子、丑的人，在命盘上寅宫安孤辰，戌宫安寡宿，其余类推。孤辰、寡宿都是代表孤单的星曜，其中“男怕孤辰，女怕寡宿”，最好在命宫及三方四正不要遇到它们。 安天厨（以生年天干）口诀： 甲丁年巳宫，乙戌辛午宫。 丙年在子宫，己年在申宫。 庚年在寅宫，壬癸酉亥中。 注解： 甲年、 丁年生人，天厨星都在巳宫；乙年、戌年、辛年生人，天厨星在午宫；丙年生人，天厨星在子宫；巳年生人，天厨星在申宫；庚年生人，天厨星在寅宫；壬年生人，天厨星在酉宫；癸年生人，天厨星在亥宫。 安截空、旬空（1）截空（以生年天干） 口诀： 戌亥无截空，一星占两宫。 戊癸在子丑，正副有先后。 丁壬卯寅宫，丙辛辰巳中。 乙庚年午未，甲己年申酉。 注解： 截空本来是两颗星曜，即截路、空亡，同临一位，占据两宫，分为一正一副，正称截空（或正空），副称副截（或傍空）。正副之分，以出生年份天干为准，生年天干为阳时，阳宫（甲、丙、戊、庚、壬）里的截空为正空；出生年份天干为阴时，阴宫（乙、丁、巳、辛、癸）里的截空为副截。 注意，截空不入戌、亥二宫。 （2）旬空（以生年地支、天干） 方法：以命主出生年份地支找到命盘相同的地支宫位，以此宫起命主生年天干甲，并依次顺数至天干癸为止，接下来两个宫位就是旬空。旬空也分正副，命主干支为阳，阳宫为正旬，干支为阴，阴宫为正旬。一星占两宫，截空旬空同。 安华盖、劫煞（1）华盖（以生年地支） 方法：单取辰、戌、丑、未四个宫位，以辰为首起子，依次轮数十二地支，数到命主省点地支为止，落华盖。 （2）劫煞 方法：劫煞永远在华盖星的前一宫，若华盖在丑宫，劫煞在寅宫；华盖在辰宫，劫煞在巳宫。其余类推。 安大耗（以生年地支）口诀： 但用年支去对冲，阴阳移位过一宫。 阳顺阴逆移其位，大耗原来不可逢。 注解： 不可逢，即最好不要遇到。 以命主生年地支所在宫位冲对宫，若为阳支便顺行一宫安大耗，如子宫的对宫为午宫（阳宫），午宫顺行一宫是未宫，在未宫安大耗；阴支便逆行一宫安大耗，如丑宫的对宫为未宫（阴宫），未宫逆行一宫是午宫，在午宫安大耗。 安蜚廉、破碎、咸池、龙德、月德（以生年地支）口诀： 蜚廉分方顺年移，西南东北各轮之。 破碎轮排巳丑酉，不关生月与生时。 辰戌丑未轮华盖，酉午卯子布咸池。 龙德起羊月起巳，六星都起据年支。 注解：西（申、酉、戌），南（巳、午、未），东（辰、卯、寅），北（亥、子、丑） 安天德、年解（以生年地支）口诀： 天德星君起酉宫，顺至生年定其踪。 年解戌宫逆行去，数至生年可解凶。 安天才、天寿、台辅、封诰口诀： 命宫起子顺天才，身宫起子天寿堂。（以生年地支，顺数） 曲前二位是台辅，曲后二位封诰乡。（以文曲） 安天姚、天刑、解神、天巫（以生月）口诀： 天姚丑上顺正月，天刑酉上正月轮。 数至生月便住脚，即安刑姚两颗星。 单月冲宫觅解神，双月还依单月辰。 巳申寅亥天巫位，分轮十二月星君。 注解：年解为一年之解神，解神为一月之解神，故又名月解。月解的起法是按两个月起一宫，从寅宫开始，数到命主出生月份即可。 安天月（以生月）口诀： 一犬二蛇三在龙，四虎五羊六兔宫。 七猪八羊九在虎，十马冬犬腊寅中。 安阴煞（以生月）口诀： 寅子戌，申午辰，分六月，阴煞临。 安天伤、天使（以宫位）口诀： 天伤永在朋友宫，天使永在疾厄宫。 安三台、八座、恩光、天贵口诀： 三台左辅起初一，数至生日是台宫。（顺数） 八座右弼起初一，数至生日定其踪。（逆数） 文昌顺数至生日，退后一步是恩光。 文曲顺数至生日，退后一宫天贵场。（以上全部顺数） 安长生十二神（依五行局）十二神：长生，沐浴、冠带、临官、帝旺、衰、病、死、墓、绝、胎、养 依五行局起，水、土在申宫，金在巳，木在亥，火在寅。阳男阴女顺行，阴男阳女逆行。 安生年博士十二神十二神：博士、力士、青龙、小耗、将军、奏书、飞廉、喜神、病符、大耗、伏兵、官符 博士必定与禄存同宫，阳男阴女顺行，阴男阳女逆行。 起大限方法：以五行局起限岁数，如木三局的人从三岁开始起大限，火六局的人从六岁开始起大限，都从命宫开始。大限者，十年运势，所以初始大限在命宫，如木三局的人命宫初始大限为三至十二岁，水二局的人命宫初始大限为二至十一岁，其余类推。其余大限依阳男阴女顺行、阴男阳女逆行，分布十二宫。 起小限口诀： 寅午戌人辰宫起，申子辰人戌上排。 亥卯未人丑上是，巳酉丑人未上归。 方法：单取戌、未、辰、丑四个宫位，从戌宫起子，依上述次序数到命主生年地支起一岁，然后男性顺行，女性逆行依次于十二宫中反复排列岁数。 安命主星（以生年地支）口诀： 子属贪狼丑亥门，寅戌生人属禄存。 卯酉文曲巳未武，申辰廉贞午破军。 安身主星（以生年地支）口诀： 子午安身铃火宿，丑未天相寅申梁。 卯酉天同身主是，巳亥天机辰戌昌。"},{"title":"天相星","path":"/ziwei/天相星.html","content":"天相星属阳水，化气为印，权利的象征。 天相星的主要作用，一是辅助力，二是证明力。 观察天相星的优劣势时，必须先看两夹宫位的情况。 逢府看相，逢相看府。天府、天相是一组星，相互之间影响较大，需要看这两颗星分别与哪些星耀同缠、会照。 天相星代表权利，有权威、庄重的色彩。 天相星拥有助理，可以帮助他人。 天相星为司爵之宿，是事业宫的主星，对于在政界发展的人影响力更大。如果天相恰好落在事业宫，吉则加倍吉，凶则加倍凶。 天相星有传承的特点。 天相星带有体面、美观的特点，略带桃花性质。 天相星坐命的人，会啰嗦、爱管闲事，港台的老师称为鸡婆星。 庚干需参考天相化忌的能力，表示助力下降，对学业、官运有不良影响。命宫、官禄宫遇到天相化忌，当事人往往难以考取功名，考公务员不顺利。 天相化气曰印，是为官禄文星，佐帝之位 – 天相星拥有很强的助力，较偏于文事，利于从事文职、辅佐类型的工作。天相喜与紫薇相会，增加彼此的力量。如果在三方四正没有遇到紫薇，亦可将助力作用在其他星耀上。受天相影响首推天府星，因为天府天相永远三方会照。 命逢得辅佐，主夫妻子女不缺 – 如果天府坐命，必然有天相在三合会照，获得了天相的助力，不担心婚姻、子女方面的问题，除三方四正煞星过多之外。天府坐命时，天相一定在官禄宫，会照的吉星越多，天府星的权利就会越大，容易成为人上人。 天相星最重要的是看两夹宫位的好坏，如果是吉星、吉化夹天相，好运连连；如果是煞星、化忌夹天相，三方又无吉星救，就会厄运当头。 以财荫夹印最吉、刑忌夹印最凶。天相星的前后永远被巨门，天梁所夹。如果巨门化禄、或者有其他星耀化禄，就能为天相带来财运、帮助。如果巨门化忌、或者有其余星耀化忌，则会给天相带来各种祸患。这时候，后宫的天梁会发挥出刑星的特点，对天相造成伤害。只需观察巨门所在的宫位即可，即使天梁化禄，也不能成为财荫夹印。 天相也喜成对的吉星，如左辅右弼、天魁天钺、文昌文曲。如果命宫有天相，同时获得吉星的夹持，对命运发展十分有利。 天相畏成对的忌星来夹，如火星羚星、地空地劫、擎羊陀罗，都会使天相的吉利性质受损。如果天相坐命，同时有四忌来夹，局势会变得非常恶劣，一生挫折多，也难以获得外界的助力。 财荫夹印的天相，以同宫有左辅右弼、天魁天钺、文昌文曲、禄存等为佳。如果没有吉星，反见煞星，性质会减弱。财荫夹印最好是坐如命宫、事业宫。如果在财帛宫、夫妻宫、田宅宫，效果会差一点。如果落在疾厄宫、奴仆宫、子女宫，对命主而言没有多大好处。这种情况下，巨门化禄肯定在命宫的三方四正，可以重点研究巨门化禄对命运的影响。 如果命宫是财荫夹印，表示一生可得外界助力；如果事业宫是财荫夹印，此时命宫必然为天府，表示事业上可以获得外界助力，发展更加顺利，此时巨门化禄必然在其田宅宫，往往可以拥有多套房产。田宅宫的巨门化禄，只要没有遇见煞星，都表示家庭成员能够齐心协力，共同创造财富。 如果财帛宫是财荫夹印，表示财运较好，资金流动顺畅，在赚钱方面能够得到他人帮助，很少有缺钱的时候（需要配合大运、流年。如果形势不好，也会导致财运不利） 天相是事业宫的主星，在事业宫时以吉论，能够在工作上帮助他人。左辅右弼能增加天相的权威；天魁天钺增加天相的贵气，可以遇见贵人。与文昌、文曲、化科同宫，宜从文职；与武曲同宫，宜从武职。不宜在三方四正会照忌星、化忌，会造成事业不顺，多波折，事业前途不明等。 如果父母宫是财荫夹印，其人命宫必为巨门，主要看命宫的特制。一般父母宫形成的财荫夹印，并不代表对命主有很大助力，因为巨门化禄属于创业的结构，主要靠自己发展。 夫妻宫天相构成财荫夹印，其人命宫必有七杀，对男命较好。在古代，夫妻宫的天相代表亲上加亲，如男人与表姐妹结婚，女人与表兄弟结婚等。现代社会则是代表旧人重逢。因此，天相在夫妻宫的人想要结婚，不妨多联系之前的老友。流年的夫妻宫有天相，也可能旧情复燃，能否结婚需要看流年和大运来定。 天相在夫妻宫，对男命比较有利，三方四正煞星少，表示妻子可以帮助自己。但不宜见天桃、红鸾、左辅、右弼等星，表示婚后有第三者插足。最好也不要和武曲同宫，表示妻子强势。如果天相落陷，表示带来的助力很少。 迁移宫的天相形成财荫夹印，对人际关系有利，一般适合在外地发展。只要三方四正煞星少，一般都可以选择到外地发展。形成刑忌夹印时，对命运的发展有不利影响，不适合在外考试、考证。 子女宫的天相构成财荫夹印时，表示能有儿子，但迟得，在三十之前一般只有女儿，三十之后才有儿子。三方四正吉化多，表示子女聪明，听话，有富贵。煞星、化忌多，表示难有儿子，或有子不好养大。 田宅宫有天相，入庙表示能得祖产，如果煞星较多，形成刑忌夹印，则与祖产缘薄。庚年生人，天相在田宅者，难有祖产。 福德宫有天相，以见吉星、吉化为佳。左辅右弼，禄存、化禄、天魁天钺。三方四正煞星少，代表内心正派，有责任感，扶危济困。如果命宫的格局好，福德宫的天相又好，可以担当大任。如果没有见吉星、吉化，又被煞忌侵害，表示心态不端正，没有责任感，做事三分钟热度，不能持之以恒，对女命的婚姻极为不利，对男命婚姻影响较小。 福德宫天相见破军化禄冲照，表示心思变化快，时常改变主意，捉摸不定。 天相在父母宫、兄弟宫、奴仆宫，表示可以获得帮助，但以入庙，不见煞忌为佳。天相的本质是吉星，不表刑克，有擎羊陀罗、火星铃星、天刑、武曲化忌、廉贞化忌等会照，才会造成很大危害。 如果天相与擎羊同宫，巨门又与禄存同宫，也属于财荫夹印，但由于与擎羊同宫，必然带有纷争、竞争的性质。如果巨门没有化禄，而是同宫的其他星化禄，给天相带来的好处并不大，可以忽略。同理如果非巨门化忌，而是其他星耀化忌，也不看做刑忌夹印。 天相属阳水，具有桃花性质。女人天相坐命宫，不见煞星者，长相秀丽，性格温婉，能够匡扶丈夫。天府、天相坐命的女人，都乐意为家庭付出，子贵夫贤的比例较高。 大限、流年走到天相的宫位，如果有红鸾、天喜、咸池、天姚、沐浴等桃花同宫，桃花性质大大增强，无论男女接触异性机会大大增多，往往是对方主动的情况。 男人天相坐命，常有辅佐他人的想法，适合做二把手。 天相坐命，左辅右弼同宫者，敦厚老实，人品好，有一定的领导才能，也可以得到他人扶持，但本人开拓不强，更适合守业。如果女人天相坐命，左辅右弼同宫，福德宫、夫妻宫好，有旺夫命。 天相坐命的人，比较注重外表，希望在别人眼里看起来更体面。与贪狼坐命不同，贪狼星是为了吸引目光，往往会有奇装异服的打扮。"},{"title":"禄存星","path":"/ziwei/禄存星.html","content":"稳定，被动。 前后为擎羊、陀罗。 喜天马同宫或对宫，成禄马交驰。 喜化禄同宫、对宫、六合宫。 不喜地空地劫同宫，散财。 不喜化忌，会主凶。 主孤，与天梁、天机同宫会加重孤，与此二星同宫时需要左辅右弼同照命宫。 如与武曲同宫，为人易势利。 天府禄存坐命 – 守财奴，重视金钱。 阳梁昌禄格 – 命在卯宫，三方会照太阳、天梁、文昌、禄存，无煞忌，甲第登科之命。 如与火星、羚星、地空、地劫，技巧安身。 禄存化忌坐命 – 羊驼夹忌，不易聚财。"},{"title":"天府星","path":"/ziwei/天府星.html","content":"擅长吸收、积累、发展。 天府坐命，格局越大约包容，格局越小越小气。 格局大者，见左辅、右弼、天魁、天钺、化禄、禄存、化权、化科、文昌、文曲、三台、八座、台辅、封诰等吉星，如果未遇到这些吉星，则视为格局小。 格局小者，遇煞星、化忌、天姚等，容易发展成奸诈、狡猾的性格，不爱说真话，做事虚浮，想法不切实际。 天府能制羊陀为从，能化火羚为福 – 天府不惧与擎羊、陀罗、火星、羚星同宫，而且能减少这些星带来的危害。 天府畏地空，地劫，使财运起伏不定，命运带有空虚，孤独的性质。地空，财无意中失去。地劫，财被破。 天府与诸多煞星同宫时，人际关系不好，同时会影响到财运。 若值空亡是为孤立 – 地空、地劫、旬中、截路、天空。天府星坐命时，受天空星影响较小，受其余空亡影响较大。 天府坐命，内心敏感，适应性强，观察力强。善抓住重点，善把握细节。无论是什么组合，都适合在稳定的局面下发展，在不断地积累中进步。守成的性质大于创业，利于从事已有或熟悉的行业，在基础上逐渐提升。 性格较为保守，对创业不利。 发展能力强，发明能力弱。 最适合在青少年时期聚集力量，三十岁后逐渐发力。 天府坐命很少有少年富贵者。 天府坐命在达成目标、满足欲望后会感到严重的空虚。 天府受空星的影响，大多会接近宗教、哲学，或是命理、风水、面相等学问。命格好也会大有成就。 天府是南斗主宰，在遇到天魁、天钺、龙池、凤阁、三台、八座时发挥出贵气。在遇左辅、右弼时发挥出领导才能。天府坐命，左辅右弼齐会，提高本人社会地位。 天府本质是财星，在财帛宫、田宅宫主富厚。但以见吉星、吉化为佳。 天府在财帛宫、遇吉星多而无煞星，理财能手，一生财运稳定。 天府在田宅宫，表示有房产继承，或因其他原因直接获得房产，本人能力不佳也能守住家业。以不见擎羊为佳，否则有关于房产的明争暗斗，同时对本人置业，守业造成不利影响。表示置业不顺、家庭成员纠纷多、不和睦等。 天府在夫妻宫，与禄存或武曲同宫时，一般表示配偶管理钱财，也表示配偶不爱花钱。若无禄存、武曲同宫，表示配偶节俭、人品厚道，在经济上能为自己提供帮助。 女人贪狼坐命，天府在夫妻宫，以嫁给体型健硕的丈夫为佳。 男人贪狼坐命，天府在夫妻宫，以娶端庄、勤劳、节约、人品好的妻子为佳。 天府在迁移宫，解释为出门得财、出门遇贵，以三方四正见吉星吉化为准。遇煞星、化忌，则不以此论。不见煞就算吉，适合在外地发展事业。 天府在兄弟宫、奴仆宫，表示合作伙伴、下属对自己有助力。见左辅、右弼、天魁、天钺，不见煞忌，对命主帮助最大。 天府在福德宫，见吉星者内心安稳，有福可享，看得开。与禄存同宫，表示能享受赚钱带来的快乐，本人比较爱理财。如果三方四正见擎羊、天刑、火星、羚星等，表示内心压力大，缺乏安全感。见地空、地劫等同宫，表示内心空虚、孤独，缺乏方向感，女命则是婚姻感情不顺利。如果三方四正只有一两个煞星，仍以吉论。喜与化科同宫，能增加自身的智慧，内心较快乐。与化权同宫，增强自己的上进心，对钱财的渴望也会增加。 福德宫的天府，如果没有遇见地空地劫，而是擎羊陀罗、火星铃星、化忌在三方四正会照，也会有孤独，空虚的特点。精神上难以满足，容易沾染不良嗜好，如嫖妓、赌博等，因此损耗钱财。 天府在子女宫，以见吉星吉化为佳，本人可以有多个子女，且子女感情较好。如果遇到煞星、化忌，表示因子女破财，如败家子。 天府在疾厄宫时，命宫一定为天梁，需参照命宫会合的星耀判断。天府落疾厄宫时，一般不会有大灾大难，最终也会化解。但天府、天梁都属土，天梁坐命，天府坐疾厄宫，容易有肠胃方面的疾病，尤其与地空地劫同宫时为确。疾厄宫天府三方合武曲化忌，往往会因疾破财，有开刀的风险。 总的来说，天府以不与地空、地劫同宫为佳。无论在哪个宫位，都带有破财的性质：擎羊、陀罗、火星、羚星对天府也有一定的危害，但如果煞星不多，影响不大。 天府坐命的人，戊宫的廉贞天府和寅宫的紫薇天府较佳，午宫的武曲天府也不错。如果有左辅右弼相会，加强天府领导力、开创力，又有禄存、化禄相会，增强天府财气，也能成就事业。 此外，天府坐命、身宫，喜吉星与化科同宫，增加命主聪明才智，利于事业上的表现，三方有化科拱照次之。"},{"title":"命格","path":"/ziwei/命格.html","content":"巨门化忌在午 – 石中隐玉格 太阴化忌在亥 – 月朗天门格 七杀在午坐命，与羚星同缠，不算破格。"},{"title":"要点","path":"/ziwei/要点.html","content":"男命女命有别 男命夫妻宫坐天相 – 妻子旺夫 女命夫妻宫坐天相 – 丈夫平平 男命七杀破军坐命 – 一生会有动荡 – 苦尽甘来 女命七杀破军坐命 – 一生会有动荡 – 丈夫事业不顺 当代社会，男重事业，女重婚姻，需从世俗的角度进行解释，不可添加主观意识。 原则： 不动不占 主流文化为主，次留文化为辅 不可越权：只提供信息，不做决策 宫位，星耀，飞化 三财星（单指财）：太阴、天府、武曲 两禄星（正道之财）：禄存、化禄 财星也可能化禄，财禄双全，财运好"},{"title":"紫微星","path":"/ziwei/紫微星.html","content":"紫薇、武曲、廉贞，永远合成三方会照结构。紫薇代表帝王，是权利的中心；廉贞是紫薇的下属，是基层官员；武曲代表财政资金。三者紧密相连，一荣俱荣、一损俱损。 陆斌兆先生的讲义中，有三种组合： 百官朝拱：左辅、右弼、文昌、文曲、天魁、天钺、三台、八座、龙池、凤阁、恩光、天贵、台辅、封诰、天官、天福、禄存、天马。天才、天寿这两颗主要是增加自身能力，不属外力，因此不列入文武百官之列。 孤君在野：没有文武百官相助，人生显得孤独、艰辛。很多事都要亲力亲为，难以依靠别人。 无道之君：不仅没有文武百官相助，还遇到擎羊陀罗、火星铃星等煞忌冲照，会变得喜怒无常，善谋好诈，行止不端，往往会有不良嗜好。 文武百官中，最喜左辅、右弼、禄存，也喜化禄、化科。 左辅行善令，右弼司制令 – 左辅星主要的作用是赏与帮助，右弼星的作用是惩罚与制止。 紫微星坐命时，如果没有遇到左辅右弼、即使有文昌文曲、天魁天钺，也会感到孤独，不能称之为大富大贵之格。但若煞星少，也有福可享，只是缺少左辅右弼，开拓力度小，发展局面不大。 紫薇星喜在三方四正遇到禄存、化禄。以武曲化禄为最佳，对财运帮助大。 紫薇在子、午独坐，三合宫有廉贞、天府、武曲，迁移宫是天狼星，为府相朝垣格。如果成这种格局，命运发展会比较顺遂，即使有煞星冲破，也不为下贱，做中局来论。紫薇坐命在午宫，又被称为极向离明格，比在子宫优越许多，但以见吉星吉化为佳。如果没有吉星吉化，成就不会特别大。 紫薇在丑、未与破军同坐命宫，三合有廉贞、贪狼、武曲、七杀拱照，迁移宫是天相。这样的结构，最宜左辅右弼夹命，能大大增强其人的领导力与开创力，左辅右弼三方会照次之。如果是甲年生人，破军化权、武曲化科，又得会照，成就很大。 紫薇在寅、申与天府同坐命宫，三合有廉贞、天相、武曲拱照，迁移宫是七杀。紫府同宫，最宜有禄存、化禄会照，得禄可以稳定发展。有左辅右弼、天魁天钺则更佳，增加其人领导力与开创力。 紫薇在卯、酉与贪狼同坐命宫，三合有廉贞、七杀、武曲、破军拱照，迁移宫是空宫。紫薇贪婪的结构叫桃花犯主，是情欲很重的组合，无论男女，都比较重视感情，容易感情用事、意气用事的情况，不够理智。相对来说，紫微星本身好享受、重享受，不喜与贪狼同宫，因为贪狼有强烈的欲望和享乐的色彩，会加重紫薇的享乐色彩，进而对事业造成不利，缺乏事业心，吃不得苦。但遇到左辅右弼、天魁天钺、化禄、化权、化科，会使人能力增强、运气变好，也会在事业上有杰出表现。至于文昌、文曲，会使紫薇贪狼情欲增强，个性更为浮华，不见为妙。如果三方四正不见吉星吉化、命宫也没天刑、地空、地劫制衡贪狼，便会热衷于吃喝玩乐，喜欢粉饰外表，不能脚踏实地，不能吃苦耐劳。紫微贪狼在卯宫坐命，比在酉宫坐命时情欲更重。 紫薇在辰、戌与天相同坐命宫，三合有廉贞、武曲、天府拱照，迁移宫是破军。这样的结构，由于落在天罗地网，紫微星表现出自私的一面，自我保护意识很强，甚至显得冷酷，不近人情。但是只要有吉星、吉化和大运配合，事业也能有所成就。财帛宫为武曲、天府两个财星坐守，喜禄存、化禄、左辅右弼、天魁天钺等吉星，可大富。 紫薇在巳、亥与七杀同坐命宫，三合有廉贞、破军、武曲、贪狼同照，迁移宫是天府。这个结构的开创力很强，不畏艰难成大业者多为紫薇七杀坐命。紫薇七杀和紫薇破军一样，都有横发横破的性质，这样的命格，需谨慎推演，详细参考大运走势。紫薇七杀坐命，如果三方四正煞星多，也可成为黑道人物，或触犯法律。 紫薇破军、紫薇七杀的命盘，适合男人。女命紫薇七杀，比较孤独，需要自己拼搏，从丈夫身上得到的助力不大。女命紫薇破军，我行我素性格明显，对丈夫不利。相对来说，女命紫微破军比紫薇七杀好一点，见吉星吉化主富贵享受，但越富贵越有红杏出墙的危险。紫微破军多是靠个人能力赚钱。紫薇破军坐命的人，与紫薇贪狼坐命类似，尽量约束自己的欲望，提高个人的道德修养。在行廉贞贪狼的流年时，若见到天姚、红鸾等桃花，又遇煞星、化忌，往往对紫薇破军坐命的人不利，会因色生财。 紫薇喜与三台、八座、台辅、封诰同宫，减少紫薇的辛劳。见到恩光、天贵，提高紫薇的知名度。见龙池、凤阁，则高洁，但也会更加骄傲。见天官、天赐则人生发展稳定，福气增多。 紫薇入六亲宫，代表这些人会帮助自己，以不见煞忌为准。此处的煞星包括擎羊陀罗、地空地劫、火星铃星，也包括七杀、破军、天刑等。如果六亲宫遇到紫薇，又与煞星同宫，表示这个宫位的人以自我为中心强烈，较少顾及他人的感受，对命主不利。紫薇落在六亲宫时，若想获得该宫位的人的帮助，命主必须接受他人的控制、调遣。 紫薇在父母宫时，以见左辅右弼为佳，表示父母能帮助自己，父母能力强，大部分代表父亲能力强。但是紫薇在父母宫见左辅右弼时，不宜见到红鸾、天喜、天姚等桃花星同宫，否则表示父母间会出现第三者。紫薇七杀、紫薇破军在父母宫，易有代沟。紫薇贪狼在父母宫，不宜与桃花星同宫，易有多父母。紫薇在父母宫时，并不代表父母早逝，只是因为煞星的影响会导致关系不和、矛盾变多，不宜与擎羊、天刑等煞星同宫，代表矛盾增大。紫薇天府、紫薇天相在父母宫要好得多，通常对六亲关系有利。如果父母宫是紫薇化权，代表父母管教严格，要求高，相处不易。 紫薇在兄弟宫，遇禄存、化禄、天魁天钺、左辅右弼等吉星，代表兄弟同事能力强。如果遇煞星、化忌，大多数不宜与人合伙，会有矛盾、纠纷、破财等问题发生。紫薇七杀、紫薇破军在兄弟宫，本人得到兄弟姐妹的助力较少，与外人合作的助力也一般，如果见到煞星、化忌较多，不宜合作。紫薇贪狼在兄弟宫、奴仆宫，表示与兄弟姐妹朋友玩得好，见左辅右弼、天魁天钺会有助力，无吉星则助力普通。 紫薇在夫妻宫，表示本人眼光高，配偶能力强，或配偶的财产，身份高过自己，也代表配偶的志气高、眼界高，易看不起人。夫妻宫的紫薇，忌与破军同宫，表示婚姻变化无常，婚后也不太平，宜晚婚。男命对妻子有刑克。见吉星、吉化代表配偶可以帮助自己，但自身会受到配偶控制。如果夫妻宫紫薇没有遇见吉星、吉化，一般对命主的助力不大。紫薇七杀在夫妻宫，双方感情较平淡，本人会受到配偶的压力。紫薇贪狼在夫妻宫，最怕遇到桃花星，表示会有第三者介入，最好是婚前遇挫折，则婚后能逐渐稳定。紫薇天相在夫妻宫，男命大多重视事业，对爱情看的并不是很重，妻子以与自己小七、八岁为佳；女命则适合找一个七、八岁以上的丈夫，如果找同龄人，夫妻生活难以和睦。紫薇在夫妻宫独坐，比紫薇贪狼同宫好一些，但也主婚姻不稳定。总的来说，紫薇天相坐夫妻宫最稳定。"},{"title":"光敏垫固定曝光思路","path":"/stamper/光敏垫固定曝光思路.html","content":"这几天看了几个同行生产的套色印章，发现他们的位置匹配度十分好。 目前我们的工艺还是手动定位的方式，所以会存在曝光偏差的情况。 套色盖印使用了一个固定位置的模具，然后把每个印章都往上盖，可以从中借鉴一下。 暂定 a5 大小的纸，然后厚度和常规的光敏垫厚度一致，把图案印刷到 a5 大小硫酸纸上，然后把纸插入 a5 大小的，结构与光敏垫一致的位置中。这个方法需要制作模具，材质可以选择亚克力，合成树脂等高硬度的。 第二个方法就是在图案周围放一些线条，把整个光敏垫固定在里面。但是这种方法也会有个问题就是，手工对齐存在误差，做套色印章的话估计失败率较高。 前期普通印章可以使用这个方式。"},{"title":"紫微斗数","path":"/ziwei/index.html","content":"紫微斗数笔记"}]
[{"title":"2022总结","path":"/2023/01/08/2022总结/","content":"一年一度的总结时间转眼又是一年了,这三年,一年比一年魔幻. 1 月:深圳开始 24h 核酸 2 月:离职 3 月:回家 … 8 月:进厂.真正意义上的进厂,做 battery pack. … 11 月:乌鲁木齐起火烧死人,引发国内某些地方开始抗议. 12 月:大放开,预计死亡会上百万人.但是目前为止官方的死亡人数还停留在 17 人. 后续会如何发展,这下谁也说不准了.这就是习近平,能猜到他,他就不叫习近平了.做了那么多事,没有一件是成功的,千古留名. 去年的目标 学习公司管理方面的知识:没有时间 学习订单流程:没有时间 去广东主要城市旅游:没有时间,不过去了一次福建漳州,东山岛 &amp; 土楼 学习英语:继续保持 量化基本知识:没有时间 命理学:没有时间 明年预计完成的事情一直都很讨厌进厂.不是因为工资低,工作累,主要的原因是 i don’t have enough free time.真的没有时间去完成自己的事情,每天 8:00 am 上班 9:30 pm 下班,11 个小时花在工厂里,加上晚上还要陪女朋友,真的没有时间.唯一的可能就是,压榨睡眠时间,但是容易猝死. 英语,需要到精通需要学习上万小时,努力吧. 攒钱了,先把婚姻大事搞定. 目前的几本书先看完 陪女朋友出省旅游一次 日语还是慢慢来吧 电池健康管理 感觉奶奶有点老年痴呆了总要走到生死离别的.今年准备买车了,趁有时间多回家陪陪奶奶吧.","categories":["年终总结"]},{"title":"shopify开店Day1","path":"/2022/08/08/shopify开店Day1/","content":"开店第一天 确定了店名，就叫 Edward Store，暂时当个杂货铺吧，后期需要转型的话也方便。 注册域名。 开 Shopify 店铺。 已完成事件 注册域名 注册 shopify 店铺","tags":["shopify"]},{"title":"Mac 无法通过 path 打开 code 记","path":"/2022/07/27/Mac-无法通过-path-打开-code-记/","content":"起因许久未使用mac，然后发现在terminal里使用code &lt;name&gt;的时候，报错了。 12/usr/local/bin/code: line 6: /usr/bin/python: No such file or directory/usr/local/bin/code: line 10: ./MacOS/Electron: No such file or directory 后面才发现，系统里只有python3，没有python，遂在/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code中将python修改为python3得以解决。"},{"title":"07-26-2022记","path":"/2022/07/26/07-26-2022记/","content":"许久未登，上来看看。发现checkbox不渲染了，于是找了个插件处理了 hexo-renderer-marked 近来股票依旧捉摸不透 事业毫无长进 还在摸索之后的道路","tags":["整理"]},{"title":"04-21-2022记","path":"/2022/04/21/04-21-2022记/","content":"炒股记录还是得看大盘炒股。前几日没卖，导致-17%再现","tags":["整理"]},{"title":"03-31-2022記","path":"/2022/03/31/03-31-2022記/","content":"今日炒股記錄又一次做T失敗了。總覺得不會漲到那麼搞，結果又追高了。一直盯盤十分影響心態，不能這樣繼續下去。 之後每天只看尾盤（14:30），其他時間不打開炒股軟件。","tags":["整理"]},{"title":"普京出兵乌克兰","path":"/2022/02/22/普京出兵乌克兰/","content":"出兵了！普京指示俄军方确保顿巴斯地区和平，表示“乌是俄历史上不可分割的一部分”！当地时间 21 日，俄罗斯总统普京在宣布承认顿涅茨克人民共和国和卢甘斯克人民共和国独立后，指示俄罗斯国防部在俄罗斯与顿涅茨克人民共和国和卢甘斯克人民共和国的友好合作互助条约被批准之前，确保俄罗斯武装部队维护顿涅茨克人民共和国和卢甘斯克人民共和国的和平。 据澎湃新闻，当地时间 2 月 21 日，俄罗斯总统普京发表全国电视讲话时表示，乌克兰不仅是邻国还是俄罗斯历史上不可分割的一部分，乌民众是俄方的同志和亲人，是有血缘关系的人。 据悉，联合国安理会将应乌克兰方面请求，于美东时间 21 日晚 9 时（北京时间 22 日上午 10 时）召开紧急会议。本月联合国安理会轮值主席为俄罗斯。 乌克兰地区局势紧张，国际资本市场避险情绪升温，推动股票等权益类资产进一步被抛售，而金价和黄金股均进一步上涨。 继欧洲股市普跌之后，亚太股市也普遍下跌，日经 225 指数开盘跌 1.5%，韩国 Kospi 指数下跌 1.41%。A 股市场今天上午也进一步调整，各大指数均现显著下挫，近 4000 股下跌。港股方面亦在调整，恒生指数盘中大跌超过 3%，截至午盘仍跌 2.95%。 普京要求俄军 维护两个“共和国”的和平 据央视新闻，俄罗斯法律门户网站发布了俄总统普京 21 日签署的承认顿涅茨克人民共和国和卢甘斯克人民共和国的总统令内容。根据总统令，因乌克兰拒绝执行明斯克协议，根据当地人民的意愿，俄罗斯承认两个共和国为独立主权国家。总统令责成俄外交部开始与两国进行建立外交关系的谈判，与俄罗斯其他有关部门起草友好合作互助条约，并按程序完成条约的签署。总统令要求俄罗斯国防部在友好互助条约被批准之前确保俄罗斯武装部队维护顿涅茨克人民共和国和卢甘斯克人民共和国的和平。 当日稍早时，俄罗斯总统普京发表全国视频讲话，宣布承认乌东民间武装自称的顿涅茨克人民共和国和卢甘斯克人民共和国为独立国家。 据环球网援引俄罗斯《观点报》22 日报道称，网上有消息称俄军已开始抵达顿巴斯地区，也有人公布了相关视频。 报道称，国际文传电讯社援引目击者的话说，两个装甲车队已处于“顿涅茨克共和国”并向该其北部和西部前进。 报道还称，乌克兰 OstroV 通讯社援引社交媒体的消息称，“俄军第一批部队正进入”顿巴斯地区。 据央视新闻，俄罗斯国家杜马议员米哈伊尔·谢列梅特当地时间 22 日表示，对于俄罗斯宣布承认乌克兰东部“顿涅茨克人民共和国”与“卢甘斯克人民共和国”独立，西方国家准备对俄罗斯实施新的制裁措施，对此俄罗斯已经做好了一切准备迎接事态发展，俄罗斯不会胆怯。俄罗斯不惧怕西方国家的制裁，我们重视的是人民的生命安全而不是经济。","tags":["history"]},{"title":"中国计划生育协会2022年工作要点","path":"/2022/02/10/中国计划生育协会2022年工作要点/","content":"2022 首个魔幻文件日前，中国计划生育协会官网公布的《中国计划生育协会 2022 年工作要点》（以下简称《工作要点》）提到，2022 年，要实施生殖健康促进行动，重点解决青少年、育龄人群及其他特定人群生殖健康的突出问题，开展未婚人群人工流产干预专项行动，减少青少年意外怀孕和人工流产，提高群众生殖健康水平。在新型婚育文化的建设上，上述《工作要点》称，要以“尊重生育的社会价值，提倡适龄婚育、优生优育，鼓励夫妻共担育儿责任，破除高价彩礼等陈规陋习”为重点，加强对青年婚恋观、家庭观引导，重塑多子女家庭养育文化，淡化教育焦虑，弘扬“孝”、“和”家庭价值观，推动构建积极正向的新型婚育文化。开展新型婚育文化建设项目试点，大力推广新宣传标语口号，倡导将新型婚育文化内容纳入村规民约，修订与中央《决定》精神不一致、不适应的内容。发挥“5.29 会员活动日”宣传品牌、文化社等作用，打造新环境宣传载体，注重运用网络和新媒体等青年群体喜爱的方式，在潜移默化中培育新型婚育观念。","tags":["history"]},{"title":"汤加火山爆发","path":"/2022/01/18/汤加火山爆发/","content":"又一次见证历史了。预计级别会达到VEI6，不知道后续会不会继续喷发。没想到，疫情还未过去，出现了一个比疫情更严峻的现实问题——无夏之年。 更新于2022年7月26日17:22:50我错了，最近的温度已经到达了40℃。","tags":["history"]},{"title":"2021总结","path":"/2022/01/08/2021总结/","content":"一年一度的总结时间2021，辛丑年。这一年，似乎发生了许多事；事情太多，以至于能记住的太少了。 教育减负，新东方股价蒸发 90% 房产暴雷，恒大欠债 1.6 万亿 疫情，孕妇流产、心梗无法救治、猝死、…… 是好事吗？是坏事吗？长远来看，民智开化了许多，不再一味地听从党和政府，有了自己的思考。但是，如果一个政府没有了民心支持，那么他还能维持不倒吗？每次变革都是流血，只希望不要起太大的冲突。 去年的目标 加薪：今年无加薪，可能是疫情原因。不过没所谓，已经准备不干了。 独自旅游：去了广州、潮州、汕头等地。 学习炒股：只学习了皮毛，感觉技术分析始终只是判读过去，无法预知未来。需要多了解一下订单流。 学习数学：丝毫未看。 深入技术：深入了解了React源码以及部分Vue源码，虽然不准备干这行了，但是为了留后路还是需要时常补习。 学习色彩与构图：构图算是入了个门，色彩尚未开始。学习，就是需要多看，多实践。纸上得来终觉浅，绝知此事要躬行。 明年预计完成的事情 学习公司管理方面的知识。 学习整个订单流程。短期内应该是需要自己动手，了解之后才知道如何改进。 有机会的话，游遍整个广东的主要城市吧。 英语当然是要坚持打卡的。 学习命理知识。 加一个量化的基本知识吧。 花无重开日，人无再少年。奶奶年纪也大了，每天下班看着地铁内的人，心情极差。思来想去，打工也是一辈子，闯一闯也是一辈子，再者八字暗示会有长辈相助，适合从商，那就搏一搏吧。转行要趁早。同时，不能被利益迷惑了双眼，保持初心。现在公司的老板，初心已经变了。从最开始的打造全国顶尖云存储，到现在的只想噶韭菜，整个人都疑神疑鬼的。还是得学习稻盛和夫的公司管理，一个公司，不仅仅是用于赚钱的工具，更多的，是为那些工人提供避风港。","tags":["整理"],"categories":["年终总结"]},{"title":"《乡土中国》记录","path":"/2021/12/09/《乡土中国》记录/","content":"序言 农业和游牧或工业不同，它是直接取资与土地的。游牧的人飘忽不定，工业可以择地而居。而种地的人却搬不动地。 从农业本身来看，是无需群居的。最小的社区可以只有一户人家。夫妻和孩子聚集，满足两性与抚养的需要。无论在什么性质的社会里，家庭总是最基本的抚养社群。 中国农民聚集而居原因： 耕地面积小，小农经营。住所与耕地不会相隔太远 需要水利，所以大家一起合作。 合作弊害。 土地继承。 农村属于 face to face group，所以 文字 在农村并没有太大意义。 社会学中通常两种不同性质的社会： 共同体：没有主要的目的聚集。 社会：有主要的目的聚集。 孝是什么，孔子并没有抽象地加以说明。最后归结到“心安”二字。做子女的在日常接触中熟悉父母的性格，然后承他们的欢，做到心安。 文字下乡大家口中的愚，并不是觉得农村人不聪明，只是因为农村人不识字。主要的原因还是在于农村环境下，接触到文字的地方很少。但是并不代表农村人学习能力差。 不善用文字 -&gt; 学习机会少 -&gt; 文盲 乡下孩子不像教授们的孩子到处看见书籍，到处接触字。 并不见得他们的孩子有什么善于辨字的能力，显而易见的是他们有易于识字的环境。 文字，一种双方约定好代表一种意义的记号。文字所能表达的情感有限，所以需要使用文法，还原意境。 由于文字是用于双方交流，所以不能有个人的语言，只能有社会的语言。要让大多数人能对同一象征具有同一意义，他们必须有相同的经历（文化沉淀）。 在每个特殊的生活团体中，必有他们特色的语言，其他语言无法翻译。 群体愈大，人群的经验愈复杂，发生语言的共同基础也必愈有限，于是语言会趋于简单化（文言文 -&gt; 繁体 -&gt; 简体（同化））。在社群使用的通用语言之外，必然会产生一些少数人使用的语言（行话）。行话是同行人中的话，外行人因为没有经验，无法理解。 最普遍的特殊语言发生在母亲和孩子之间。 在亲密社群中可用来做象征体系的原料比较多。表情、动作，在面对面的情境中，有时比声音更容易传情达意。 再论文字下乡 文字是发生在人和人传情达意的过程中受到了空间和时间的阻隔的情境里。 时间上的隔阂： 今夕之隔 社会的世代之隔 小白鼠并不向其他老鼠学习，每只老鼠都在自己的具体情境里，从“试验”中得到个别的经验。他们并不能相互传递经验，相互学习。 文化：社会世代共同的经验累积。 大多数记忆，是由于当前的需要，而追忆过去。记忆并非无所为的，而是实用的，为了生活。乡土社会是一个很安定的社会，在一个地方出生，就在这个地方生长直到死。 极端的乡土社会是老子的理想社会，“鸡犬相闻，老死不相往来” 由于乡土社会安定，所以社会积累的经验永远不会更新。经验无需积累，只需保存。语言在这种社会里，算是可以传递世代的经验。 大家在同一环境里，你先走，他后走，靠的是口口相传，哪里需要文字。 中国是乡土社会，为什么会产生文字呢？ 中国社会从基层上看是乡土性，但是文字并不是从基层上发生。在乡土社会，面对面的接触中，并不是愚昧到字都不认识，而是文字没有帮助他们生活的必要。 差序格局 中国人可以为了自己牺牲家，可以为了家牺牲族。只要一件物品是公家的，意味着可以“不负责”。 家庭在西方是界限分明的团体，一般只由父母、孩子组成。中国人的家，可以大到一片地方都属于自己家，也可以小到自己就是自己家。 家族，地缘关系的体现。不是一个固定的团体，而是一个范围。有势力的人家的街坊可以遍及全村，穷苦人家的街坊只是比邻的两三家。 西方社会里争的是权力，而中国社会却多的是攀关系、讲交情。西方社会的团体是按照资格划分：有资格的进入群体，没资格的自动脱离群体。 个人主义：基于团体的概念，个人是团体的一份子。 自我主义：以自我为中心。 在传统的社会结构里最基本的概念，人来人往所构成的网格中的纲纪，就是一个差序，也就是伦。《礼记》大传里说：“亲亲也，尊尊也，长长也，男女有别，此其不可得与民变革者也”。社会的架构是不变的，变得只是利用这架构做的事情。 在差序格局中，社会关系是通过一个个人推出去的，是私人关系的增加，社会范围是一根根私人联系所构成的网格。社会道德在私人关系中才有意义，所以现代社会需要法律来进行约束。 在差序格局里，公和私是相对而言的，站在任何一圈里，在外看是私，在内看就成了公。 维系着私人关系的道德 中国人的道德和法律，具有伸缩性，要看对象和子的关系而定。在一个安居的乡土社会，每个人可以在土地上自食其力地生活时，只在偶然和临时的非常状态中才感觉到伙伴的需要。和别人的关系是次要的，而且在不同场合下需要不同的结合，并不需要一个经常性的团体，因此社会采用了“差序格局”。道德是社会对个人行为的执行力。 执行团体的意志时，需要代理者（例如：牧师、发言人、算命先生）。团体不能为任何个人所有。如果代理者违反了这些“不证自明的真理”，代理者就失去了代理的资格。为了防止代理者滥用权力，所以发生了宪法。 宪法观念是和西洋公务观念相配合的。国家可以要求人民服务，但是国家也得保证不侵害人民的权力，在公道和爱护的范围内行使权力。 但是在中国这种差序格局中，不容易找到个人对团体的道德因素。在西洋团体格局的社会中，公务、履行义务是一个清除明白的行为规范。孝悌忠信，都是私的关系。道德仅存于私人关系之间。 家族在西方，家是团体性社群，夫妇是主轴，经营的事务很少，主要是生儿育女。但在中国的乡土社会里，“家”在结构上俨然是一个氏族，根据单系（父亲）亲属原则所组成的社群，且构成的分子不仅限于亲子关系，因而具有生育和事业的双重功能。 家庭（Family）：西方观念，由亲子（双系，父母双方）构成的生育社群。主要是为了生育。孩子成长之后，脱离父母抚育，去成立新的家庭。所以“家庭”是暂时性的，抚养孩子的目的就在于抚养结束。 家族（Extended Family）：乡土社会中的基本社群，具有生育之外的功能，夫妻之间的合作不因停止抚育孩子而停止，是长期的稳定的合作。 大家庭：结构复杂（父母、子女、婿、媳、堂、表等组成），不按数量区分。 小家庭：结构简单。 中国家族的扩大是单系的：大部分的家并不能同时包括儿媳和女婿。在父系原则下，女婿和结了婚的女儿都是外家人。在社会学里，单系亲属组成的叫做“氏族”，但是氏族是由许多家族组成，所以中国的家族，实际上是“小氏族”，结构原则上一样。 人类学上的说法，氏族是一个事业组织，再扩大就可以成为部落。具有政治、经济、宗教等复杂功能。中国乡土社会采取差序格局，利用亲属的伦常去结合社群，经营各种事业，把基本的家变成了氏族性。 在乡土社会中，家是个连续性的事业社群，他的主轴是父子之间，婆媳之间，是纵的。夫妻之间，异性之间，属于副轴。一切事业都不能脱离高效率，高效率就得有纪律，就不能有私情。所以夫妻之间“相敬如宾”，女子“三从四德”，亲子间讲究负责和服从，都是事业性社群的特点。夫妻俩各自之间有各自的工作，属于合作关系，感情占比不大。同时同性和同性之间联系比较多，性别和年龄组之间保持着很大距离，这是将生育之外的功能拉入这社群之后的结果。 男女有别从社会关系上来说，感情是具有破环和创造作用的。感情的激动改变了原有的关系。如果要维持固定的社会关系，就得避免感情的激动。 两种文化模式： 阿波罗（Apollonian）：宇宙有一个完善的秩序，人只是去接受它。 浮士德（Faustian）：冲突是存在的基础。文化就是无尽创造的过程，不断改变。 乡土社会是阿波罗式的，现代社会是浮士德式的。 乡土社会靠亲密和长期的共同生活来相互配合，社会是熟习的，每个人对彼此都足够了解。完全的道义必须有充分的了解，无所隔，但是由于两性关系，性别的鸿沟是基本的阻碍。所以乡土社会选择对性进行抹杀。浮士德是感情的象征，把感情的激动，不断地变化，作为生命的主脉。 在乡土社会，不需要创造新的社会关系，社会关系是生下来就决定的。社会结构多的是同性之间的组合。家庭受到同性组合的影响，不易维护，于是家族代替了家庭，成了以同性为主、异性为辅的单系组合。乡土社会是个男女有别的社会，也是一个安稳的社会。 礼治秩序乡土社会属于无政府社会，一种不需要规律的秩序，自动的秩序，无治而治。礼制社会并不一定是君子国，并没有文明的意思，礼制也可以很野蛮。礼是社会公认合式的行为规范。法则是由国家权力执行的规章制度。在乡土社会中传统效力更大。但是在一个变化快的社会，传统的效力是无法保证的，礼制社会是不能在变迁快的时代出现的。所以当现代社会的法进入乡土社会后，破坏了他们的礼，甚至认为律师是帮着法说话的坏人。 无讼法律属于专业知识，所以在都市中存在律师、法律顾问等职位。但在乡土社会里，不懂礼就成了坏人。打官司，必然是有人破坏了传统规矩，父母官应该做的是教化，而不是折狱。 理想的礼治是每个人都自动的遵守规矩，不必有外在的监督。社会假定每个人是知礼的，至少社会有责任使每个人知礼，这也是乡土社会中通行连坐的证据。 与礼不同的是，法不考虑伦理问题，只保护应有的权力不受侵犯。所以在不同的场合下，往往有不同的判决方法，导致无法沉淀。 在差序格局中，不认为具有一套人人通用的法。所以现行的司法制度在乡间发生了很特殊的副作用，它破坏了原有的礼治秩序，但并不能有效的建立起法制秩序。 无为政治权力： 社会冲突来看（横暴权力）：权力是冲突的持续，性质还在，但被支配的一方认输，属于压迫性质。 社会合作来看（同意权力）：干涉别人是权力，被别人干涉是义务，权力的基础是同意制度。 权力之所以诱人，最主要的应当是经济利益。在同意权力下，有权利者并不是为了保障自己的特殊权益，所以必须用荣誉和高薪来延揽。但在横暴权力下，统治者要用暴力来维持他们的地位，维护自己的利益。 一个只生产他生存必需品的人是没有资格做奴隶的。在农业民族的斗争中，最主要的方式就是把土著赶走而占据他们的土地自己来耕种。 和平发展 -&gt; 积累力量 -&gt; 扩大势力 -&gt; 民不聊生 -&gt; 内乱 -&gt; 伤亡惨重 -&gt; 和平发展 乡土社会可以自给自足，是同意权力扩大的阻碍。所以皇帝长远来看，是无为的。 长老统治中国除了横暴权力、同意权力，还存在一种教化性的权力。 在被教化的古城镇并不发生这个问题，被教化者并没有选择的机会。文化，是先他而存在的。 血缘和地缘年长对年幼有强制的权利，这是血缘社会的基础。血缘的意思是人和人的权利和义务根据亲属关系决定。职业、财富、地位都存在继承。生育没有社会化之前，血缘作用的强弱是以社会变迁的速率决定。 血缘是稳定的力量。血缘是先人而存在的，地缘是血缘的投影 一个地方的人口发展到一定的规模，就不得不去另寻住处。但不论怎么发展，与最开始都保持着地缘关系，即使后来成为了其他乡的人。 在亲密的血缘社会中商业是无法存在的。他们之间的交易是以人情来维持的，是相互馈赠的方式。外乡客成了商业的媒介，商业是在血缘之外发展的。 所以大家会聚集在集市贸易，抛开彼此的血缘、地缘关系。 地缘是从商业里发展出来的社会关系。血缘是身份社会的基础，地缘是契约社会的基础。 名实的分离社会变迁快，长老权利小；社会变迁慢，长老权利大。社会结构自身也存在变迁。由旧结构到新结构之间，会出现时势权利（苏联：形式上是独裁的，但是从苏联人民的立场来看，苏联的独裁和沙皇的独裁并不一样）。 长老权利是建立在教化作用之上的，教化是有知对无知，如果所传递的文化是有效的，被教的自然没有反对的必要。在横暴权利下，没有反对，只有反抗。在时势权利中，反对是发生于对同一种问题不同的答案上。 面子就是表面的无违，名实之间的距离随着社会变迁速率增加。 从欲望到需要 乡土社会，欲望驱动。 现代社会，需要驱动。 欲望 -&gt; 紧张 -&gt; 动作 -&gt; 满足 -&gt; 愉快，那是人类的行为过程。欲望如果要通过意志对行为有所控制，它必须是行为者所自觉的。 人类现有行为，后有思想。决定行为的是从试验与错误的公式中累计出来的经验，思想只有保留这些经验的作用，自觉的欲望是文化的命令。社会变迁快，文化无法满足于生活，逐渐重视起功能，从欲望到了需要。 在现代社会里只是即是权利，因为在这种社会里生活的人要依他们的需要做计划。从知识中得来的权利是时势权利。乡土社会是靠经验的，他们不必计划，因为在积累的过程中，自然替他们选择出了一个足以依赖的传统生活方案，各人遵照执行即可。","tags":["记录"]},{"title":"阿米巴经营记录","path":"/2021/12/08/阿米巴经营记录/","content":"日航哲学 – 成功方程式 人生 · 工作的结果 &#x3D; 思维方式 _ 努力 _ 能力 作为人，何谓正确 领导人率先垂范，以身作则。 阿米巴系统京瓷的经营理念： 在追求全体员工物质和精神两方面幸福的同时，为人类社会的进步发展做出贡献。 阿米巴经营是通过一个个小集体的独立核算来实现全员参与经营、凝聚全体员工力量和智慧的经营管理系统。 但是在 乌合之众 中说到，群体聚集在一起的智商，只会降低。所以是否可以利用群体的力量，独立的领导人（智慧&amp;方向），达到目的。 阿米巴经营的目的 确立与市场挂钩的分部门核算制度 培养具有经营意识的人才 实现全员参与的经营 创业初期部门结构 核心技术在研发 传统公司经营模式 如果市场价格波动，销售的售价必然下降。此时，如果减少销量，会增加库存。增加销量，成本增高，总利润下降。 此时拆分成阿米巴之后，生产和销售之间必然会产生分歧。此时直接损害生产部的利益，所以传统经营模式在阿米巴经营中并不适用。 细分阿米巴的三个条件 能够独立核算的单位 独立完成某个业务的单位 划分组织必须有利于实现公司的方针和目标","tags":["记录"]},{"title":"Windows VL 激活","path":"/2021/11/12/Windows-VL-激活/","content":"激活 Windows 查看 OS 版本： run.exe: slmgr.vbs -dlv，查看产品密钥通道。 OEM：出厂版本 Retail：零售版本 VL(Vol)：批量激活版本 只有 VL 版本可以激活。 使用 cmd：slmgr /skms kms.03k.org，把skms地址设置为 kms.03k.org slmgr /ato，手动激活 激活 OfficeOffice 必须是 VL 版本 进入 Office 安装地址，找到 OSPP.VBS cmd：cscript ospp.vbs /sethst:kms.03k.org，指定kms服务地址 cscript ospp.vbs /act，手动激活 工具网站：office tool plus","tags":["整理"]},{"title":"10/31/2021 记","path":"/2021/10/31/10-31-2021-记/","content":"晚上睡不着。看了一眼 HuoBi发现自己的合约被强制平仓了。陆续开始清退大陆用户。 也就几百块，取出来也没多大作用。 看了看最近的风口 Meta verse，买了点币。顺便跟着孙割买了点币。 15 个 MANA: 基于VR的游戏平台 9600 个 BTT: Bit torrent 之后HuoBi清退，还需要把币提出来。麻烦 周一看看能不能把股市内的基金投入到 恒生30ETF恒生ETF中很大一部分是 Meta Verse 概念。股市还是太难玩了。玩不明白。","tags":["记录"]},{"title":"Vue中对Array拓展的方法","path":"/2021/10/14/Vue中对Array拓展的方法/","content":"原理通过改写[].__proto__上的方法，实现对Array原生方法的拦截。 源码位置为 /core/instance/observer/array.js 123456789101112131415161718192021222324252627282930313233343536// cache the original Array.prototypeconst originalPrototype = Array.prototype;// create an object from original Array.prototypeconst arrayMethods = Object.create(originalPrototype);const methodsToPatch = [ &quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;reverse&quot;,];methodsToPatch.forEach((method) =&gt; &#123; arrayMethods[method] = function (...args) &#123; // use original Array methods to get the result const result = originalPrototype[method].apply(this, args); // proxy here console.log(`catch $&#123;method&#125;`); return result; &#125;;&#125;);const a = [1, 2, 3];a.__proto__ = arrayMethods;a.push(1);a.reverse();a.pop();console.log(a);","tags":["学习"]},{"title":"Promise a+","path":"/2021/10/08/Promise-a/","content":"Promise A+ 规范 promise：是一个拥有then方法的对象或函数，其行为符合本规范。 thenable：是一个定义了then方法的对象或函数。这个主要是用来兼容一些老的Promise实现，只要一个Promise实现是thenable，也就是拥有then方法的，就可以跟Promises/A+兼容。 value：指reslove出来的值，可以是任何合法的 JS 值(包括 undefined , thenable 和 promise等) exception：异常，在Promise里面用throw抛出来的值 reason：拒绝原因，是reject里面传的参数，表示reject的原因 Promise Status pending: 一个promise在resolve或者reject前就处于这个状态。 fulfilled: 一个promise被resolve后就处于fulfilled状态，这个状态不能再改变，而且必须拥有一个不可变的值(value)。 rejected: 一个promise被reject后就处于rejected状态，这个状态也不能再改变，而且必须拥有一个不可变的拒绝原因(reason)。 thenable1promsie.then(onFulfilled, onRejected); Optional parameters 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 onFulfilled如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值value 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因reason 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 thenthen 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 Returnthen 方法必须返回一个 promise 对象。 1promise2 = promise1.then(onFulfilled, onRejected); 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320var PENDING = &quot;pending&quot;;var FULFILLED = &quot;fulfilled&quot;;var REJECTED = &quot;rejected&quot;;function Promise(fn) &#123; this.status = PENDING; // initial status this.value = null; // initial value this.reason = null; // initial reason this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; var _this = this; function resolve(value) &#123; if (_this.status === PENDING) &#123; _this.status = FULFILLED; _this.value = value; _this.onFulfilledCallbacks.forEach((i) =&gt; i(_this.value)); &#125; &#125; function reject(reason) &#123; if (_this.status === PENDING) &#123; _this.status = REJECTED; _this.reason = reason; _this.onRejectedCallbacks.forEach((i) =&gt; i(_this.reason)); &#125; &#125; try &#123; fn(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;function resolvePromise(promise, x, resolve, reject) &#123; if (promise === x) &#123; reject(new TypeError(&quot;The promise and the return value are the same&quot;)); &#125; if (x instanceof Promise) &#123; x.then(function (y) &#123; resolvePromise(promise, y, resolve, reject); &#125;, reject); &#125; else if (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;) &#123; if (x === null) &#123; return resolve(x); &#125; try &#123; var then = x.then; &#125; catch (e) &#123; return reject(e); &#125; if (typeof then === &quot;function&quot;) &#123; var called = false; try &#123; then.call( x, function (y) &#123; if (called) return; called = true; resolvePromise(promise, y, resolve, reject); &#125;, function (r) &#123; if (called) return; called = true; reject(r); &#125; ); &#125; catch (e) &#123; if (called) return; reject(e); &#125; &#125; else &#123; resolve(x); &#125; &#125; else &#123; resolve(x); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; var checkOnFulfilled = onFulfilled; if (typeof onFulfilled !== &quot;function&quot;) &#123; checkOnFulfilled = function (value) &#123; return value; &#125;; &#125; var checkOnRejected = onRejected; if (typeof onRejected !== &quot;function&quot;) &#123; checkOnRejected = function (reason) &#123; throw reason; &#125;; &#125; var _this = this; if (this.status === FULFILLED) &#123; // 如果前面的 promise 抛出异常，后面的必须拒绝执行 var promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; if (typeof onFulfilled !== &quot;function&quot;) &#123; resolve(_this.value); &#125; else &#123; var x = checkOnFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); return promise2; &#125; if (this.status === REJECTED) &#123; var promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; if (typeof onRejected !== &quot;function&quot;) &#123; reject(_this.reason); &#125; else &#123; var x = checkOnRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); return promise2; &#125; if (this.status === PENDING) &#123; var promise2 = new Promise(function (resolve, reject) &#123; _this.onFulfilledCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; if (typeof onFulfilled !== &quot;function&quot;) &#123; resolve(_this.value); &#125; else &#123; var x = checkOnFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); _this.onRejectedCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; if (typeof onRejected !== &quot;function&quot;) &#123; reject(_this.reason); &#125; else &#123; var x = checkOnRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125;); return promise2; &#125;&#125;;Promise.resolve = function (parameter) &#123; if (parameter instanceof Promise) &#123; return parameter; &#125; return new Promise(function (resolve) &#123; resolve(parameter); &#125;);&#125;;Promise.reject = function (reason) &#123; return new Promise(function (resolve, reject) &#123; reject(reason); &#125;);&#125;;Promise.all = function (promises) &#123; return new Promise(function (resolve, reject) &#123; var count = 0; var result = []; var len = promises.length; if (length === 0) &#123; return resolve(result); &#125; promises.forEach(function (promise, index) &#123; Promise.resolve(promise).then( function (value) &#123; count++; result[index] = value; if (count === len) &#123; resolve(result); &#125; &#125;, function (reason) &#123; reject(reason); &#125; ); &#125;); &#125;);&#125;;Promise.race = function (promises) &#123; return new Promise(function (resolve, reject) &#123; var len = promises.length; if (length === 0) &#123; return resolve(); &#125; else &#123; for (var i = 0; i &lt; len; i++) &#123; Promise.resolve(promises[i]).then( function (value) &#123; return resolve(value); &#125;, function (reason) &#123; return reject(reason); &#125; ); &#125; &#125; &#125;);&#125;;Promise.catch = function (onRejected) &#123; this.then(null, onRejected);&#125;;Promise.finally = function (fn) &#123; return this.then( function (value) &#123; return Promise.resolve(fn()).then(function () &#123; return value; &#125;); &#125;, function (error) &#123; return Promise.resolve(fn()).then(function () &#123; throw error; &#125;); &#125; );&#125;;Promise.allSettled = function (promises) &#123; return new Promise(function (resolve) &#123; var len = promises.length; var result = []; var count = 0; if (len === 0) &#123; resolve(result); &#125; else &#123; for (let i = 0; i &lt; len; i++) &#123; (function (i) &#123; var current = Promise.resolve(promises[i]); current.then( function (value) &#123; count++; result[i] = &#123; status: &quot;fulfilled&quot;, value, &#125;; if (count === len) &#123; return resolve(result); &#125; &#125;, function (reason) &#123; count++; result[i] = &#123; status: &quot;rejected&quot;, reason, &#125;; if (count === len) &#123; return resolve(result); &#125; &#125; ); &#125;)(i); &#125; &#125; &#125;);&#125;;// for promises-aplus-tests testPromise.deferred = function () &#123; var result = &#123;&#125;; result.promise = new Promise(function (resolve, reject) &#123; result.resolve = resolve; result.reject = reject; &#125;); return result;&#125;;module.exports = Promise;","tags":["记录"]},{"title":"通用中心路由基座式微前端实现","path":"/2021/09/13/通用中心路由基座式微前端实现/","content":"什么是微前端微前端架构具备以下几个核心价值 技术栈无关：主框架不限制接入应用的技术栈，子应用具备完全自主权 独立开发、独立部署：子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新 独立运行时：每个子应用之间状态隔离，运行时状态不共享 现有解决方案 路由分发（nginx） npm子包：基座负责打包构建发布，打包时集成； iframe：应用之间完全独立；需要基座提供通信方案； 通用中心路由基座式：完全独立；需要基座提供通信方案；使用DOM实现；（阿里乾坤） 特定中心路由基座式：相同技术栈；复用基座公共基建内容；（美团广告业务） 方案对比 方案 技术栈是否能统一 单独打包 单独部署 打包部署速度 单页应用体验 子工程切换速度 工程间通信难度 现有工程侵入性 学习成本 NPM式 是（不强制） 否 否 慢 是 快 正常 高 高 iframe式 是（不强制） 是 是 正常 否 慢 高 高 低 通用中心路由基座式 是（不强制） 是 是 正常 是 慢 高 高 高 特定中心路由基座式 是（强制） 是 是 快 是 快 正常 低 低 通用中心路由基座式实现应用架构123456graph TBApp[App]App --&gt; App1[App1]App --&gt; App2[App2]App --&gt; App3[App3]App --&gt; App4[...] 实现方案1234567891011graph LRStart(Start)Start --&gt; Route(/subapp/xxx/index)Route --&gt; Match(根路由匹配到 /subapp)Match --&gt; DoubleMatch&#123;二级路由xxx匹配到子路由注册信息&#125;DoubleMatch --&gt; | 匹配失败 | MatchError(失败处理) --&gt; End(End)DoubleMatch --&gt; | 匹配成功 | IsLoaded&#123;检查是否已经加载&#125;IsLoaded --&gt; | 是 | Loaded(直接获取模块) --&gt; EndIsLoaded --&gt; | 否 | LoadJs&#123;异步获取JS&#125;LoadJs --&gt; | 失败 | MatchJsError(失败处理) --&gt; EndLoadJs --&gt; | 成功 | MatchSuccess(获取子工程模块) --&gt; LoadPage(显示子工程页面) --&gt; End 核心流程1、注册子应用12graph LRStart(Start) --&gt; GetList[拿到子应用列表] --&gt; Init[将子应用初始状态设置为 NOT_LOADED] --&gt; GlobalHook(设置全局生命周期) --&gt; End(End) 2、运行12graph LRStart(Start) --&gt; Hijack[Hijack Route] --&gt; Reroute[ReRoute] --&gt; LoadOther(对其他子应用进行资源预加载) --&gt; End(End) 3、页面路由切换12graph LRStart(Start) --&gt; ReRoute --&gt; End(end) 核心代码逻辑1、Hijack Route 设置全局变量 HistoryEvent 重写 pushState 方法，每次调用之后生成一个 PopStateEvent，赋值给 HistoryEvent 重写 replaceState 方法，每次调用之后生成一个 PopStateEvent ，赋值给 HistoryEvent 监听 hashChange ，调用 reroute 监听 popstate，调用reroute 对addEventListener和removeEventListener注入，对hashChange和popstate进行拦截 2、ReRoute actives：所有处于 active 状态的子应用列表 unmounted：所有处于 unmount 状态的子应用列表 1234567graph LRStart(Start) --&gt; IfUrl&#123;url !== lastUrl&#125;IfUrl --&gt; | false | End(End)IfUrl --&gt; | true | AppList[拿到app的状态列表]AppList --&gt; | unmount | UnMount --&gt; Finish[Finish]AppList --&gt; | active | BeforeLoad --&gt; Assets --&gt; Mounted --&gt; FinishFinish --&gt; OpenListener[启动监听] --&gt; End 生命周期函数1、beforeLoad12graph LRStart --&gt; Loading[set app state to LOADING] --&gt; GlobalHook --&gt; LoadHTML --&gt; Loaded[set app state to LOADED] --&gt; End LoadHTML： 12graph LRStart --&gt; Init[get container ant entry] --&gt; Dom[get dom node] --&gt; parseHTML --&gt; CSS[get external css] --&gt; JS[get external js] --&gt; RunCode --&gt; Return[return application] 2、Assets1234graph LRStart --&gt; IsLoaded&#123;&quot;status === LOADED&quot;&#125;IsLoaded --&gt; | false | EndIsLoaded --&gt; | true | Assets[set app state to ASSETS_LOADING] --&gt; RunApp[run app.assets] --&gt; NotMounted[set app state to NOT_MOUNTED] --&gt; End 3、Mounted12graph LRStart --&gt; Mounting[set app state to MOUNTING] --&gt; RunApp[run app.mounted] --&gt; GloalHook --&gt; Mounted[set app state to MOUNTED] --&gt; End 4、UnMounted12graph LRStart --&gt; UnMounting[set app state to UNMOUNTING] --&gt; RunApp[run app.unmount] --&gt; GlobalHook --&gt; NotMounted[set app state to NOT_MOUNTED] --&gt; End","tags":["学习"]},{"title":"module导入script方式","path":"/2021/07/19/module导入script方式/","content":"type=&quot;module&quot;1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;module&quot;&gt; // will not block the button console.log(this) // undefined console.log(import.meta.url) // the url of import file &lt;/script&gt; &lt;script&gt; // will block the button console.log(this) // window &lt;/script&gt; &lt;script async type=&quot;module&quot; src=&quot;http://example.com/test.js&quot;&gt; // will run immediate when the file is load // example.com needs the Access-Control-Allow-Origin flag import &#123;sayHi&#125; from &#x27;sayHi&#x27; // this will get error because no path import in this module block. &lt;/script&gt; &lt;script nomodule&gt; alert(&#x27;The Browser can not support the module import.&#x27;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Button&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","tags":["学习"]},{"title":"React Reconciler Diff Example","path":"/2021/07/19/react-reconciler-diff/","content":"before: abcd after: acdb &#x3D;&#x3D;&#x3D;第一轮遍历开始&#x3D;&#x3D;&#x3D;a（之后）vs a（之前）key 不变，可复用此时 a 对应的 oldFiber（之前的 a）在之前的数组（abcd）中索引为 0所以 lastPlacedIndex = 0; 继续第一轮遍历… c（之后）vs b（之前）key 改变，不能复用，跳出第一轮遍历此时 lastPlacedIndex === 0;&#x3D;&#x3D;&#x3D;第一轮遍历结束&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;第二轮遍历开始&#x3D;&#x3D;&#x3D;newChildren === cdb，没用完，不需要执行删除旧节点oldFiber === bcd，没用完，不需要执行插入新节点 将剩余 oldFiber（bcd）保存为 map &#x2F;&#x2F; 当前 oldFiber：bcd&#x2F;&#x2F; 当前 newChildren：cdb 继续遍历剩余 newChildren key === c 在 oldFiber 中存在const oldIndex = c（之前）.index;此时 oldIndex === 2; &#x2F;&#x2F; 之前节点为 abcd，所以 c.index &#x3D;&#x3D;&#x3D; 2比较 oldIndex 与 lastPlacedIndex; 如果 oldIndex &gt;= lastPlacedIndex 代表该可复用节点不需要移动并将 lastPlacedIndex = oldIndex;如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动 在例子中，oldIndex 2 &gt; lastPlacedIndex 0，则 lastPlacedIndex = 2;c 节点位置不变 继续遍历剩余 newChildren &#x2F;&#x2F; 当前 oldFiber：bd&#x2F;&#x2F; 当前 newChildren：db key === d 在 oldFiber 中存在const oldIndex = d（之前）.index;oldIndex 3 &gt; lastPlacedIndex 2 &#x2F;&#x2F; 之前节点为 abcd，所以 d.index &#x3D;&#x3D;&#x3D; 3则 lastPlacedIndex = 3;d 节点位置不变 继续遍历剩余 newChildren &#x2F;&#x2F; 当前 oldFiber：b&#x2F;&#x2F; 当前 newChildren：b key === b 在 oldFiber 中存在const oldIndex = b（之前）.index;oldIndex 1 &lt; lastPlacedIndex 3 &#x2F;&#x2F; 之前节点为 abcd，所以 b.index &#x3D;&#x3D;&#x3D; 1则 b 节点需要向右移动&#x3D;&#x3D;&#x3D;第二轮遍历结束&#x3D;&#x3D;&#x3D; 最终 acd 3 个节点都没有移动，b 节点被标记为移动","tags":["学习"]},{"title":"JSDoc remark","path":"/2021/07/13/JSDoc-remark/","content":"Class in ES2015123456789101112131415161718192021222324/** * Class representing a point. */class Point &#123; /** * Create a point. * @param &#123;number&#125; x - The x value. * @param &#123;number&#125; y - The y value. */ constructor(x, y) &#123;&#125; /** * Get the x value. * @return &#123;number&#125; The x value. */ getX() &#123;&#125; /** * Convert a string containing two comma-separated number into a point. * @param &#123;string&#125; str - The string containing two comma-separated number. * @return &#123;Point&#125; A point object. */ static fromStringStr(str) &#123;&#125;&#125; extends123456789101112131415161718192021/** * Class representing a point. * @extends Point */class Dot extends Point &#123; /** * Create a dot. * @param &#123;number&#125; x - The x value. * @param &#123;number&#125; y - The y value. * @param &#123;number&#125; width - The width of the dot. */ constructor(x, y, width) &#123; super(x, y); &#125; /** * Get the width of the dot. * @return &#123;number&#125; The dot&#x27;s width. */ getWidth() &#123;&#125;&#125; @abstract1234567891011121314151617181920212223242526272829/** * Foo. * @constructor */function Foo() &#123;&#125;/** * Check if is solid. * @abstract * @return &#123;boolean&#125; */Foo.prototype.isSolid = function () &#123; throw new Error(&quot;Must be implemented by suclass.&quot;);&#125;;/** * Bar. * @constructor * @arguments Foo */function Bar() &#123;&#125;/** * Check if is solid. * @return &#123;boolean&#125; Always return false. */Bar.prototype.isSolid = function () &#123; return false;&#125;; @assets12345678910111213141516171819202122232425262728/** * @constructor */function Foo() &#123; /** * @assets private * @type &#123;number&#125; */ let foo = 0; /** * @assets protected * @type &#123;string&#125; */ this.bar = &quot;1&quot;; /** * @assets package * @type &#123;string&#125; */ this.barz = &quot;2&quot;; /** * @assets public * @type &#123;string&#125; */ this.barm = &quot;3&quot;;&#125; @author1234/** * @author Edward &lt;wang.huiyang@outlook.com&gt; */function MyClass() &#123;&#125; @callback1234567891011121314151617/** * @class */function Foo() &#123;&#125;/** * Send a request. * @param &#123;requestCallback&#125; cb - The callback than handles the response. */Foo.prototype.send = function (cb) &#123;&#125;;/** * Callback * @callback requestCallback * @param &#123;number&#125; responseCode * @param &#123;string&#125; responseMessage */ @event1234567891011121314151617/** * @constructor */function Foo() &#123;&#125;/** * Do some test. * @fires Foo#test */Foo.prototype.test = function () &#123;&#125;;/** * Foo test. * @event Foo#test * @type &#123;object&#125; * @property &#123;boolean&#125; isPass - Check if is pass. */"},{"title":"ES6 Class","path":"/2021/07/02/ES6-Class/","content":"Class1234567891011// class factoryfunction classFactory(phone) &#123; return class &#123; getName() &#123; return phone; &#125; &#125;;&#125;let _187 = classFactory(&quot;18720128815&quot;);console.log(new _187().getName()); Calculated attribute name1234567class User &#123; [&quot;say&quot; + &quot;Hi&quot;]() &#123; console.log(&quot;hi&quot;); &#125;&#125;new User()[&quot;sayHi&quot;]; Class field12345678// class fieldclass User &#123; name = &quot;Edward&quot;; // is not at the prototype&#125;const user = new User();console.log(user.name); // Edwardconsole.log(User.prototype.name); // undefined Extends — How the super run12345678910111213141516171819202122232425262728293031let animal = &#123; name: &quot;Animal&quot;, eat() &#123; console.log(this.name + &quot; eat&quot;); &#125;,&#125;;let rabbit = &#123; __proto__: animal, // extends animal eat() &#123; super.eat(); &#125;,&#125;;let err = &#123; __proto__: rabbit, // extends rabbit name: &quot;err obj&quot;, eat() &#123; super.eat(); &#125;,&#125;;// super.eat() -&gt; [[Rabbit.prototype]].eat// -&gt; super.eat -&gt; [[Animal.prototype]].eat// this -&gt; errerr.eat();class Animal &#123;&#125;class Rabbit extends Animal &#123;&#125;console.log(Rabbit.__proto__ === Animal); // class extends linkconsole.log(Rabbit.prototype.__proto__ === Animal.prototype); // prototype extends link Prototypechange the basic class 12345678910111213141516let user = &#123; name: &quot;Edward&quot;, hello(name) &#123; console.log(`hi $&#123;this.name&#125;, this is $&#123;name&#125;`); &#125;,&#125;;Function.prototype.defer = function (ms) &#123; let f = this; return function (...arg) &#123; setTimeout(() =&gt; f.apply(this, arg), ms); &#125;;&#125;;user.hello = user.hello.defer(1000);user.hello(&quot;Ejklfj&quot;); // will delay 1000ms Magic of the instance of12345678class Animal &#123; static [Symbol.hasInstance](obj) &#123; if (obj.canEat) return true; &#125;&#125;let obj = &#123; canEat: true &#125;;console.log(obj instanceof Animal); // it will find from the [[Prototype]] Static123456789101112131415161718192021222324class User &#123; static staticMethod() &#123; console.log(this === User); &#125;&#125;class Article &#123; constructor(title, date) &#123; this.title = title; this.date = date; &#125; static compare(articleA, articleB) &#123; return articleA.date - articleB.date; &#125;&#125;let articles = [ new Article(&quot;HTML&quot;, new Date(2019, 1, 1)), new Article(&quot;Css&quot;, new Date(2019, 0, 1)),];articles.sort(Article.compare);console.log(articles);","tags":["学习"]},{"title":"Decorator 装饰器模式","path":"/2021/06/21/Decorator-装饰器模式/","content":"e.g.12345678910111213141516171819202122232425262728293031let worker = &#123; someMethod() &#123; return 1; &#125;, slow(x) &#123; console.log(&quot;called with &quot; + x); return x * this.someMethod(); &#125;,&#125;;function decorator(func) &#123; const cache = new Map(); return function (x) &#123; if (cache.has(x)) &#123; console.log(&quot;cache hit&quot;); return cache.get(x); &#125; const result = func.call(this, x); cache.set(x, result); return result; &#125;;&#125;worker.slow = decorator(worker.slow);console.log(worker.slow(2));console.log(worker.slow(2)); Injection1234567891011121314151617181920function injection(func, ...argsBound) &#123; return function (...args) &#123; return func.call(this, ...argsBound, ...args); &#125;;&#125;// usagelet user = &#123; firstName: &quot;Edward&quot;, say(time, phrase) &#123; console.log(`[$&#123;time&#125;]: $&#123;this.firstName&#125; $&#123;phrase&#125;`); &#125;,&#125;;user.say = injection( user.say, new Date().getHours() + &quot;:&quot; + new Date().getMinutes());user.say(&quot;Hi&quot;); arrow function123456789101112function defer(f, ms) &#123; return function () &#123; setTimeout(() =&gt; f.apply(this, arguments), ms); &#125;;&#125;function sayHello(name) &#123; console.log(`Hi, $&#123;name&#125;`);&#125;const deferSay = defer(sayHello, 2000);deferSay(&quot;Edward&quot;); prototype12345678910111213141516let user = &#123; name: &quot;Edward&quot;, hello(name) &#123; console.log(`hi $&#123;this.name&#125;, this is $&#123;name&#125;`); &#125;,&#125;;Function.prototype.defer = function (ms) &#123; let f = this; return function (...arg) &#123; setTimeout(() =&gt; f.apply(this, arg), ms); &#125;;&#125;;user.hello = user.hello.defer(1000);user.hello(&quot;Ejklfj&quot;);","tags":["整理"],"categories":["ECMAScript"]},{"title":"Binary Indexed Array","path":"/2021/06/19/Binary-Index-Array/","content":"DefinitionA Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. update(index, delta): 将delta加到index位置上。 prefixSum(index): 求 sum[1, index]的值。 rangeSum(from, to): 求 sum[from, to] 的值。 时间复杂度： update(index, delta): 更新需要循环更新每一个parent的值，从index开始到最后一个parent。复杂度为O(n)。 prefixSum(index): 直接返回sum[index + 1]即可，复杂度为O(1)。 rangeSum(from, to): 直接返回sum[to + 1] - sum[from]即可，复杂度为O(1)。 Build现在有个nums初始数组，通过这个数组构造一个BITArray。构造Binary Indexed Array。 实现insert(index, delta): 123456function insert(index, delta) &#123;\twhile (index &lt; this.BITArray.length) &#123; this.BITArray[index] += delta index += (index &amp; -index) // BIT中，parent的index计算方法为：parent = child + (child &amp; -child)\t&#125;&#125; 构造BITArray: 123456function MyArray(nums) &#123;\tthis.BITArray = new Array(nums.length + 1).fill(0)\tfor (let i = 0, len = nums.length; i &lt; len; i++) &#123; this.insert(i + 1, nums[i]) // 在每个index处循环插入，delta就是初始值。\t&#125;&#125; 实现sum(index): 123456789function sum(index) &#123;\tlet sum = 0\twhile (index &gt; 0) &#123; sum += this.BITArray[index] index -= (index &amp; -index) // BIT中，child的计算方法为：child = parent - (parent &amp; -parent)\t&#125;\treturn sum&#125; 实现perfixSum(from, to) 123function perfixSum(from, to) &#123;\treturn this.sum(to + 1) - this.sum(from)&#125;","tags":["算法"]},{"title":"parseInt()的奇幻现象","path":"/2021/06/18/parseInt-的奇幻现象/","content":"parseInt中塞number12parseInt(0.000001) // 0parseInt(0.0000001) // 1 为什么会得到这样的结果？ parseInt(arg: string)：接收的是一个string变量。 0.0000001转成string会变为1e-7。 parseInt(&#39;1e-7&#39;)结果为1。 所以要截取小数，最好还是使用Math.trunc(n)","tags":["整理"]},{"title":"Typescript Enum取key&value","path":"/2021/06/16/Typescript-Enum取key-value/","content":"1234567891011const enum Foo &#123; AA = &#x27;aa&#x27;, BB = &quot;bb&quot;&#125;type B = keyof typeof Foo // &#x27;AA&#x27; | &#x27;BB&#x27;// Template Literal Typestype C = `$&#123;keyof &#123; [x in Foo]: string &#125;&#125;` // &#x27;aa&#x27; | &#x27;bb&#x27;","tags":["整理","学习"]},{"title":"Ubuntu折腾笔记--音频","path":"/2021/06/15/Ubuntu折腾笔记-音频/","content":"缘由公司的PC没有音卡。导致耳机不能播放。 使用pavucontrol输出为模拟信号刚开始总报找不到这个package。换了官方源也没用。后来才发现需要打开开源package安装。。。software &amp; updates &gt; ubuntu software &gt; open-source software","tags":["整理"]},{"title":"2021-05-09","path":"/2021/05/09/2021-05-09/","content":"天下无不散的宴席实习生只剩下一个了，其他都离职了。对他们来说是件好事，呆在这里也不能提高多少。 最近发生的事情太多了： 养了一只猫：某天突然就想养只猫了，下午决定晚上就去领了一只。回家后花了不少精力，现在活得还算不错。 新买了个镜头：入了个35mm f2.0镜头，扫街+人像应该够了。 不知不觉喜欢上了一个女生：深入了解后发现希望不大，还是放弃了。 去了家公司参观：这家公司有Node中间层，是以前未接触过的。今后还需努力。 刷了一点leetcode：在公司需求不多，就刷着为以后做准备了。 买了一点书：身体和心灵总有一个在路上。 去桂山岛旅游：看了看人烟稀少的小镇是什么样的生活。 币圈疯狂的人们数字货币的世界，涨跌不需要理由。公司一群人炒币，只有一个人脱身，其余的加起来估计亏了百来万。地铁上，公交上，餐厅奶茶店；俊男靓女，大爷大妈，所有人都在炒币，太疯狂了。 人的欲望总是无穷的，赌徒只需要输一次就能将所有的钱输完，人性的弱点。大家都希望山底买，山顶卖。但是谁又知道你是不是买在山顶呢。大家都信仰最大傻瓜理论，觉得自己不是那个大傻瓜。 安心生活周末出去走走看看世界看一场电影看几本书与朋友游戏几局平安喜乐就够了 还是决定关闭blog了。太多黑历史，何况还有骂GCD的东西。","tags":["雜談"]},{"title":"Flutter 语法","path":"/2021/01/27/Flutter-语法/","content":"Null-aware operators12345678910String foo = &#x27;a string&#x27;;String bar; // Unassigned objects are null by default.// Substitute an operator that makes &#x27;a string&#x27; be assigned to baz.String baz = foo ?? bar;void updateSomeVars() &#123; // Substitute an operator that makes &#x27;a string&#x27; be assigned to bar. bar ??= &#x27;a string&#x27;;&#125; Conditional property accessmyObject?.someProperty equals to (myObject != null) ? myObject.someProperty : null. 123456// This method should return the uppercase version of `str`// or null if `str` is null.String upperCaseIt(String str) &#123; // Try conditionally accessing the `toUpperCase` method here. return str?.toUpperCase();&#125; CascadesmyObject.someMethod() will get the return value of the someMethod(), myObject..someMethod() will get the reference of the myObject. 12345678910111213141516171819class BigObject &#123; int anInt = 0; String aString = &#x27;&#x27;; List&lt;double&gt; aList = []; bool _done = false; void allDone() &#123; _done = true; &#125;&#125;BigObject fillBigObject(BigObject obj) &#123; // Create a single statement that will update and return obj: return obj ..anInt = 1 ..aString = &quot;String!&quot; ..aList = [3.0] ..allDone();&#125; Optional named parameters12345678910111213141516171819class MyDataObject &#123; final int anInt; final String aString; final double aDouble; MyDataObject(&#123; this.anInt = 1, this.aString = &#x27;Old!&#x27;, this.aDouble = 2.0, &#125;); // Add your copyWith method here: MyDataObject copyWith(&#123;int newInt, String newString, double newDouble&#125;) &#123; return MyDataObject(anInt: newInt ?? this.anInt, aString: newString ?? this.aString, aDouble: newDouble ?? this.aDouble ); &#125;&#125; Initializer lists12345678910class FirstTwoLetters &#123; final String letterOne; final String letterTwo; // Create a constructor with an initializer list here: FirstTwoLetters(String word) : assert(word.length &gt;= 2), letterOne = word[0], letterTwo = word[1] &#123;&#125;&#125; Named constructors12345678910111213class Color &#123; int red; int green; int blue; Color(this.red, this.green, this.blue); Color.black() &#123; red = 0; green = 0; blue = 0; &#125;&#125; Factory constructors1234567891011121314151617181920212223242526272829class IntegerHolder &#123; IntegerHolder(); // Create your factory constructor called &quot;fromList&quot; here. factory IntegerHolder.fromList(List&lt;int&gt; list) &#123; if (list.length == 1) return IntegerSingle(list[0]); if (list.length == 2) return IntegerDouble(list[0], list[1]); if (list.length == 3) return IntegerTriple(list[0], list[1], list[2]); return null; &#125;&#125;class IntegerSingle extends IntegerHolder &#123; final int a; IntegerSingle(this.a);&#125;class IntegerDouble extends IntegerHolder &#123; final int a; final int b; IntegerDouble(this.a, this.b);&#125;class IntegerTriple extends IntegerHolder &#123; final int a; final int b; final int c; IntegerTriple(this.a, this.b, this.c);&#125; Redirecting constructors123456789101112class Color &#123; int red; int green; int blue; Color(this.red, this.green, this.blue); // Create a named constructor called &quot;black&quot; here and redirect it // to call the existing constructor Color.assign(int red, int green, int blue): this(red, green, blue); Color.black(): this.assign(0, 0, 0);&#125; Const constructors1234567class Recipe &#123; final List&lt;String&gt; ingredients; final int calories; final double milligramsOfSodium; const Recipe(this.ingredients, this.calories, this.milligramsOfSodium);&#125;","tags":["学习"]},{"title":"useMemo","path":"/2021/01/13/useMemo/","content":"useMemouseMemo 是拿来保持一个对象引用不变的。useMemo 和 useCallback 都是 React 提供来做性能优化的。比起 classes， Hooks 给了开发者更高的灵活度和自由，但是对开发者要求也更高了，因为 Hooks 使用不恰当很容易导致性能问题。 假设有个 component，在 dataConfig 变化的时候重新去 fetchData： 123456&lt;Child fetchData=&#123;() =&gt; &#123; // fetch data &#125;&#125; dataConfig=&#123;&#123;id: getId(queryId)&#125;&#125;/&gt; 如果是个 Class Component，会这么写： 1234567class Child extends React.Component&lt;Props&gt; &#123; componentWillReceiveProps(nextProps: Props) &#123; if (nextProps.dataConfig !== this.props.dataConfig) &#123; nextProps.fetchData(nextProps.dataConfig) &#125; &#125;&#125; 使用 Hooks 后长这样： 12345const Child = (&#123;fetchData, dataConfig&#125;: Props) =&gt; &#123; useEffect(() =&gt; &#123; fetchData(dataConfig) &#125;, [fetchData, dataConfig])&#125; 使用 Class Component 时我们需要手动管理依赖，但是使用 Hooks 时会带来副作用：React 使用的是Object.is()，如果fetchData的 reference 变了，也会触发 useEffect。虽然逻辑上 React 的处理是合理的，但是还是需要手动去解决它导致的性能问题：官方提供了 useCallback 这个 hooks，用于解决函数引用问题。 12345678910const App = () =&gt; &#123; const fetchData = useCallback( (config: any) =&gt; &#123; queryList(config) &#125;, [queryList], ) return &lt;Child fetchData=&#123;fetchData&#125; dataConfig=&#123;&#123;id: getId(queryId)&#125;&#125; /&gt;&#125; 但是这个时候还有一个地方没有解决——Props。只要 props 更新，组件还是会重新 fetchData，因为 dataConfig 也是一个会变化的 prop。memo 是一个最容易被忽略的 Hooks，即使我们有意不在 JSX 中做计算，写成这样： 12345678910const fetchData = useCallback( (config: any) =&gt; &#123; queryList(config) &#125;, [queryList],)const dataConfig = queryConfig(id)return &lt;Child fetchData=&#123;fetchData&#125; dataConfig=&#123;dataConfig&#125; /&gt; 由于习惯函数式编程，我们已经习惯了这种写法。但是组件是有状态的，状态更新了就得处理相关逻辑，触发 re-render。我们需要告诉 React 什么时候该处理这个状态，这时候 useMemo 就登场了。 12345678910111213const fetchData = useCallback( (config: any) =&gt; &#123; queryList(config) &#125;, [queryList],)const dataConfig = useMemo(() =&gt; (&#123;...config, id: getId(queryId)&#125;), [ getId, queryId,])return &lt;Child fetchData=&#123;fetchData&#125; dataConfig=&#123;dataConfig&#125; /&gt; 这样 dataConfig 只有在 getId 或 queryId 变化时才重新生成，组件才会在必要的时候重新 fetchData memo只使用 useMemo 和 useCallback 来进行优化是有可能达不到效果的，原因在于如果 props 引用不发生变化，虽然不会重新渲染，但它依然会重新执行。 12345678910111213141516171819202122232425const Child = (&#123;name&#125;: Props) =&gt; &#123; console.log(&#x27;run&#x27;) // will log every second // some complex calculations return &lt;div&gt;&#123;name&#125;&lt;/div&gt;&#125;const App = () =&gt; &#123; const [name] = useState(&#x27;foo&#x27;) const [count, setCount] = useState(0) useEffect(() =&gt; &#123; setInterval(() =&gt; &#123; setCount((prev) =&gt; prev + 1) &#125;, 1000) &#125;, []) return ( &lt;div&gt; &lt;div&gt;&#123;count&#125;&lt;/div&gt; &lt;Child name=&#123;name&#125; /&gt; &lt;/div&gt; )&#125; 如果 Child 中的计算量非常大，这时候的性能主要就耗在重新执行的这个过程了。如果想要阻断这一过程重新执行，React 有一个 API：memo，它相当于一个 PureComponent，是一个 HOC，默认对 props 进行一次浅比较，如果 props 不变，则不会重新执行。现在给 Child 套上 memo： 1234567const Child = memo((&#123;name&#125;: Props) =&gt; &#123; console.log(&#x27;run&#x27;) // will log only once // some complex calculations return &lt;div&gt;&#123;name&#125;&lt;/div&gt;&#125;) 或者使用 useMemo 包裹： 12345678910111213141516171819const App = () =&gt; &#123; const [name] = useState(&#x27;foo&#x27;) const [count, setCount] = useState(0) useEffect(() =&gt; &#123; setInterval(() =&gt; &#123; setCount((prev) =&gt; prev + 1) &#125;, 1000) &#125;, []) const memoChild = useMemo(() =&gt; &lt;Child name=&#123;name&#125; /&gt;, [name]) return ( &lt;div&gt; &lt;div&gt;&#123;count&#125;&lt;/div&gt; &#123;memoChild&#125; &lt;/div&gt; )&#125; 何时何处使用？ 开销大的组件可以考虑使用 memo。因为有的组件重新渲染的开销可能比用 memo 做浅比较的开销还小，但是如果组件的重新执行开销很大，使用 memo 一定可以加快性能。 用 useMemo 和 useCallback 来控制 props 的引用，和 memo 配套使用效果最佳。性能优化是一个整体的过程，不是单独在某个组件里就可以改善的。 useMemo 避免昂贵计算，useCallback 解决 reference 问题，memo 解决 shouldComponentUpdate 问题。","tags":["学习"]},{"title":"Waves svg","path":"/2021/01/12/Waves-svg/","content":"","tags":["svg"]},{"title":"useRef","path":"/2021/01/11/useRef/","content":"useRef mutable ref presist eg: 实现一个需求：点击按钮时 input 自动聚焦。 createRef 实现 12345678910111213141516const HomePage = () =&gt; &#123; const input = createRef&lt;HTMLInputElement&gt;() const handle = () =&gt; &#123; if (input.current) &#123; input.current.focus() &#125; &#125; return ( &lt;div&gt; &lt;input ref=&#123;input&#125; /&gt; &lt;button onClick=&#123;handle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125; useRef 实现 12345678910111213141516const HomePage = () =&gt; &#123; const input = useRef&lt;HTMLInputElement | null&gt;(null) const handle = () =&gt; &#123; if (input.current) &#123; input.current.focus() &#125; &#125; return ( &lt;div&gt; &lt;input ref=&#123;input&#125; /&gt; &lt;button onClick=&#123;handle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125; 两者的区别在于：createRef 每次渲染会返回一个新的引用，而 useRef 返回的是相同的引用（persist）。对于函数式组件，每次 useState 会造成整个组件的重新渲染，但是 uesRef 可以保证引用不变，不会触发 re-render。 eg： 12345678910111213141516171819202122const HomePage = () =&gt; &#123; const [index, setIndex] = useState(1) const click = () =&gt; &#123; setTimeout(() =&gt; &#123; /** * 2 * 3 * 4 */ console.log(index) &#125;, 3000) &#125; return ( &lt;div&gt; &lt;span&gt;current: &#123;index&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; setIndex((prev) =&gt; prev + 1)&#125;&gt;increase&lt;/button&gt; &lt;button onClick=&#123;click&#125;&gt;log index&lt;/button&gt; &lt;/div&gt; )&#125; log 出来的并不是实时的 index，每次触发 setState 都会重新渲染，timeout 中拿到的都是当时的 index。使用 useRef 就可以拿到实时更改的结果： 123456789101112131415161718192021222324252627const HomePage = () =&gt; &#123; const [index, setIndex] = useState(1) const ref = useRef&lt;number | null&gt;(null) useEffect(() =&gt; &#123; ref.current = index &#125;) const click = () =&gt; &#123; setTimeout(() =&gt; &#123; /** * 4 * 4 * 4 */ console.log(ref.current) &#125;, 3000) &#125; return ( &lt;div&gt; &lt;span&gt;current: &#123;index&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; setIndex((prev) =&gt; prev + 1)&#125;&gt;increase&lt;/button&gt; &lt;button onClick=&#123;click&#125;&gt;log index&lt;/button&gt; &lt;/div&gt; )&#125; useRef 还可拿到前一个值12345678910111213141516const HomePage = () =&gt; &#123; const [index, setIndex] = useState(1) const ref = useRef&lt;number | null&gt;(null) useEffect(() =&gt; &#123; ref.current = index &#125;) return ( &lt;div&gt; &lt;span&gt;current: &#123;index&#125;&lt;/span&gt; &lt;span&gt;prev: &#123;ref.current&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; setIndex((prev) =&gt; prev + 1)&#125;&gt;increase&lt;/button&gt; &lt;/div&gt; )&#125; React 渲染 JSX 比 useEffect 快，所以已经渲染完成，才给 ref.current 赋值，ref 引用不变，不引起 re-render，所以渲染出来的是上一个值。通过这个特性可以封装一个 usePrevious： 123456789const usePrevious = (value: any) =&gt; &#123; const ref: any = useRef() useEffect(() =&gt; &#123; ref.current = value &#125;, [value]) return ref.current&#125; 还有一个特别的用处，可以用于记录 timer： 123456789const timer = useRef&lt;NodeJS.Timeout | null&gt;(null)useEffect(() =&gt; &#123; timer.current = setInterval(() =&gt; &#123; // do something &#125;, 1000) return () =&gt; clearInterval(timer.current as NodeJS.Timeout)&#125;)","tags":["学习"]},{"title":"State/Effect 分层","path":"/2021/01/10/State-Effect-分层/","content":"友好的 React Hooks网络上对 react hooks 的评价负面大于正面，确实很容易写出性能有问题的代码，关键就在于：我们太喜欢用 useState 了。在 vue-composition-api 中，reactivity 数据都有 wrapper，custom-vca 里不管产生多少个 reactivity 对象，不会直接产生 re-render。只有那些被 return 到外部跟 template 绑定的部分才会触发视图渲染。而 react 的 reactivity 就是通过 re-render 实现的，useState 没有 wrapper，每次使用都会得到一个触发渲染的函数。在这种 reactivity 机制下，就需要特殊的方式编写 hooks —— State&#x2F;Effect 分层 假设有个 useHeight： 1const [ref, height] = useHeight() 高度变化时，被动 re-render，难以转换合并。大部分情况下，不提供 state，而提供 effect 可能会更好： 12345const [height, setHeight] = useState(0)const ref = useHeight((height: number) =&gt; &#123; // do something setHeight(height)&#125;) 使用者在外部声明 state，然后在 callback 中按需 setState。使用者可以结合其他 state，做 dispatch 到 reducer 的一次整体更新，而不是被动 re-render。根据 State&#x2F;Effect 分层理念，尝试着给出友好地 react hooks 公式： 1const handler = useProducer(consumer, options) producer 接收 consumer callback 作为参数，返回 handler 控制函数，用于绑定到事件或其他位置。 React 实现 useHeight给定一个 resizable 的 textarea，我们监听它的高度变化，并展示到文本里。同时给个 checkbox，用户决定是否继续监听。并且只监听一定范围内的尺寸变化。代码实现按照 low-level -&gt; high-level 首先实现一个 useResizeObserver，对 dom api 的 low-level 适配： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123;useCallback, useLayoutEffect, useRef&#125; from &#x27;react&#x27;const useDispatch = &lt;I extends any[], O&gt;(f: (...args: I) =&gt; O): typeof f =&gt; &#123; const dispatchRef = useRef&lt;typeof f&gt;(f) const callback = useCallback&lt;typeof f&gt;((...args) =&gt; &#123; return dispatchRef.current(...args) &#125;, []) useLayoutEffect(() =&gt; &#123; dispatchRef.current = f &#125;, [f]) return callback&#125;export const useResizeObserver = &lt;T extends HTMLElement&gt;( callback: (target: T) =&gt; any,) =&gt; &#123; const ref = useRef&lt;T | null&gt;(null) const observerRef = useRef&lt;ResizeObserver | null&gt;(null) const dispatch = useDispatch(callback) const trigger = (elem: T | null) =&gt; &#123; ref.current = elem if (observerRef.current) &#123; observerRef.current.disconnect() observerRef.current = null &#125; if (!elem) &#123; return &#125; const observer = new ResizeObserver(() =&gt; &#123; dispatch(elem) &#125;) observer.observe(elem) observerRef.current = observer &#125; const enable = () =&gt; &#123; if (ref.current) &#123; observerRef.current?.observe(ref.current) &#125; &#125; const disable = () =&gt; &#123; if (ref.current) &#123; observerRef.current?.unobserve(ref.current) &#125; &#125; return &#123;trigger, enable, disable&#125;&#125; useResizeObserver 不返回 state 出去，而是暴露一个 resize effect。然后再使用 useResizeObserver 实现 useHeight： 1234567891011121314export const useHeight = &lt;T extends HTMLElement&gt;( callback: (height: number) =&gt; any,) =&gt; &#123; const heightRef = useRef&lt;number&gt;(0) const observer = useResizeObserver&lt;T&gt;((target) =&gt; &#123; const height = target.offsetHeight heightRef.current = height callback(height) &#125;) const getCurrentHeight = () =&gt; heightRef.current return &#123;...observer, getCurrentHeight&#125;&#125; 同样的思路还能实现其他监听。最后在页面中使用： 12345678910111213141516171819202122232425262728293031323334export default function App() &#123; const [height, setHeight] = useState(0) const [checked, setChecked] = useState(false) const handler = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123; setChecked(event.target.checked) &#125; const observer = useHeight&lt;HTMLTextAreaElement&gt;((currentHeight) =&gt; &#123; if (currentHeight &gt; 300) &#123; if (currentHeight !== 300) &#123; setHeight(300) &#125; &#125; else &#123; setHeight(currentHeight) &#125; &#125;) useEffect(() =&gt; &#123; if (checked) &#123; observer.enable() &#125; else &#123; observer.disable &#125; &#125;, [checked, observer]) return ( &lt;div&gt; &lt;textarea ref=&#123;observer.trigger&#125; /&gt; &lt;div&gt;height is &#123;height&#125;&lt;/div&gt; &lt;input type=&quot;checkbos&quot; checked=&#123;checked&#125; onChange=&#123;handler&#125; /&gt; &lt;/div&gt; )&#125;","tags":["学习"]},{"title":"TikTok svg","path":"/2021/01/08/TikTok-svg/","content":"","tags":["svg"]},{"title":"Battery svg","path":"/2021/01/05/Battery-svg/","content":"","tags":["svg"]},{"title":"Mix-ins","path":"/2021/01/04/Mix-ins/","content":"Mix-ins Abstract subclasses or mix-ins are templates for classes. An ECMAScript class can only have a single superclass, so multiple inheritance from tooling classes, for example, is not possible. The functionality must be provided by the superclass. eg: 12345678910111213141516171819const calculatorMixin = (Base) =&gt; class extends Base &#123; calc() &#123; // do something &#125; &#125;const randomizerMixin = (Base) =&gt; class extends Base &#123; remdomize() &#123; // do something &#125; &#125;class Foo &#123;&#125;class Bar extends calculatorMixin(randomizerMixin(Foo)) &#123;&#125;const bar = new Bar()console.log(bar.calc)console.log(bar.remdomize) // also a function."},{"title":"2021观影记录","path":"/2021/01/01/2021观影记录/","content":"电影 &#x2611; 沐浴之王：老套路。看完了感觉很无聊。 &#x2611; Dead to 2020：英剧喜剧片。有点意思，照例黑老美。 &#x2611; 十诫：老电影，十分艺术。 &#x2611; Megan Leavey：军人与军犬之间的故事，但是我还是觉得一旦走上了这条路，就很难回归正常生活了。 &#x2610; 邪不压正 &#x2611; 急先锋：很难想象是 2020 年的电影，给我的感觉比不上神话。 &#x2611; Azizler（易舍难分）：拿到了好的题材，拍了一部烂片。 &#x2611; Mosul（血战摩苏尔）：钢枪很热血，剧情挺狗血。 &#x2611; Greenland（末日逃生）：强行拖剧情，很多地方逻辑不通。特效还可以。 &#x2611; 赵子龙：垃圾片。 &#x2611; 送你一朵小红花 &#x2611; 盗梦空间 纪录片 &#x2611; Alien Worlds：根据现有的环境对其他星球进行模拟，幻想存在的物种。最后一集很震撼，随着进化只剩下神经系统，不需要肉体。靠葡萄糖维持生命，高度发达的机器人。","tags":["整理"]},{"title":"macOS打不开非官方dmg文件","path":"/2021/01/01/macOS打不开非官方dmg文件/","content":"直接使用 su 权限移除镜像的 quarantine 标志1sudo xattr -rd com.apple.quarantine /Applications/&lt;application-name&gt;","tags":["整理"]},{"title":"2020总结","path":"/2021/01/01/2020总结/","content":"转眼间就是新的一年了。2020 年，庚子年。发生了许多事情。 新冠 澳洲大火 美股熔断 ··· 在这一年里我也毕业了，入职了，成为了一个打工人士。有了收入之后之前想买的东西都基本买齐了，之前想做的事还在稳步进行中。虽然很多人说 2020 是未来十年中最好的一年，但是在我这还是有可圈可点的地方。大环境的改变，正是抓住机遇的时候。 今年完成的事情 毕业 入职 购买想要的数码产品 补习数学（线性代数、离散） 学习英语 看剧 听歌（QQ 音乐榜单显示全年听了 3700 首） 数字货币（盈利） 基金（亏损） 股票（亏损） 明年预计完成的事情 加薪 独自旅游 学习炒股 学习数学（代数） 深入技术 学习色彩与构图 仰望星空，脚踏实地。在之前的学生生涯中，总是容易对自己的些许成就沾沾自喜。进入了社会后才会发现之前的成就根本不值一提。需要学习的还有很多，在 TypeScript 群里学习了很多新的知识。 新的一年，希望能认识更多优秀的人，学习更多新的知识。","tags":["整理"],"categories":["年终总结"]},{"title":"Clash Service","path":"/2020/12/19/Clash-Service/","content":"config clash.servicefile path: /etc/systemd/system 12345678910111213[Unit]Description=Clash serviceAfter=network.target[Service]Type=simpleUser=edwardExecStart=/usr/bin/clash -d /home/edward/.config/clash &gt;&gt; /home/edward/.config/clash/clash.logRestart=on-failureRestartPreventExitStatus=23[Install]WantedBy=multi-user.target start: systemctl start clash stop: systemctl stop clash enable(start when system start): systemctl enable clash disable: systemctl disable clash status: systemctl status clash"},{"title":"2020/11 總結","path":"/2020/12/07/2020-11-總結/","content":"最近在做的事 去中心化 APP 閱讀”我的簡史” 上月任務 Testing: 需求過多,完成一半 結構優化: Done. TS: 擱置 shell: 擱置 這個月的目標 線性代數 Webpack 去中心化 APP 最近的事 BTC 接近 20000 去道院參觀 補習數學","tags":["雜談"]},{"title":"使用clash進行科學上網","path":"/2020/11/08/使用clash進行科學上網/","content":"之前使用的是 trojan, 奈何找不到好的管理程序, 現使用 clashclash 的 config 使用的是 yaml 文件, 所以比較好寫. 1234567891011121314151617181920212223242526272829303132333435port: 7890socks-port: 7891mixed-port: 7892 # 混合端口allow-lan: true # 允許局域網連接log-level: infoexternal-controller: 127.0.0.1:9090 # 外部控制端口extarnal-ui: dashborad # 使用的uiproxies: # clash官方文檔有更清楚的寫法 - &#123; type: ss, name: &#x27;TEST-SS&#x27;, server: 127.0.0.1, port: 2020, password: 123456, plugin: obfs, plugin-opts: &#123;mode: http&#125;, &#125; # 公司使用的是ss協議 - &#123; type: trojan, name: &#x27;TEST-TROJAN&#x27;, server: 127.0.0.1, port: 443, password: 123456, #sni skip-cert-verify: true, &#125;proxy-groups: - &#123;name: WORK, type: select, proxies: [&#x27;TEST-SS&#x27;]&#125; # 將所需的proxy單獨進行分組 - &#123;name: Proxy, type: select, proxies: [&#x27;TEST-TROJAN&#x27;]&#125;rules: - IP-CIDR, 10.8.0.0/12, WORK # 根據rule將不同的請求轉發到所需的分組去 - IP-CIDR, 172.30.0.0/12, WORK - IP-CIDR, 100.64.0.0/10, DIRECT - IP-CIDR, 127.0.0.0/8, DIRECT - DOMAIN-SUFFIX, google.com, Proxy","tags":["雜談"]},{"title":"2020/10 總結","path":"/2020/11/07/2020-10-總結/","content":"最近的任務量比較多10 月份除開 1-8 只休息了四天, 需求很趕, 代碼質量參差不齊. 上個月的任務 React Hook: 這個月打算將之前的代碼邏輯抽離城自定義 hooks shell: 需求太密已擱置 Linux: 需求太密已擱置 優化 code: 大部分都已經優化掉了, 少數 code 還存在很大問題. 這個月的目標: 補全測試 優化代碼結構, 文件結構 挖掘 Jest 深入用法 重新熟悉 Typescript shell 最近的事 BTC 價格接近 16000 美國大選 追完說唱新世代, 一場三個小時是有夠久的 人生中第一次得蕁麻疹, 查不出病因","tags":["雜談"]},{"title":"使用generator處理無限數據流","path":"/2020/10/07/使用generator處理無限數據流/","content":"Example假設現在有一個數據非常多的數組,但是我們只需要它的前幾個數據,并且進行一定的操作,這時候可以使用 generator 來進行 take 的操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];const from = (arr) =&gt; arr[Symbol.iterator]();const filter = (f) =&gt; function* (iter) &#123; let v = iter.next(); while (!v.done) &#123; if (f(v.value)) yield v.value; v = iter.next(); &#125; &#125;;const multipy = (n) =&gt; function* (iter) &#123; let v = iter.next(); while (!v.done) &#123; yield v.value * n; v = iter.next(); &#125; &#125;;const take = (n) =&gt; function* (iter) &#123; let i = 0; let v = iter.next(); while (!v.done &amp;&amp; i &lt; n) &#123; yield v.value; i++; v = iter.next(); &#125; &#125;;const pipe = (...arr) =&gt; arr.reduce((acc, func) =&gt; func(acc));console.log([ ...pipe( from(arr), filter((v) =&gt; v % 2 === 0), multipy(3), take(30), filter((v) =&gt; v &gt; 15) ),]); // [18, 24, 30, 36]"},{"title":"Transducer","path":"/2020/10/03/Transducer/","content":"ReducerReducer 將多個 input flod 成一個 output. 1234const add = (a, b) =&gt; a + b;const multiply = (a, b) =&gt; a * b;const concatString = (a, b) =&gt; a + b;const concatArray = (a, b) =&gt; [...a, ...b]; TransducerTransducer 做的事情大致相同,但是與普通的 reducer 不同的是,它可以通過多個 function 組合而成.而普通的 reducer 不能組合,因爲他們接受兩個參數,但是只返回一個值,所以不能將這次的結果傳入下一個 reducer: 1234567// reducerf: (a, c) =&gt; a;g: (a, c) =&gt; a;// transducerf: (reducer) =&gt; reducer;g: (reducer) =&gt; reducer; Why Transducers?儅我們處理數據時,將處理過程拆分成相互獨立,然後組合的步驟會非常有用.假設現在有一個非常大的數據集,現在需要對數據集處理某些操作,你可能會這樣做: 12345678910111213const friends = [ &#123; id: 1, name: &quot;Sting&quot;, nearMe: true &#125;, &#123; id: 2, name: &quot;Radiohead&quot;, nearMe: true &#125;, &#123; id: 3, name: &quot;NIN&quot;, nearMe: false &#125;, &#123; id: 4, name: &quot;Echo&quot;, nearMe: true &#125;, &#123; id: 5, name: &quot;Zeppelin&quot;, nearMe: false &#125;,];const isNearMe = (&#123; nearMe &#125;) =&gt; nearMe;const getName = (&#123; name &#125;) =&gt; name;const results = friends.filter(isNearMe).map(getName);console.log(results); // =&gt; [&quot;Sting&quot;, &quot;Radiohead&quot;, &quot;Echo&quot;] 上面的例子存在著一定的問題:只能處理 array;如果存在從網絡上來的無限數據流,該如何處理? 每次在 array 上使用.語法時,JavaScript 都會構造一個全新的 intermediate array,如果你的 array 非常龐大,這時的性能會出現指數級的下降.若使用 transducer,則可以將每個 item 在 pipe 中傳輸,無需建立中間對象,從而節省了大量的時間和内存. Example下面的代碼暫時未實現具體的操作,但是可以先觀察 transducer 是如何構建的. 12345678910111213const friends = [ &#123; id: 1, name: &quot;Sting&quot;, nearMe: true &#125;, &#123; id: 2, name: &quot;Radiohead&quot;, nearMe: true &#125;, &#123; id: 3, name: &quot;NIN&quot;, nearMe: false &#125;, &#123; id: 4, name: &quot;Echo&quot;, nearMe: true &#125;, &#123; id: 5, name: &quot;Zeppelin&quot;, nearMe: false &#125;,];const isNearMe = (&#123; nearMe &#125;) =&gt; nearMe;const getName = (&#123; name &#125;) =&gt; name;const getFriendsNearMe = compose(filter(isNearMe), map(getName));const results2 = toArray(getFriendsNearMe, friends); Transducer 在需要使用並給它傳遞數據時才會執行,也就是上述代碼的toArray()部分,你可以自己實現 transducer 的轉換結果.Transducer 可以映射各種類型,例如 &#123;x, y, z&#125; -&gt; &#123;x, y, z&#125; &#123;x, y ,z&#125; -&gt; &#123;x, z&#125; &#123;x, y, z&#125; -&gt; &#123;x, y, z, xx, yy, zz&#125; 假設我們現在需要讓一個 array 中的數字翻倍,我們可以這麽實現: 1234const double = (x) =&gt; x * 2;const arr = [1, 2, 3];const result = arr.map(double); 在上述例子中,arr 是一個可枚舉對象,map 將每個對象單獨進行 double 處理,然後將所有的值纍加到新的 array 中.我們還可以實現新的效果: 1234567const isEven = (x) =&gt; x % 2 === 0;const double = (x) =&gt; x * 2;const arr = [1, 2, 3, 4, 5, 6];const result = arr.filter(isEven).map(double);console.log(result); 但是,處理無限數據流時會發生什麽?數組是不能無限長的,在數組的處理中,你必須將整個迭代成一個集合,才能進行下一步的處理.這種限制就會導致性能降低,因爲需要創建一個中間數組,并且為每個操作迭代一次新的集合.就用上述的例子來説,首先有一個過濾單數的操作,然後有一個倍增的操作.必須先在過濾操作中將所有的元素進行過濾,然後再在 double 中執行所有的元素,才能夠拿到你想要的數據.一種處理方法是將每個值單獨映射,一次通過一個值,這樣就避免了每次生成一個映射集合,并且隨時能夠通過值來發出終止信號: Pull: lazy evaluation: 直到用戶要求取下一個值時,才會拿出下一個值.如Iterable. Push: eager evaluation: 每次拿出一個值,然後傳入 reducer 中,生成新值.如Array.reduce() Transducer 不關心你使用的是哪種方式,也不關心數據的具體結構,他們只是簡單的調用傳入的 reducer 並纍加新值.實際上就是一個 Higher Order Reducer,它的類型大致為: 12reducer = (accumulator, current) =&gt; accumulator;transducer = (reducer) =&gt; reducer; 大多數 transducer 需要使用一定的參數以實現特定的功能,所以一個 map transducer 也許類型為這樣: 1234map = (transform) =&gt; (reducer) =&gt; reducer;// another waymap = ((a) =&gt; b) =&gt; (step) =&gt; reducer; map 接受一個 mapping function(transform),一個 reducer(step)然後返回一個新的 reducer.現在來看一些簡單的例子. Naive Examples12345678910111213const compose = (...fns) =&gt; (x) =&gt; fns.reduceRight((y, f) =&gt; f(y), x);const map = (f) =&gt; (step) =&gt; (a, c) =&gt; step(a, f(c));const filter = (predicate) =&gt; (step) =&gt; (a, c) =&gt; predicate(c) ? step(a, c) : a;const isEven = (n) =&gt; n % 2 === 0;const double = (n) =&gt; n * 2;const doubleEvens = compose(filter(isEven), map(double)); // also a transducerconst arrayConcat = (a, c) =&gt; a.concat([c]); // stepconst xform = doubleEvens(arrayConcat); // a reducerconst result = [1, 2, 3, 4, 5, 6].reduce(xform, []); // [4, 8, 12] 在這個例子中,map 就是一個 transducer,你還能這樣使用: 123456const double = (x) =&gt; x * 2;const doubleMap = map(double); // double is a transformconst step = (a, c) =&gt; console.log(c);doubleMap(step)(0, 4); // 8doubleMap(step)(0, 21); // 42 其中,0 代表 reducer 的初始值,step 函數本該是一個 reducer,但是方便演示就將他寫成一個 logger.這種技巧也可以在單元測試中作斷言使用.","tags":["学习"]},{"title":"Blog集成到CI","path":"/2020/10/01/Blog集成到CI/","content":"閑著無聊看了看如何部署公司内部有 k8s 集群,所以也需要學習如何寫 deploy 脚本.目前服務挂在 Travis CI 上,後續可能會使用自己的機器裝個 Github Runner 啥的… 步驟大致為: 在 Travis 中登錄,然後選擇需要 watch 的倉庫 編寫 deploy 文件,需要内部暴露字段的可以在 setting 中添加 在 github 中拿到 person access token,添加到 Travis 因爲 blog 還不需要 build 和 test 的步驟,所以我的 deploy file 暫時還沒有這些: 1234567891011121314151617181920212223242526272829303132333435language: node_jsnode_js: - 10 # hexo目前似乎還不支持node 14版本branches: only: - master # 需要監聽的branchbefore_install: - npm install -g hexo-cliinstall: - npm install - npm install hexo-deployer-gitbefore_script: - git config user.name &quot;$&#123;username&#125;&quot; - git config user.email &quot;$&#123;email&#125;&quot; - rm -rf themes/next - git clone https://github.com/theme-next/hexo-theme-next themes/next - cp assets/config/_config.yml themes/next/_config.yml # 我將自己的theme config存在assets中 - cp assets/images/avatar.jpg themes/next/source/images/avatar.jpg - sed -i &quot;s/github_token/$&#123;GITHUB_TOKEN&#125;/g&quot; _config.ymlscript: - hexo clean - hexo generate - echo &quot;Generation finished.&quot; - hexo deploynotifications: email: - foo@example.com on_success: change on_failure: always October Plan React Hook: 首要完成的目標 shell: 不知道能學到什麽程度 Linux 命令: 不知道能學到什麽程度 優化之前的 code: 算是屎山了 September Harvest Test Driven Development: 業務需求太多,暫時還是需求開發 State Management: 還不熟練 Null Value Judgment: 後端新使用的框架,如果字段值為0或者&#39;&#39;,返回的 data 裏直接沒這個字段了(XD),所以很多地方都新增了判空處理 Left Questions Mobx 包裹的對象無法 log React Native 難以 debug 移動端難以 testing","tags":["雜談"]},{"title":"Alibaba Cloud","path":"/2020/09/14/Alibaba-Cloud/","content":"買了個阿里雲服務有點太貴了。隨便跑點什麽Memory就100%。 時常掉綫，不知道是不是網絡的問題。拿到公司Network環境一樣掉綫。 想搭個Gatsby玩玩，還是用自己的電腦吧。","tags":["雜談"]},{"title":"一點總結","path":"/2020/09/11/一點總結/","content":"工作以來的感受最大的感受就是，需要學習的還有很多很多。獨立思考可以讓你的思維更加開放、活躍，同時可以激發更多的靈感。目前的技術棧：React+Mobx+TypeScirpt 從前對狀態管理沒有什麽概念，自從接觸到工程項目之後，對爲何要進行State Management越來越清晰。當然也產生了一定的不良影響 -&gt; 只要上手就會想如何設計State，導致有的地方代碼實在冗餘。 同時在項目代碼中瞭解了許多新知識，如何去設計一個可繼承、可復用的Function；如何將Store封裝，便於使用；如何對請求進行封裝；何時使用Interface、何時使用Type；等等…… 接下來需要做的 思考之前的代碼如何優化 思考目前的代碼是否還能拆分 閲讀State Management的文章 …… 課餘時間的活動 書籍 熵的世界 我的簡史 - 霍金 日常 陰陽師 B站 手游 - 跑跑卡丁車 音樂 綜藝 説唱新世代 中國新説唱 影視劇 甜蜜蜜 投名狀 親愛的 八佰 Mulan 信條 挖坑考慮用點什麽搭一個自己的博客。","tags":["雜談"]},{"title":"Higher Order Components","path":"/2020/08/11/Higher-Order-Components/","content":"使用HOC进行代码复用假设存在下面两个组件： 12345678910111213141516171819202122232425262728293031import React from &#x27;react&#x27;class ButtonCounter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; increase = () =&gt; &#123; let &#123; step &#125; = this.props this.setState((pre) =&gt; &#123; return &#123; count: pre.count + step &#125; &#125;) &#125; render() &#123; let &#123; count &#125; = this.state return( &lt;button onClick=&#123;this.increase&#125;&gt;click &#123;count&#125; times&lt;/button&gt; ) &#125;&#125;export default ButtonCounter 12345678910111213141516171819202122232425262728293031import React from &#x27;react&#x27;class ButtonCounter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; increase = () =&gt; &#123; let &#123; step &#125; = this.props this.setState((pre) =&gt; &#123; return &#123; count: pre.count + step &#125; &#125;) &#125; render() &#123; let &#123; count &#125; = this.state return( &lt;div onMouseLeave=&#123;this.increase&#125;&gt;click &#123;count&#125; times&lt;/div&gt; ) &#125;&#125;export default ButtonCounter 使用HOC进行改造HOC通过传入的组件，返回一个新的组件。 12345678910111213import React from &#x27;react&#x27;const withCounter = (OriginalComponent) =&gt; &#123; class newComponent extends React.Component &#123; render() &#123; return &lt;OriginalComponent /&gt; &#125; &#125; return newComponent&#125;export default withCounter 将counter中的方法放到HOC中1234567891011121314151617181920212223242526272829303132333435import React from &#x27;react&#x27;const withCounter = (OriginalComponent, step) =&gt; &#123; // 将step从props中抽离出来 class newComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; increase = () =&gt; &#123; this.setState((pre) =&gt; &#123; return &#123; count: pre.count + step &#125; &#125;) &#125; render() &#123; let &#123; count &#125; = this.state return &lt;OriginalComponent increase=&#123;this.increase&#125; count=&#123;count&#125; &#123;...this.props&#125; /&gt; &#125; &#125; return newComponent&#125;export default withCounter 123456789101112131415import React from &#x27;react&#x27;import withCounter from &#x27;../util/withCounter&#x27;class ButtonCounter extends React.Component &#123; render() &#123; let &#123; increase, count &#125; = this.props return( &lt;button onClick=&#123;increase&#125;&gt;click &#123;count&#125; times&lt;/button&gt; ) &#125;&#125;export default withCounter(ButtonCounter, 2)"},{"title":"防抖与节流","path":"/2020/07/30/防抖与节流/","content":"防抖浏览器中有的事件触发非常频繁，如果在事件触发的时候就调用，这时就会不断地产生新的调用，导致变‘卡’。防抖就是在某段时间间隔内，不调用函数，直到一段时间后不在再新的事件触发，再调用函数；或者是先调用函数，在一段时间间隔内继续触发不再重复调用函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let times = 0;let container = document.querySelector(&quot;#container&quot;);let button = document.querySelector(&quot;#cancel&quot;);function getUserAction() &#123; // do some thing container.innerHTML = `run $&#123;++times&#125; time(s).`;&#125;/** * * @param &#123;function(): *&#125; func * @param &#123;number&#125; wait * @param &#123;boolean&#125; immediate * @returns &#123;function(): *&#125; */function debounce(func, wait, immediate) &#123; let timer; // start a new timer every time it is triggered let result; // get the return from func | undefined(only if the immediate is true will return a value) let debounced = function () &#123; let context = this; // current context let args = arguments; // events if (timer) &#123; clearTimeout(timer); &#125; if (immediate) &#123; // check whether it is called immediately let callNow = !timer; // callNow is always false unless the timer is null timer = setTimeout(() =&gt; &#123; timer = null; // set the timer null after wait time &#125;, wait); if (callNow) &#123; // means timer is null now, then call func result = func.apply(context, args); &#125; &#125; else &#123; timer = setTimeout(() =&gt; &#123; // 1. bind the `this` to `&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;` // 2. get the `event` func.apply(context, args); &#125;, wait); &#125; return result; &#125;; debounced.cancel = function () &#123; // to cancel the debounce clearTimeout(timer); timer = null; // reset to null &#125;; return debounced;&#125;let userAction = debounce(getUserAction, 5000, true); // get the function `debounced`container.onmousemove = userAction;button.onclick = function () &#123; userAction.cancel();&#125;; 节流如果持续触发事件，那么每固定时间内只触发一次事件。实现方式可以使用时间戳，或者定时器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let times = 0;let container = document.querySelector(&quot;#container&quot;);let button = document.querySelector(&quot;#cancel&quot;);function getUserAction() &#123; // do some thing container.innerHTML = `run $&#123;++times&#125; time(s).`;&#125;function throttle( func, wait, options = &#123; leading: true, // run immediately trailing: true, // run after wait time &#125;) &#123; let timer; let context; let args; let previous = 0; let later = function () &#123; previous = !options.leading ? 0 : new Date().getTime(); timer = null; func.apply(context, args); context = args = null; &#125;; let throttled = function () &#123; let now = new Date().getTime(); if (!previous &amp;&amp; !options.leading) previous = now; let remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timer) &#123; clearTimeout(timer); timer = null; &#125; previous = now; func.apply(context, args); if (!timer) context = args = null; &#125; else if (!timer &amp;&amp; options.trailing) &#123; timer = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function () &#123; clearTimeout(timer); previous = 0; timer = null; &#125;; return throttled;&#125;let userAction = throttle(getUserAction, 5000, &#123; leading: true, trailing: false,&#125;);// let userAction = throttle(getUserAction, 5000, &#123;leading: false, trailing: true&#125;)container.onmousemove = userAction;button.onclick = userAction.cancel;"},{"title":"创建对象的多种方式","path":"/2020/07/29/创建对象的多种方式/","content":"Factory缺点：对象无法区分，所有的实例指向一个原型 12345678910111213function Person(name) &#123; let o = new Object() o.name = name o.getName = function () &#123; return this.name &#125; return o&#125;let person = new Person(&#x27;Edward&#x27;)console.log(person instanceof Person) // falseconsole.log(person instanceof Object) // true Constructor缺点：每次创建实例时，每个方法需要被创建一次。 123456function Person(name) &#123; this.name = name this.getName = function () &#123; // create function return this.name &#125;&#125; Prototype缺点： 所有的属性和方法都共享 不能初始化值 12345678function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: &#x27;Edward&#x27;, getName: function () &#123; return this.name &#125;&#125; Constructor &amp; Prototype12345678910function Person(name) &#123; this.name = name&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; return this.name &#125;&#125; Safe constructor没有公共属性，方法也不使用this对象，无法识别对象所属类型。 1234567891011121314function Person(name) &#123; let o = new Object() o.name = name o.getName = function () &#123; return name // formal parameter &#125; return o&#125;let person = new Person(&#x27;Edward&#x27;)console.log(person.getName()) // Edwardperson.name = &#x27;Jack&#x27;console.log(person.getName()) // also Edward"},{"title":"词法作用域与动态作用域","path":"/2020/07/28/词法作用域与动态作用域/","content":"JavaScript采用的是词法作用域（lexical scoping）JavaScript函数的作用域在函数定义的时候就确定了，所以实际使用的值与函数定义位置有关系。 123456789101112let value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; let value = 2 foo()&#125;bar() // 1 上面这个例子中，foo函数中的value向上寻找为在全局定义的1，所以会打印出1。 1234567891011value=1function foo()&#123; echo $value&#125;function bar() &#123; local value=2 foo&#125;bar #2 而在bash中，由于是动态作用域，所以会打印出2。 一个例子输出的都会是local。 1234567891011let text = &#x27;global&#x27;let foo = () =&gt; &#123; let text = &#x27;local&#x27; let f = () =&gt; text return f() // return f&#125;console.log(foo()) // local// console.log(foo()()) // local"},{"title":"RegExp断言","path":"/2020/07/24/RegExp断言/","content":"先行断言 lookahead assertion：x在y之前才匹配，格式为/x(?=y)/ negative lookahead assertion：只有x不在y之前才匹配，格式为/x(?!y)/ 1234let str = &#x27;now is 02:11:44&#x27;/\\d+(?=:)/.exec(str) // [&#x27;02&#x27;]/\\d+(?!\\.)/.exec(str) // [&#x27;0&#x27;] 后行断言 lookbehind assertion：x只有在y后面才匹配，格式为/(?&lt;=y)x/ negative lookbehind assertion：只有x不在y后面才匹配，格式为/(?&lt;!y)x/ 1234let str = &#x27;now is 02:11:44&#x27;/(?&lt;=:)\\d+/.exec(str) // [&#x27;11&#x27;]/(?&lt;!:)\\d+/.exec(str) // [&#x27;02&#x27;]","categories":["ECMAScript"]},{"title":"ECMAScript新增String方法","path":"/2020/07/24/ECMAScript新增String方法/","content":"ES2017新增padStart(), padEnd()字符串补全功能，接受两个参数，如果第二个参数为空，则默认使用空格补全。 123456// fill with the template&#x27;12&#x27;.padStart(3, &#x27;000&#x27;) // &#x27;012&#x27;&#x27;12&#x27;.padEnd(3, &#x27;000&#x27;) // &#x27;120&#x27;// fill with space&#x27;12&#x27;.padStart(4) // &#x27; 12&#x27; ES2019新增trimStart(), trimEnd()与String.trim()的行为一致，不会修改原字符串。 1234567let str = &#x27; string &#x27;// str.trimLeft()str.trimStart() // &#x27;string &#x27;// str.trimRight()str.trimEnd() // &#x27; string&#x27;","tags":["整理"],"categories":["ECMAScript"]},{"title":"绘制不同颜色","path":"/2020/06/22/WebGL绘制不同颜色/","content":"绘制过程 执行Vertex Shader，配置顶点。 调用gl.drawArrays()，装配图形。 光栅化，将图形转换为Fragment。 执行Fragment Shader。 代码实现使用varying标识符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const vShaderSource = ` attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; void main() &#123; gl_Position = a_Position; gl_PointSize = 10.0; v_Color = a_Color; &#125;`;const fShaderSource = ` precision mediump float; varying vec4 v_Color; void main() &#123; gl_FragColor = v_Color; &#125;`;const main = () =&gt; &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) return; let n = initVertexBuffers(gl); if (n &lt; 0) return; gl.clearColor(0, 0, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT); // gl.drawArrays(gl.LINE_LOOP, 0, n); gl.drawArrays(gl.TRIANGLES, 0, n);&#125;;const initVertexBuffers = (gl) =&gt; &#123; let verticesColor = new Float32Array([ // [x, y, r, g, b] 0, 0.5, 1, 0, 0, -0.5, -0.5, 0, 1, 0, 0.5, -0.5, 0, 0, 1 ]); let n = 3; let vertexColorBuffer = gl.createBuffer(); if (!vertexColorBuffer) return -1; gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColor, gl.STATIC_DRAW); const SIZE = verticesColor.BYTES_PER_ELEMENT; let a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;); let a_Color = gl.getAttribLocation(gl.program, &#x27;a_Color&#x27;); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, SIZE * 5, 0); gl.enableVertexAttribArray(a_Position); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, SIZE * 5, SIZE * 2); gl.enableVertexAttribArray(a_Color); return n;&#125;;","tags":["学习"],"categories":["WebGL"]},{"title":"制作动画","path":"/2020/06/20/WebGL制作动画/","content":"绘制流程 计算变换后的位置坐标。 清空画板。 绘制 循环1-3操作。 代码实现使用库函数简化数学计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_ModelMatrix; void main() &#123; gl_Position = u_ModelMatrix * a_Position; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); &#125;`;const main = () =&gt; &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn; let n = initVertexBuffers(gl); if (n &lt; 0) return; gl.clearColor(0, 0, 0, 1); rotating(gl, n, 360);&#125;const rotating = (gl, n, ANGLE_STEP = 30) =&gt; &#123; let currentAngle = 0; let modelMatrix = new Matrix4(); let u_ModelMatrix = gl.getUniformLocation(gl.program, &#x27;u_ModelMatrix&#x27;); let tick = function () &#123; currentAngle = animate(currentAngle, ANGLE_STEP); draw(gl, n, currentAngle, modelMatrix, u_ModelMatrix); requestAnimationFrame(tick); &#125; tick();&#125;const draw = (gl, n, currentAngle, modelMatrix, u_ModelMatrix) =&gt; &#123; modelMatrix.setRotate(currentAngle, 0, 0, 1); // Set rotation matrix. // modelMatrix.translate(0.5, 0, 0); gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); gl.clear(gl.COLOR_BUFFER_BIT); // Clear canvas. gl.drawArrays(gl.TRIANGLES, 0, n); // Draw triangle.&#125;let g_last = Date.now();/** * Get the new angle. * @param currentAngle &#123;number&#125; * @param ANGLE_STEP &#123;number&#125; * @returns &#123;number&#125; */const animate = (currentAngle, ANGLE_STEP) =&gt; &#123; let now = Date.now(); let temp = now - g_last; g_last = now; return (currentAngle + (ANGLE_STEP * temp) / 1000) % 360;&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"使用矩阵进行变换","path":"/2020/06/19/WebGL使用矩阵进行变换/","content":"WebGL中的矩阵是列主序的。 平移变换123456789101112131415161718192021222324252627282930313233343536373839const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_xFormMatrix; void main() &#123; gl_Position = u_xFormMatrix * a_Position; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;const Tx = 0.5, Ty = 0.2, Tz = 0;function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn; let n = initVertexBuffers(gl); if (n &lt; 0) return; let xFormMatrix = new Float32Array([ 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, Tx, Ty, Tz, 1.0 ]) let u_xFormMatrix = gl.getUniformLocation(gl.program, &#x27;u_xFormMatrix&#x27;); gl.uniformMatrix4fv(u_xFormMatrix, false, xFormMatrix); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);&#125; 旋转变换1234567891011121314151617181920212223242526272829303132333435363738394041const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_xFormMatrix; void main() &#123; gl_Position = u_xFormMatrix * a_Position; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;const ANGLE = 30;function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn; let n = initVertexBuffers(gl); if (n &lt; 0) return; let radian = Math.PI * ANGLE / 180.0; let sinB = Math.sin(radian), cosB = Math.cos(radian); let xFormMatrix = new Float32Array([ // column major order cosB, sinB, 0, 0, -sinB, cosB, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]); let u_xFormMatrix = gl.getUniformLocation(gl.program, &#x27;u_xFormMatrix&#x27;); gl.uniformMatrix4fv(u_xFormMatrix, false, xFormMatrix); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);&#125; 缩放变换缩放矩阵：$$\\begin{bmatrix} x’ \\ y’ \\ z’ \\ 1 \\\\end{bmatrix} &#x3D;\\begin{bmatrix} Sx &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; Sy &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; Sz &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix} ×\\begin{bmatrix} x \\ y \\ z \\ 1 \\\\end{bmatrix}$$ 123456789101112131415161718192021222324252627282930313233343536373839const vShaderSource = ` attribute vec4 a_Position; uniform mat4 u_xFormMatrix; void main() &#123; gl_Position = u_xFormMatrix * a_Position; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;const Sx = 1.0, Sy = 1.5, Sz = 1.0;function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) reutrn; let n = initVertexBuffers(gl); if (n &lt; 0) return; let xFormMatrix = new Float32Array([ Sx, 0, 0, 0, 0, Sy, 0, 0, 0, 0, Sz, 0, 0, 0, 0, 1 ]); let u_xFormMatrix = gl.getUniformLocation(gl.program, &#x27;u_xFormMatrix&#x27;); gl.uniformMatrix4fv(u_xFormMatrix, false, xFormMatrix); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"图像旋转","path":"/2020/06/19/WebGL图像旋转/","content":"旋转原理将WebGL坐标系转为极坐标，然后通过角度计算得出旋转后的左标位置。旋转矩阵：$$\\begin{bmatrix} x’ \\ y’ \\ z’ \\ 1 \\\\end{bmatrix} &#x3D;\\begin{bmatrix} \\cos \\beta &amp; -\\sin \\beta &amp; 0 &amp; 0 \\ \\sin \\beta &amp; \\cos \\beta &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix} ×\\begin{bmatrix} x \\ y \\ z \\ 1 \\\\end{bmatrix}$$ 代码实现使用u_SinBCosB存放SinB与CosB。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 2d rotate * x&#x27; = x * cosB - y * sinB * y&#x27; = x * sinB + y * cosB * z&#x27; = z */const vShaderSource = ` attribute vec4 a_Position; uniform vec2 u_SinBCosB; void main() &#123; gl_Position.x = a_Position.x * u_SinBCosB.y - a_Position.y * u_SinBCosB.x; gl_Position.y = a_Position.x * u_SinBCosB.x + a_Position.y * u_SinBCosB.y; gl_Position.z = a_Position.z; gl_Position.w = 1.0; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;let ANGLE = 30.0;function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) return; let n = initVertexBuffers(gl); if (n &lt; 0) return; let radian = Math.PI * ANGLE / 180.0; // Transform to radian. let SinB = Math.sin(radian); let CosB = Math.cos(radian); let u_SinBCosB = gl.getUniformLocation(gl.program, &#x27;u_SinBCosB&#x27;); gl.uniform2f(u_SinBCosB, SinB, CosB); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"图像位移","path":"/2020/06/18/WebGL图像位移/","content":"位移原理与在普通的坐标系中一样，只需在需要位移的坐标位置加入相应的矢量即可。(x1, y1, z1, w1) + (x2, y2, z2, w2) -&gt; (x1 + x2, y1 + y2, z1 + z2, w1 + w2)平移矩阵：$$\\begin{bmatrix} x’ \\ y’ \\ z’ \\ 1\\end{bmatrix} &#x3D;\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; Tx \\ 0 &amp; 1 &amp; 0 &amp; Ty \\ 0 &amp; 0 &amp; 1 &amp; Tz \\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\end{bmatrix} ×\\begin{bmatrix} x \\ y \\ z \\ 1 \\\\end{bmatrix}$$ 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// position = P + ▲Pconst vShaderSource = ` attribute vec4 a_Position; uniform vec4 u_Translation; void main() &#123; gl_Position = a_Position + u_Translation; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;// Displacementconst Tx = 0.4, Ty = -0.2, Tz = 0.3; Tw = 0.0;function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) return; let n = initVertexBuffers(gl); if (n &lt; 0) return; let u_Translation = gl.getUniformLocation(gl.program, &#x27;u_Translation&#x27;); gl.uniform4f(u_Translation, Tx, Ty, Tz, Tw); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, n);&#125;function initVertexBuffers(gl) &#123; let vertices = new Float32Array([ 0.0, 0.5, -0.5, -0.5, 0.5, -0.5, ]); let n = vertices.length / 2; let vertexBuffer = gl.createBuffer(); if (!vertexBuffer) &#123; console.log(&#x27;failed to create buffer&#x27;); return -1; &#125; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); let a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;); gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); return n;&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"绘制多个点","path":"/2020/06/18/WebGL绘制多个点/","content":"绘制步骤 创建顶点数组。 创建一个Buffer。 将WebGL的ARRAY_BUFFER指向所创建的Buffer。 将顶点数组赋值到Buffer中。 将Buffer分配给Vertex Shader中的Attribute。 让Vertex Shader访问Buffer。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const vShaderSource = ` attribute vec4 a_Position; void main() &#123; gl_Position = a_Position; gl_PointSize = 5.0; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;function main() &#123; const gl = document.querySelector(&#x27;#canvas&#x27;).getContext(&#x27;webgl&#x27;); if (!initShaders(gl, vShaderSource, fShaderSource)) &#123; return; &#125; let n = initVertexBuffers(gl); if (n &lt; 0) &#123; console.log(&#x27;failed to set positions&#x27;); return; &#125; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.POINTS, 0, n); // (type, first, count = n)&#125;function initVertexBuffers(gl) &#123; let vertices = new Float32Array([ // Create points array. 0.0, 0.5, -0.5, -0.5, 0.5, -0.5, ]); let n = vertices.length / 2; // Compute the n. let vertexBuffer = gl.createBuffer(); // Create buffer. if (!vertexBuffer) &#123; console.log(&#x27;failed to create buffer&#x27;); return -1; &#125; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); // Bind buffer. gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); // Draw data into buffer. let a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;); // size = 2 because of the [x, y] components gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); // Set data into &#x27;a_Position&#x27;. gl.enableVertexAttribArray(a_Position); // Link attribute and Buffer. return n;&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"绘制点","path":"/2020/06/17/绘点/","content":"ShaderWebGL使用两种Shader： Vertex Shader：用于描述point的特性。 Fragment Shader：用于逐片处理。 Shader Program使用的是GLSL ES语言，在JS中需要使用字符串编写，再通过函数加载进去。 WebGL的执行流程大致为： Get canvas. Get WebGL context. Initialize vertex shader and fragment shader. Set clear color. Clear canvas. Draw. vec4在GLSL ES中，vec4类型用四维适量描述一个点的三维空间投影，(x, y, z, w)等价与三维空间的(x / w, y / w, z / w)。WebGL坐标系统水平向右为x正轴，竖直向上为y正轴，垂直屏幕向外为z正轴。范围都在[-1, 1]之间。 使用onmousedown搭配WebGL进行图像绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const vShaderSource = ` attribute vec4 a_Position; attribute float a_PointSize; void main() &#123; gl_Position = a_Position; gl_PointSize = a_PointSize; &#125;`;const fShaderSource = ` void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); &#125;`;function main() &#123; const canvas = document.querySelector(&#x27;#canvas&#x27;); const gl = canvas.getContext(&#x27;webgl&#x27;); if (!gl) &#123; console.log(&#x27;failed to initialize context for WebGL&#x27;); return; &#125; if (!initShaders(gl, vShaderSource, fShaderSource)) &#123; // initialize program console.log(&#x27;failed to initialize shaders.&#x27;); return; &#125; const a_Position = gl.getAttribLocation(gl.program, &#x27;a_Position&#x27;); if (a_Position &lt; 0) &#123; console.log(&#x27;failed to get the storage location of a_Position&#x27;); return; &#125; const a_PointSize = gl.getAttribLocation(gl.program, &#x27;a_PointSize&#x27;); gl.vertexAttrib1f(a_PointSize, 5.0); // set the &#x27;attribute float a_PointSize&#x27; // canvas.onmousemove = function (event) &#123; canvas.onmousedown = function (event) &#123; click(event, gl, canvas, a_Position); &#125; gl.clearColor(0.0, 0.0, 0.0, 1); gl.clear(gl.COLOR_BUFFER_BIT);&#125;let g_points = [];function click(event, gl, canvas, a_Position) &#123; let x = event.clientX; let y = event.clientY; let rect = event.target.getBoundingClientRect(); // toggle the domain of points x, y to [-1, 1] x = ((x - rect.left) - canvas.width / 2) / (canvas.width / 2); y = (canvas.height / 2 - (y - rect.top)) / (canvas.height / 2); g_points.push(x); g_points.push(y); gl.clear(gl.COLOR_BUFFER_BIT); for (let i = 0, len = g_points.length; i &lt; len; i += 2) &#123; gl.vertexAttrib3f(a_Position, g_points[i], g_points[i + 1], 0); // set x, y gl.drawArrays(gl.POINTS, 0, 1); &#125;&#125;","tags":["学习"],"categories":["WebGL"]},{"title":"美股再次熔断","path":"/2020/03/13/美股再次熔断/","content":"开盘受挫 开盘后，标普500指数跌幅扩大至7%，触发本周第二次熔断，美股暂停交易15分钟。而加拿大多伦多证交所暂停股票交易，股指跌9.17%，触发一级市场熔断。 恢复交易后，三大指数进一步下跌，道指一度下挫2100点。波音下跌15.4%，仅仅一个月时间，市值腰斩。巴里克黄金10.2%，特斯拉跌9.4%。美股邮轮股大跌，挪威邮轮跌超30%，皇家加勒比邮轮跌超25%。 今天，美股期货连续出现熔断，早间，纳斯达克指数期货就跌至7600点触发熔断，跌幅超5%。下午标普500指数期货跌超5%，也触发交易限制。 今日，标普500期货、道指期货、纳指期货均跌超5%，再度触发熔断。据不完全统计，除了美股期指外，日内还有泰国股市、菲律宾股市、韩国股市、巴基斯坦股市、印尼股市、巴西股市，加拿大股市8个国家股市发生熔断。巴西股市触发二级熔断 欧洲央行维持三大关键利率不变欧洲央行公布3月会议的利率决议，其中，欧洲央行是否会追随美联储和英国央行的步伐进行降息成为最大看点，今日，欧洲央行宣布，维持三大关键利率不变，其中，维持基准利率在0.000%不变，将存款利率维持在-0.500%不变。此前市场预期降息10个基点。 比特币跌破5000,24h涨幅-40%北京时间13&#x2F;03&#x2F;2020 7:30am，BTC跌破5000美元。短线来看BTC的避险属性几乎为零。 比特币跌破4000,24h涨幅-47%北京时间13&#x2F;03&#x2F;2020 10:15am","tags":["history"]},{"title":"美股熔断","path":"/2020/03/10/美股熔断/","content":"股市停止跳动美国股市有熔断制度： 当大盘跌幅达到-7%的时候，触发1级熔断，美国证券市场停止交易15分钟。 当大盘跌幅达到-13%的时候，触发2级熔断，美国证券市场再停止交易15分钟。 当大盘跌幅达到-20%的时候，触发3级熔断，当天直接停盘，不再交易。 这是自颁布以来，继1997&#x2F;10&#x2F;27之后的第二次熔断。主要的原因很有可能是石油大国之间的价格战争。 石油减产协议 2020&#x2F;3&#x2F;6，欧佩克和俄罗斯谈崩，无法达成减产150万&#x2F;日的协议。 2020&#x2F;3&#x2F;7，沙特发出增产公告，并大幅度调整官方油价，俄罗斯也应战，增加石油产量。 周一开盘，国际油价暴跌30%，危机情绪加大，引发各国股市大幅震荡。","tags":["history"]},{"title":"TypeScript Type Compatibility","path":"/2020/03/06/TypeScript-Type-Compatibility/","content":"Introduction123456789interface A &#123; text: string;&#125;class B &#123; text: string;&#125;let a: A = new B(); // no error At least same member1234567891011interface A &#123; text: string;&#125;function foo(obj: &#123; text: string &#125;): string &#123; return obj.text;&#125;let obj = &#123;text: &#x27;some text&#x27;, num: 3&#125;;let a: A = obj; // successfoo(obj); // success Functions1234567891011let a = (a: number) =&gt; a;let b = (a: number, b: number) =&gt; a + b;b = a; // successa = b; // errorlet x = () =&gt; (&#123;text: &#x27;some text&#x27;&#125;);let y = () =&gt; (&#123;text: &#x27;some text&#x27;, num: 3&#125;);x = y; // successy = x; // error Classes12345678910111213141516171819class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;let a: Animal;let b: Size;a = b; // successb = a; // success Generics123456789101112131415interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;string&gt;;let y: Empty&lt;number&gt;;x = y; // successinterface T&lt;T&gt; &#123; data: T;&#125;let x1: T&lt;string&gt;;let x2: T&lt;number&gt;;x1 = x2; // error","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Enums","path":"/2020/03/05/TypeScript-Enums/","content":"Numeric enums123456789101112enum Direction &#123; UP, DOWN, LEFT, RIGHT&#125;function move(length: number, direction: Direction): void &#123; console.log(`move: $&#123;direction&#125; $&#123;length&#125;meters.`);&#125;move(10, Direction.UP); String enums123456enum Direction &#123; UP=&#x27;UP&#x27;, DOWN=&#x27;DOWN&#x27;, LEFT=&#x27;LEFT&#x27;, RIGHT=&#x27;RIGHT&#x27;&#125; Heterogeneous enums1234enum E &#123; yes, no = &#x27;no&#x27;&#125; Computed members1234567enum E &#123; None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, L = &#x27;1234&#x27;.length&#125; Union enums and enum member types12345678910111213141516enum Kind &#123; Square, Circle&#125;interface Circle &#123; kind: Kind.Circle, radius: number&#125;interface Square &#123; kind: Kind.Square, length: number&#125;let c: Circle = &#123;kind: Kind.Circle, radius: 5&#125;; Enums at runtime123456789enum E &#123; X, Y, Z&#125;function f(obj: &#123; X: number &#125;) &#123; return obj.X;&#125;f(E); // work Enums at compile time1234567891011121314enum LogLevel &#123; ERROR, WARN, INFO, DEBUG&#125;type LogLevelString = keyof typeof LogLevel;function print(key: LogLevelString, message: string): void &#123; const num = LogLevel[key]; if (num &lt;= LogLevel.WARN) &#123; console.log(`$&#123;key&#125;-$&#123;num&#125;-$&#123;message&#125;`); &#125;&#125;print(&#x27;WARN&#x27;, &#x27;warning&#x27;); Reverse mappings123456enum E &#123; A&#125;let a = E.A;let getName = E[a]; // &#x27;A&#x27;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Generics","path":"/2020/03/04/TypeScript-Generics/","content":"Generics12345678function foo&lt;T&gt;(arg: T): T &#123; return arg;&#125;function len&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); return arg;&#125; Generics Types1234567891011function foo&lt;T&gt;(arg: T): T &#123; return arg;&#125;interface fooInterface&lt;T&gt; &#123; (arg: T): T;&#125;let myFunction: &lt;T&gt;(arg: T) =&gt; T = foo;let otherFunction: &#123; &lt;T&gt;(arg: T): T &#125; = foo;let interfaceFunction: fooInterface&lt;number&gt; = foo; Generics Classes123456789101112131415161718class GenericsNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let number = new GenericsNumber&lt;number&gt;();number.zeroValue = 0;number.add = function (x, y) &#123; return x + y;&#125;;let string = new GenericsNumber&lt;string&gt;();string.zeroValue = &#x27;&#x27;;string.add = function (x, y) &#123; return x + y;&#125;;console.log(string.add(string.zeroValue, &#x27;test&#x27;)); Generics Constraints12345678interface Lengthwise &#123; length: number;&#125;function foo&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; Using Type Parameters in Generic Constraints1234567function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let obj = &#123;a: 1, b: 2, c: 3, d: 4&#125;;console.log(getProperty(obj, &#x27;a&#x27;));console.log(getProperty(obj, &#x27;e&#x27;)); // error Using Class Types in Generics12345678910111213141516171819202122232425262728293031323334353637function create&lt;T&gt;(c: &#123; new(): T &#125;): T &#123; return new c();&#125;class BeeKeeper &#123; constructor(private hasMask: boolean = false) &#123; &#125;&#125;class ZooKeeper &#123; constructor(private nameTag: string = &#x27;undefined&#x27;) &#123; &#125;&#125;class Animal &#123; constructor(private numLegs: number = 0) &#123; &#125;&#125;class Bee extends Animal &#123; constructor(num: number, public keeper: BeeKeeper) &#123; super(num); &#125;&#125;class Lion extends Animal &#123; constructor(num: number, public keeper: ZooKeeper) &#123; super(num); &#125;&#125;function createInstance&lt;A extends Animal&gt;(c: new (x, y) =&gt; A, numLegs: number, keeper: any): A &#123; return new c(numLegs, keeper);&#125;console.log(createInstance(Bee, 2, new BeeKeeper(true)));console.log(createInstance(Lion, 4, new ZooKeeper(&#x27;lion&#x27;)));","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Functions","path":"/2020/03/03/TypeScript-Functions/","content":"Function TypesTyping the function1234567function foo(x: number, y: string): string &#123; return x + y;&#125;let fo = function (x: number, y: string): string &#123; return x + y;&#125;; Writing the function type123let foo: (x: number, y: string) =&gt; string = function (x: number, y: string): string &#123; return x + y;&#125;; Inferring types123let foo: (x: number, y: string) =&gt; string = function (x, y) &#123; return x + y;&#125; Optional and Default Parameters12345678910111213141516171819202122232425function getName(firstName: string, lastName?: string): string &#123; if (lastName) &#123; return firstName + &#x27; &#x27; + lastName; &#125; else &#123; return firstName; &#125;&#125;getName(&#x27;Edward&#x27;);getName(&#x27;Edison&#x27;, undefined);getName(&#x27;Jack&#x27;, &#x27;Li&#x27;);getName(&#x27;Jack&#x27;, &#x27;R&#x27;, &#x27;Li&#x27;); // error, too many parameters.function buildName(firstName: string, lastName: string = &#x27;Li&#x27;): string &#123; if (lastName) &#123; return firstName + &#x27; &#x27; + lastName; &#125; else &#123; return firstName; &#125;&#125;buildName(&#x27;Edward&#x27;);buildName(&#x27;Edison&#x27;, undefined);buildName(&#x27;Jack&#x27;, &#x27;Li&#x27;);buildName(&#x27;Jack&#x27;, &#x27;R&#x27;, &#x27;Li&#x27;); // error, too many parameters. Rest Parameters123456function buildName(firstName: string, ...restOfName: string[]): string &#123; return firstName + &#x27; &#x27; + restOfName.join(&#x27; &#x27;);&#125;let buildNameFun: (firstName: string, ...restOfName: string[]) =&gt; string = buildName;console.log(buildName(&#x27;Jack&#x27;, &#x27;R&#x27;, &#x27;Chen&#x27;)); this and arrow functions123456789101112131415let deck = &#123; suits: [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;], cards: Array(52), createCardPicker: function () &#123; // NOTE: The arrow function allowing us to capture &#x27;this&#x27; right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;;console.log(deck.createCardPicker()()); this parameters1234567891011121314151617181920212223242526interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;], cards: Array(52), createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;;console.log(deck.createCardPicker()()) Overloads1234567891011121314151617181920let suits = [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;];function pickCard(x: &#123; suit: string, card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string, card: number &#125;;function pickCard(x): any &#123; if (typeof x == &#x27;object&#x27;) &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; else if (typeof x == &#x27;number&#x27;) &#123; let pickedSuit = Math.floor(x / 13); return &#123;suit: suits[pickedSuit], card: x % 13&#125;; &#125;&#125;let myDeck = [&#123;suit: &quot;diamonds&quot;, card: 2&#125;, &#123;suit: &quot;spades&quot;, card: 10&#125;, &#123;suit: &quot;hearts&quot;, card: 4&#125;];let pickedCard1 = myDeck[pickCard(myDeck)];console.log(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);let pickedCard2 = pickCard(35);console.log(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Classes","path":"/2020/02/29/TypeScript-Classes/","content":"Classes1234567891011class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet(): string &#123; return &#x27;Hello, &#x27; + this.greeting; &#125;&#125; Private123456789101112131415161718192021class Animal &#123; constructor(private name: string) &#123; &#125;&#125;class Horse extends Animal &#123; constructor() &#123; super(&#x27;Horse&#x27;); &#125;&#125;class Human &#123; constructor(private name: string) &#123; &#125;&#125;let animal = new Animal(&#x27;Lucy&#x27;);let horse = new Horse();let human = new Human(&#x27;Jack&#x27;);animal = horse; // successanimal = human; // failed Protected123456789101112131415161718192021222324class Person &#123; protected name: string; protected constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getInfo(): string &#123; return `name: $&#123;this.name&#125;, department: $&#123;this.department&#125;` &#125;&#125;let Edward = new Employee(&#x27;Edward&#x27;, &#x27;front-end&#x27;);let person = new Person(&#x27;Jack&#x27;); // failedconsole.log(Edward.getInfo()); Readonly modifier12345678910class C &#123; readonly name: string; readonly length: number = 8; constructor(name: string) &#123; this.name = name; &#125;&#125;new C(&#x27;test&#x27;).name = &#x27;test1&#x27;; // failed Accessors1234567891011121314151617const MAX = 10;class Person &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(name: string) &#123; if (name &amp;&amp; name.length &gt; MAX) &#123; throw new Error(&#x27;too long&#x27;); &#125; this._fullName = name; &#125;&#125;new Person().fullName = &#x27;Edward&#x27;; Static Properties123456789101112131415class Point &#123; static origin = &#123;x: 0, y: 0&#125;; constructor(public scale: number) &#123; &#125; calculateDistance(point: &#123; x: number, y: number &#125;): number &#123; let xDist = (point.x - Point.origin.x); let yDist = (point.y - Point.origin.y); return Math.sqrt(xDist ** 2 + yDist ** 2); &#125;&#125;let point1 = new Point(1, 0);console.log(point1.calculateDistance(&#123;10, 20&#125;)); Abstract Classes12345678910111213141516171819202122232425262728abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log(&#x27;name: &#x27; + this.name); &#125; abstract printMeeting(): void;&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(&#x27;AccountingDepartment&#x27;); &#125; printMeeting(): void &#123; console.log(&#x27;This is Accounting Department&#x27;); &#125; foo(): void &#123; console.log(&#x27;foo&#x27;); &#125;&#125;let department: Department = new Department(); // error: can not create an instance of an abstract classlet department2: Department = new AccountingDepartment();department2.foo(); // error: method doesn&#x27;t exist on declared abstract type Using a class as an interface12345678910class Point &#123; x: number; y: number;&#125;interface point3D extends Point &#123; z: number;&#125;const point: point3D = &#123;x: 0, y: 0, z: 0&#125;;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript Interface","path":"/2020/02/26/TypeScript-Interface/","content":"Interface12345678910interface labelValue &#123; label: string;&#125;function printLabel(obj: labelValue): void &#123; console.log(obj.label);&#125;let obj = &#123;size: 10, label: &#x27;some text&#x27;&#125;;printLabel(obj); Optional Properties1234567891011121314interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string, area: number &#125; &#123; let defaultSquare = &#123;color: &#x27;White&#x27;, area: 200&#125;; if (config.color) defaultSquare.color = config.color; if (config.width) defaultSquare.area = config.width ** 2; return defaultSquare;&#125;console.log(createSquare(&#123;color: &#x27;Black&#x27;, width: 30&#125;)); Readonly Properties1234567interface Point &#123; readonly x: number; readonly y: number;&#125;let readOnlyArray: ReadonlyArray&lt;number&gt; = [1, 2, 3, 4];let a: number[] = readOnlyArray as number[]; // readonly array assignment to ordinary array Excess Property Checks1234567interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;let newSquare = createSquare(&#123;width: 100, opacity: 0.5&#125; as SquareConfig); Function Types1234567interface foo &#123; (source: string, subString: string): boolean;&#125;let mySearchFunction: foo = function (src, sub) &#123; return src.search(sub) &gt; -1;&#125;; Indexable Types1234567891011121314151617181920interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray = [&#x27;text1&#x27;, &#x27;text2&#x27;];let text1 = myArray[0];interface NumberDictionary &#123; [index: string]: number; length: number; name: string; // error&#125;interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let readonly: ReadonlyStringArray = [&#x27;text1&#x27;, &#x27;text2&#x27;];readonly[2] = &#x27;change&#x27;; // error Class Types12345678910111213141516interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125;&#125; Static sides of class1234567891011121314151617181920212223242526272829303132interface ClockInterface &#123; tick();&#125;interface ClockConstructor &#123; new(hour: number, minute: number): ClockInterface;&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(&#x27;tick&#x27;); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(&#x27;tick22222&#x27;); &#125;&#125;let digital = createClock(DigitalClock, 12, 0);let analog = createClock(AnalogClock, 12, 1); Extending Interfaces12345678910111213141516interface A &#123; color: string;&#125;interface B &#123; width: number;&#125;interface Square extends A, B &#123; sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = &#x27;white&#x27;;square.width = 2;square.sideLength = 4; Hybrid Types1234567891011121314151617181920212223interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = (function (start: number) &#123; // some thing &#125;) as Counter; counter.interval = 20; counter.reset = function () &#123; // some thing &#125;; return counter;&#125;let counter = getCounter();counter(10);counter.reset();counter.interval = 10; Interface Extending Classes123456789101112131415161718192021222324252627class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; // subclass of Control &amp; implement the interface select(): void &#123; // from the interface // some thing &#125;&#125;class TextBox extends Control &#123; // subclass of Control select(): void &#123; // custom function // some thing &#125;&#125;class Image implements SelectableControl &#123; // just implement the interface, but not the subclass of Control private state: any; // need to add. select(): void &#123; // some thing &#125;&#125;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"TypeScript 初探","path":"/2020/02/25/TypeScript-初探/","content":"基本类型 boolean:1let done: boolean = true; number:1let count: number = 20; string:1let name = &#x27;Edward Wang&#x27;; array:12let list1: number[] = [1, 2, 3];let list2: Array&lt;number&gt; = [1, 2, 3]; tuple:1let x: [string, number] = [&#x27;test&#x27;, 2]; enum:12345678enum NUMBER &#123; ONE, TWO, THREE &#125;let a = NUMBER.TWO;let title: string = NUMBER[3]; any:1234let x: any = 4;x = &#x27;string&#x27;;let list: any[] = [1, true, &#x27;stirng&#x27;]; void:表示没有返回类型，只能被赋予null和undefined。1234function warning(): void &#123; console.log(&#x27;warning&#x27;);&#125;let unusable: void = undefined; null &amp; undefined:默认情况下null和undefined是所有类型的子类型。如果使用了--strictNullChecks标记,null、undefined、void只能赋值给他们自己。12let u: undefined = undefined;let n: null = null; never:表示永不存在值的类型。123function error(message: string): never &#123; throw new Error(message);&#125; object:除number、string、boolean、symbol、null或undefined之外的类型。 类型断言 &lt;&gt;断言12let text: any = &#x27;some text&#x27;;let strLength = (&lt;string&gt;text).length; as断言12let text: any = &#x27;some text&#x27;;let strLength = (text as string).length;","tags":["整理","学习"],"categories":["TypeScript"]},{"title":"Trump一番话影响经济市场","path":"/2020/01/09/Trump一番话影响经济市场/","content":"川普不对伊朗动武 美股涨 金价回落 油价跳水伊朗袭击美军驻伊拉克基地后，美国总统川普表示将升级经济制裁取代付诸武力。市场乐观情绪上扬，美股上涨，金价回落，油价则大跳水。 川普1月8日在白宫发表谈话，伊朗袭击并未伤害到任何美国人，称伊朗有所退让，暗示不会对伊朗动武，伊朗外交部长也称该国不寻求升级事态，这些消息都缓解了投资人对美伊局势的不安。 8日美国股市上涨，道琼工业指数收涨161.41点或0.56%，报28745.09点。标普500指数收涨15.87点或0.49%，报3253.05点。那斯达克指数收涨60.66点或0.67%，报9129.24点。费城半导体指数上涨0.31点或0.02%，报1867.59点。 那斯达克指数创收盘新高，道琼工业指数、标普500指数、费城半导体指数徘回历史次高位。 亚洲股市9日也普遍回涨，衡量6种主要货币对美元的美元指数上涨0.33%至97.01。 而黄金价格原本因市场的避险情绪，8日一度升穿每英两1,600美元，为近七年来首见，但川普总统演讲缓解市场疑虑后，金价迅速回落。 黄金现货下跌近1%，报每英两1,559.22美元，盘中触及2013年以来最高的1,610.90美元。美国黄金期货收跌0.9%，结算价报每英两1,560.20美元。 OANDA高级市场分析师Edward Moya表示：「可能不会爆发战争，金价因此走低，但其余推动走势的催化剂仍在，黄金价格短期内上看每盎英两1,640美元」。 国际油价则在8日重挫逾4%。原本盘中一度飙升至近四个月高点，但中东紧张局势出现缓解迹象，且美国原油库存意外增加，油价随之跳水。 布兰特原油期货下跌2.83美元或4.2%，结算价报每桶65.44美元；西德州原油期货下跌3.09美元或4.9%，结算价报每桶59.61美元。 美国能源资讯署（EIA）表示，上周原油库存增加120万桶，高于市场预期的减少260万桶，也高于美国石油协会（API）公布的减少590万桶。 BTC同样也受影响 一小时内下跌$2401&#x2F;8&#x2F;2020 23:49 UTC+8 时间，BTC价格为$8335.19。1&#x2F;9&#x2F;2020 00:55 UTC+8 时间，BTC价格为$8095.46。1&#x2F;9&#x2F;2020 03:50 UTC+8 时间，BTC跌破**$8000，价格为$7992.02。1&#x2F;9&#x2F;2020 04:25 UTC+8 时间，BTC跌破$7900**，价格为$7887.35。 到日间有所回暖，但随后又开始下跌。","tags":["雜談"]},{"title":"美国确认空袭导致伊朗将军苏莱曼尼死亡","path":"/2020/01/03/美国确认空袭导致伊朗将军苏莱曼尼死亡/","content":"《纽约时报》美国当地时间1月2日报道说，美国官员确认，在美军对巴格达的一次空袭中，伊朗伊斯兰革命卫队特种部队“圣城旅”部队指挥官卡西姆·苏莱曼尼将军死亡。 《纽约时报》报道，伊朗官方媒体确认了，伊拉克当地时间3日，伊朗将军卡西姆·苏莱曼尼在美军对巴格达国际机场一处目标的空袭中死亡。苏莱曼尼是伊朗革命卫队中的重要官员。美国国防部声明表示，美国发动了空袭。 “苏莱曼尼将军积极筹划了对美国在伊拉克及地区的外交官和服务人员的攻击。苏莱曼尼将军和‘圣城旅’需要为美军和联军数百人死亡、数千人受伤负起责任。” 伊朗誓言为苏莱曼尼将军之死报复美国伊朗伊斯兰革命卫队（伊朗武装力量组成部分）前总司令、伊朗确定国家利益委员会秘书长穆赫辛·雷扎伊称，伊朗将为在巴格达死于火箭弹袭击的伊斯兰革命卫队圣城旅指挥官卡西姆·苏莱曼尼将军复仇。 雷扎伊在推特上写道： “殉难的卡西姆·苏莱曼尼去找他的兄弟们了。我们会狠狠报复美国。” 伊斯兰革命卫队圣城旅指挥官卡西姆·苏莱曼尼将军2日晚上在巴格达的火箭弹袭击中被炸死，伊拉克什叶派民兵武装“人民动员组织”(Al-Hashd al-Shaabi)的几位高级别成员也一同丧生，12名伊拉克士兵受伤。 五角大楼称系按照美国总统川普的命令开展对苏莱曼尼的行动。五角大楼称，此次打击旨在预防伊朗方面的袭击，而苏莱曼尼本人涉嫌参与袭击联盟基地和美国驻伊拉克大使馆。","tags":["history"]},{"title":"Telegram批量邀请成员进组","path":"/2019/12/25/Telegram批量邀请成员进组/","content":"TG（目前）最大的需求–宣传前几天在 TG，有个人问我如何实现一个 TG 批量拉人入某个 group。找了找资料发现真的可以实现。 测试了似乎单次最多只能邀请 30 人进组，并且一个人邀请太多人会被禁止单项邀请。TG 还能不进群，直接拉进去，直接获取某个群组的所有 mamber，太 BUG 了 有类似想法的可以联系我，与我交流。","tags":["雜談"]},{"title":"CNN: 比特币是过去十年最好投资","path":"/2019/12/20/CNN-比特币是过去十年最好投资/","content":"The best investment of the decade turned $1 into $90,000The decade is almost over — and one incredibly volatile investment stood out from all the rest as the best of the 2010s. Want to guess what it was? Bitcoin According to a recent report by Bank of America Securities, if you invested $1 in bitcoin at the start of the decade, it would now be worth more than $90,000. A bitcoin is currently valued at about $7,000. While that’s still significantly below its peak price of just under $20,000 two years ago, it’s substantially higher than the fractions of a penny that one bitcoin cost at the beginning of the Twenty-Teens. Bitcoin remains a highly speculative investment, but it has soared during the past decade as it emerged as the most-popular and widely accepted cryptocurrency. More retailers are accepting bitcoin as a form of payment, and several investment firms and exchanges have launched futures trading for bitcoin, a move that helped legitimize it. And Facebook’s planned launch of the Libra digital currency initiative has also further validated bitcoin and other crytpocurrencies in the minds of many investors. The BofA report lists several other fun facts about what’s been a wild decade for the markets — one that has seen stocks recover from the depths of the Great Recession and hit new highs despite a trade war between the United States and China, attacks on the Federal Reserve by President Trump, Brexit concerns and a slowdown in Europe as well as continued malaise in Japan. Go USA! But hope you avoided Myanmar and GreeceAlthough bitcoin has been the star investment of the 2010s, anybody stuck with a spare kyat — the local currency of Myanmar — won’t be too happy. Ethnic conflicts, violence and instability in the nation formerly known as Burma have left a dollar invested in a kyat at the beginning of the decade worth just 4 tenths of one US cent today. Turning to stocks, Greece was not the word. The Mediterranean nation continued to struggle in the wake of its debt crisis. BofA investment strategists Michael Hartnett and Tommy Ricketts noted in the report that $1 dollar invested in the Greek equity market in 2010 is now worth only 7 cents. The United States was the best stock market in the world, with $1 in American stocks now valued at about $3.46. That’s a gain of nearly 250%. US bonds were also the best performers in fixed income. A 30-year Treasury that was worth $1 in 2010 is now valued at about $2.08. But Greece’s neighbor Turkey had the worst bond of the decade. A dollar in benchmark Turkish bonds at the beginning of 2010 is now worth only 61 cents. And many bonds no longer generate any income for investors at all. Negative interest rates have been good for gold. But oil has languishedSeveral central banks around the globe have slashed interest rates to below zero to try and jumpstart sluggish economies. As a result, BofA said that 2019 had $17 trillion’s worth of sovereign debt sporting a negative yield. In 2010, no bonds had negative yields. Speaking of central banks, it may seem like US Fed chairs Ben Bernanke, Janet Yellen and Jerome Powell have moved interest rates a lot during the past decade. But they have nothing on Brazil. The Brazilian central bank was the most active — with 25 rate cuts and 24 rate hikes since 2010. The Bank of Japan was the quietest central bank. It lowered rates once in the past ten years — to negative territory in 2016. As interest rates have fallen, investors have flocked to gold, which was the top commodity of the 2010s. $1 of gold in 2010 is now worth $1.34. But crude oil was the worst commodity. A dollar’s worth of oil is now valued at just 74 cents. The drop in oil prices, in part because of sluggish demand and more supply from more American shale producers, is a key reason why energy stocks were among the biggest dogs in the S&amp;P 500 during the past decade as well.","categories":["Digital currency"]},{"title":"复旦大学修改章程","path":"/2019/12/18/复旦大学修改章程/","content":"教育部关于同意复旦大学章程部分条款修改的批复 教政法函〔2019〕18号重点修改如下： 序言第一段“国人自主创办”改为“中国人自主创办”。 序言第二段删去“学校的办学理念是其校歌所传颂的……思想自由……强调以学术精神滋养师生，坚守价值，治学严谨，为学有恒。学校始终秉持团结、服务与牺牲的精神，强调学校、师生的社会责任和国家使命。”增加“敦行爱国奉献……海纳百川、追求卓越。学校倡导‘文明、健康、团结、奋发’的校风和‘刻苦、严谨、求实、创新’的学风，强调坚持理想、探究真理、正谊明道、守护文明。” 序言第三段新增“学校坚持中国共产党的领导，全面贯彻党的教育方针，坚持马克思主义指导地位和社会主义办学方向，扎根中国大地办大学，始终为人民服务，为中国共产党治国理政服务，为巩固和发展中国特色社会主义制度服务，为改革开放和社会主义现代化建设服务。立足中国特色社会主义新时代，学校落实立德树人根本任务，全面履行人才培养、科学研究、社会服务、文化传承创新、国际交流合作的使命……致力于培养德智体美劳全面发展的社会主义建设者和接班人，在实现中华民族伟大复兴的历史进程中建设中国特色世界顶尖大学”。 原章程第四条删去“师生治学、民主管理”，新增“实行中国共产党复旦大学委员会（以下简称党委）领导下的校长负责制”。 原章程第六条“师生依法独立自主开展学术研究”改为“鼓励师生依法自主开展学术研究”；新增“学校营造人心聚学的氛围”。 原章程第八条“独立自主办学”修改为：“自主办学”。 原章程第九条删去“学校实行中国共产党复旦大学委员会（简称学校党委）领导下的校长负责制”，“统一领导学校工作”改为“全面领导学校工作”，“校长独立负责地行使职权”改为“校长依法负责地行使职权”。 原章程第九条（一）新增“（校长）贯彻执行党的教育方针……依靠全校师生员工推动学校科学发展，培养德智体美劳全面发展的社会主义建设者和接班人”。 （二）删去“（支持校长）审定学校基本管理制度”。 （三）新增“坚持党管干部原则，按照干部管理权限负责干部的选拔、教育、培养、考核和监督，讨论决定学校内部组织机构的设置及其负责人的人选，依照有关程序推荐校级领导干部和优秀年轻干部人选，做好老干部工作”。 （四）新增“坚持党管人才原则，讨论决定学校人才工作规划和重大人才政策，创新人才工作体制机制，优化人才成长环境，统筹推进学校教师队伍及其他各类人才队伍建设”。 （五）新增“坚持用习近平新时代中国特色社会主义思想武装师生员工头脑，在师生员工中培育和践行社会主义核心价值观，牢牢掌握学校意识形态工作的领导权、管理权、话语权，维护学校安全稳定，促进和谐校园建设”。 （七）新增“加强学校党委自身建设，加强对学院(系)等基层党组织的领导，做好发展党员和党员教育、管理、服务工作，扩大党内基层民主，充分发挥基层党组织的战斗堡垒作用和党员的先锋模范作用”。 （八）新增“落实全面从严治党主体责任，领导学校党的纪律检查工作，推进惩治和预防腐败体系建设”。 （九）新增“向党委报告重大决议执行情况，向教职工代表大会报告工作，组织处理教职工代表大会、学生（研究生）代表大会、工会会员代表大会和团员代表大会有关行政工作的提案，支持学校各级党组织、民主党派基层组织、群众组织和学术组织开展工作”。 其他 新增“党委全体会议……主要对事关学校改革发展稳定和师生员工切身利益及党的建设等全局性重大问题作出决策。常务委员会……主要对学校改革发展稳定和教学、科研、行政管理及党的建设等方面的重要事项作出决定，按照干部管理权限和有关程序推荐、提名、决定任免干部。党委常委会由党委全委会选举产生……党委书记主持党委全面工作”。 复旦大学纪律检查委员会……根据相关规定履行职责”改为“依据党的章程和党内法规履行职责”。 原章程第十条新增“（校长）在学校党委领导下，贯彻党的教育方针，组织实施学校党委有关决议，行使高等教育法等规定的各项职权”。 原章程第十一条删去“学校党政领导不参加学术委员会”；新增“依据民主集中制产生（学术委员会）”。 原章程第十二条（二）新增“在国家授权范围内（审议学科专业）”。 其他新增“依据民主集中制产生（学位评定委员会）……连任一般不超过两届”。 原章程第十三条“教学指导委员会委员……由校长聘任”改为“依照民主集中制原则产生”。新增“院系教学指导分委员会，组成人员依照民主集中制原则产生”。 原章程第十四条删除“校务委员会领导下设各专门咨询委员会”以及专门咨询委员会的全部章程。 新增一条第十四条“学校设置教材委员会。教材委员会在学校党委领导下，对学校教材建设、使用与管理工作进行指导、审议和监督……主要职责是：（一）贯彻党和国家关于教材工作的方针政策，指导和统筹全校教材工作……”。 原章程第十五条教职工代表大会“评议学校各级党政负责人”改为“参与评议”。新增“（共青团复旦大学委员会）指导学生会和研究生会，指导和管理学生社团工作”。 原章程第十七条删去“学校是以学术为核心的共同体”。 原章程第二十条新增“学校构建以思想政治教育为根本……的教育教学体系”。 原章程第二十一条自主设置与境外高校联合学位项目”改为“授予名誉博士学位须报国务院学位委员会批准”。 原章程第二十四条新增“学院……落实立德树人根本任务”。 原章程第二十六条“学校确定一名副校长兼任上海医学院院长”，改为“上海医学院党政主要领导由校领导兼任”。 新增第二十八条“学院（系）直属学校的实体研究机构设立党的组织，发挥政治核心作用，负责党的建设和思想政治工作，保证监督本单位贯彻落实党的路线方针政策及学校决定，支持行政班子在其职责范围内负责地开展工作。”第二十九条：“学院（系）依照有关规定通过党政联席会议，研究决定本单位重大事项，健全集体领导、党政分工合作、协调运行的工作机制。涉及办学方向、教师队伍建设、师生员工切身利益等重大事项，由党组织先研究再提交党政联席会议决定。”。 原章程第三十二条教师的专职新增“教育”，从“教学科研”变为“教育教学科研”；“代表性成果为核心的晋升制度”修改为：“有基本标准要求与代表性成果相结合的评价制度”。 原章程第三十五条加入增加第一款“（教职员工负有义务）忠诚于党的教育事业，学习贯彻党和国家的教育方针，坚持立德树人根本任务，践行社会主义核心价值观”（此条直接引用），“为人师表，爱护学生、立德树人”修改为：“恪守师德规范，履行育人职责，为人师表，敬业爱生，引领学生健康成长”。 第三十一条 原章程第四十三条（现第四十五条）学生在校，应当以学习为要务。”修改为：“学生在校，应当以学习为要务，注重价值观、知识和能力的全面协调发展，不断提升综合素养。”。 第三十三条 原章程第四十八条（现第五十条）“学生群体内部事务，原则上由学生自主管理、自我完善”修改为：“学生群体应不断提高自我教育、自我管理、自我服务、自我监督的意识和能力”。 新增一条第三十七条“学校根据需要，按照国家法律、法规和学校有关规定聘请外籍教师。外籍教师应遵守中国的法律、法规及学校的规章制度和纪律，对华友好，尊重中国的社会公德和风俗习惯，享有相应权利，履行相关义务。”。 原章程第四十八条删去“复旦大学学生会……是学生自我服务、自我管理、自我教育、自我监督的组织”。复旦大学学生会以及研究生会……是全校本（专）科学生以及研究生参与学生事务的最高权力机关”，改为“是全校本（专）科学生以及研究生参与学生事务的重要形式”。 新增一条第五十二条“学校招收外国留学生，提供学历教育和非学历教育，依照国家有关法律、法规和学校的规章制度对外国留学生进行教育和管理。外国留学生应遵守中国的法律、法规及学校的规章制度和纪律，尊重中国的社会公德和风俗习惯，享有相应权利，履行相关义务”。 原章程第五十九条“（学校董事会旨在）健全监督机制”改为“共商共促学校发展”。 复旦大学校歌刘大白 词丰子恺 曲歌词：复旦复旦旦复旦，巍巍学府文章焕，学术独立思想自由，政罗教网无羁绊，无羁绊前程远，向前，向前，向前进展。复旦复旦旦复旦，日月光华同灿烂。复旦复旦旦复旦，师生一德精神贯，巩固学校维护国家，先忧后乐交相勉，交相勉前程远，向前，向前，向前进展。复旦复旦旦复旦，日月光华同灿烂。复旦复旦旦复旦，沪滨屹立东南冠，作育国士恢廓学风，震欧铄美声名满，声名满前程远，向前，向前，向前进展。复旦复旦旦复旦，日月光华同灿烂。 百度百科复旦大学校歌_百度百科","tags":["history"]},{"title":"区块链项目需要注意哪些司法新动向","path":"/2019/12/17/区块链项目需要注意哪些司法新动向/","content":"警方虚拟币法律知识的更新继沿海几座大城市的网警朋友积极学习区块链技术（存证等方面）和相关法律知识之后，内陆的经济警察也开始相关法律知识的更新。 我们发现，浙江某市的区块链内部研讨会议和技术复盘会议中，也出现了警察叔叔参与讨论，而且其对技术本身的研究颇深，出乎大家意料。这与两年前在人民大学与公检法朋友们沟通时的情况（彼时他们对区块链的陌生）形成了鲜明的对比。 这充分说明，已经有案子出现了，并且呈现一定活跃态势，司法机关严阵以待，提前用相关法律知识武装自己，以便更好地适应或许会出现的涉币案件潮。 反观链圈，几乎每一个区块链项目方都有“发币”的冲动，虽然我们理解“激励机制”对项目自身的作用，然而，一旦发币ICO，在我国现有法律框架下会被定性为“非法的公开融资行为”，涉嫌非法集资类犯罪或非法经营罪等。 懂币圈的人越来越多曾几何时，我们以为坐在对面的检察官朋友对币圈不甚了解，近期发现，并非如此。为了办案准确，他们深入调研，甚至暗访；对于token的价值，并不是全盘否定，而是认为如果token对应有权益等，则token自身是有价值的，不能把发行代币的行为认定为“诈骗”，在实务中，也做出了“不批捕”的决定。 同时，在认定是否涉嫌非法吸收公众存款罪的问题上，检方对于“投资者特定与否”的认定相对严格，如果确实“私募”，那么，不构成刑法第176条非法吸收公众存款罪。但是，不一定会按照无罪处理，而是有可能选择计算机类犯罪予以补白。 对于“境外发币，境内无实质销售”的行为，当下，司法机关采取的方式还是相对宽容的，基本不会主动“穿透式审判”，而是“等子弹再飞一会儿”。因此，类似的项目方暂时可以喘息，记住千万不要回国内进行“路演”等销售活动，以免遭遇刑事风险。 组织领导传销罪，浮出水面与飒姐同在一所高校任职兼职硕导的资深检察官，谈到其学生在某区按摩店门口窥见一群老人家认真听课：什么是区块链什么是虚拟币及如何投资。 这不禁让我们联想起数年前的P2P线下推广，十几年前的纳米技术线下推广，新瓶装旧酒，还是那个配方：传销行为。 诚然，传销行为本身只是违法行为，不构成犯罪。但是，我们必须说明，组织者和领导者是构成犯罪的。其中，读者需要特别注意的是，传销活动中的“讲师”应归属于“组织者领导者”的范围之内，应当受到刑法第224条之一组织领导传销罪的处理。 目前，在内陆一些城市拿区块链技术蒙骗投资者的不法活动有所抬头，相信办案机关不会坐视不管，传说中的“剿匪”工作势在必行，务必保护好老百姓的钱袋子。在此，飒姐也提醒诸位读者，不要轻信项目方的忽悠，您看中的是“回报”，人家看上的是您的“本金”。 写在最后目前法律的态度非常坚决，发币是非法公开融资，涉币交易所不允许在境内存在，一旦发现立刻取缔。同时，针对区块链项目的备案，已经如火如荼进行中，但备案不是许可，并不能因此获得“法律金钟罩”，如果涉嫌违法犯罪，该处理的时候绝不会手软。 本文来源于 肖飒lawyer","categories":["Digital currency"]},{"title":"全球央行数字货币进展调研","path":"/2019/12/16/全球央行数字货币进展调研/","content":"Overview随着消费者支付习惯的改变，现金的存在作用在不断弱化。无现金交易将成为下一个支付前沿。目前多国央行在筹备发行数字货币，数字货币的稳定性和安全性，是各国央行研发的重中之重。 Report多家央行准备发行数字货币IBM 和国际货币金融机构（OMFIF）联合发布的最新调查报告显示，首个央行数字货币（CBDC）预计将在未来五年内发行。 报告显示，多国央行考虑开发和发行央行数字货币（CBDC），未来五年内可能会有面向消费者的 CBDC 推出，而面向消费者的 CBDC 可能需要某种形式的公司合作。CBDC 是由中央银行发行的一种用来支付和结算的数字资产。央行数字货币预计分为两种：零售型和批发型。零售型主要供社会大众和公司使用，目的或将替代现有的法定货币 M0；批发型则用于银行间结算服务，这将有效提高支付效率，并降低与现有支付系统相关的成本和复杂性。 IBM 和 OMFIF 还根据调查得出结论，首个 CBDC 预计在未来五年内从一个小经济体中产生，并以明确的用途响应一个特定的政策目标。这个调查，从 2019 年 7 月开始，历时三个月，调查对象涉及 13 个发达经济体和 10 个新兴市场的央行官员。其中 73% 的受访者表示支持 CBDC，认为某些情况下，CBDC 将是现金的良好替代品。 中国中国目前走在数字货币发行的前沿。据《财经》报道，由人民银行牵头，工、农、中、建四大国有商业银行，中国移动、中国电信、中国联通三大电信运营商共同参与的央行法定数字货币试点项目有望在深圳、苏州等地落地。 这距离首次法定数字货币试行间隔近三年，相较于上次试点，本次央行法定数字货币试点将走出央行系统，进入交通、教育、医疗等服务场景，触及 C 端用户，进入频繁应用阶段，试点银行可根据自身条件进行场景选择。该试点项目由央行货币金银局牵头，数字货币研究所具体落实。去年年底，央行货币金银局下的防伪处改为数字货币与防伪管理处，作为央行数字货币唯一的官方权威处室。 并且，法定数字货币的相关标准以及支付系统接入等测试工作也在同步推进中。 美国10 月，美联储一份名为《数字货币、稳定币以及不断发展的支付格局》的报告中提到，央行数字货币可以是一种灵活的中央银行发行的货币形式，甚至可能有助于解决美元面临的特里芬困境。 但根据彭博社报道，美国财长 Steven Mnuchin 在众议院金融服务委员会的听证会上称，五年内美联储没有发行数字货币的必要，也不反对 Facebook 创建数字货币，但 Facebook 的数字货币 Libra 需要完全遵守银行保密和反洗钱规定，并且绝不能用于资助恐怖主义。 目前而言，美国对发行央行数字货币还持有一种观望状态。 欧洲有消息称，如果欧洲内部支付成本仍然居高不下，私有支付系统不能解决支付成本问题，欧洲央行将推出数字货币用于内部支付结算，并称现金使用减少的迹象也将加速数字货币的实施。 法国外媒称，法兰西银行行长宣布，法国将于 2020 年开始试验一种提供给金融机构的央行数字货币。并称将在 2020 年第一季度结束之前，开始试验并发布项目信息。并且有报道称，法国央行支付监督和市场基础设施局将改名为基础设施、创新和支付局。新的机构将负责央行在数字货币、支付和基础设施方面的创新。 印度在距离印度央行下令禁止银行、电子钱包和支付网关提供商为加密货币交易所和其他与加密货币交易相关业务提供支持 18 个月后，其态度似乎在转变。印度央行已计划开发央行数字货币（CBDC），但尚未公布具体实施计划和时间。印度央行行长 Shaktikanta Das 表示随着技术发展，印度储备银行将在适当时候认真对待央行数字货币，但目前还处于起步阶段。 泰国2019 年 5 月，泰国中央银行和香港金融管理局签署了谅解备忘录，并表示香港和泰国的货币当局准备推出两层结构的数字货币，这是使用金融技术或金融科技为两个经济体之间的跨境资金转移创建原型的过程的一部分。 原型的第一层，称为 LionRock-Inathanon 项目。这将涉及到向参与试点计划的香港银行发行数字货币。香港金融管理局发言人称，第二层涉及银行将数字货币分发给其企业客户，以便与其他银行或其他公司进行批发付款。 这项计划的主要目的是，以研究「央行数字货币」在跨境支付领域里的应用，从而促进香港与泰国两地银行之间的双币种外汇交易同步交付，预计有关的联合报告将会于 2020 年第一季公布。该项「央行数字货币计划」与中国人民银行正在开发的数字货币相比，是不同的使用案例。央行专注于替换流通中的现金，而 LionRock 项目的重点则是简化银行与公司之间的跨境转账和付款。 突尼斯突尼斯已经宣布推出本国货币 Dinar 的数字版本「E-Dinar」，这个北非小国成为全国第一个发行中央银行数字货币（CBDC）的国家。突尼斯已经与俄罗斯公司 Universa 建立合作，通过 Universa 的区块链平台发行 E-Dinar。在上线时，突尼斯中央银行行长 Marouane EI Abassi 与国际货币基金组织（IMF）的代表之间象征性的进行了一次转账。 Conclusion全世界各国都对央行数字货币（CBDC）表现出了兴趣，但目前尚未出现有决定意义的央行数字货币。随着技术的进步，以及科技金融在整体金融框架中所占地位越来越重，央行数字货币的出现，将会对货币政策和金融系统稳定性产生重大影响。央行数字货币的发行除了需要技术的辅助，也需要有足够的框架来确保治理和风险管理，才能保证其健康稳定的发展。 本文来自：全球央行数字货币进展调研｜标准共识","categories":["Digital currency"]},{"title":"美国参议院一致通过《香港人权与民主法案》","path":"/2019/11/20/美国参议院一致通过《香港人权与民主法案》/","content":"Hong Kong Human Rights and Democracy Act","tags":["history"]},{"title":"策略模式","path":"/2019/07/15/策略模式/","content":"状态模式123456789101112131415161718192021222324252627let ResultState = (() =&gt; &#123; let States = &#123; state0: function () &#123; console.log(&#x27;state0&#x27;) &#125;, state1: function () &#123; console.log(&#x27;state1&#x27;) &#125;, state2: function () &#123; console.log(&#x27;state2&#x27;) &#125;, state3: function () &#123; console.log(&#x27;state3&#x27;) &#125; &#125; function show(result) &#123; States[&#x27;state&#x27; + result] &amp;&amp; States[&#x27;state&#x27; + result](); &#125; return &#123; show &#125;&#125;)();// for testResultState.show(3); 策略模式123456789101112131415let Price = (() =&gt; &#123; let obj = &#123; return30: price =&gt; +price + parseInt(price / 100) * 30, return50: price =&gt; +price + parseInt(price / 100) * 50, percent90: price =&gt; price * 100 * 90 / 10000, percent80: price =&gt; price * 100 * 80 / 10000 &#125;; return (algorithm, price) =&gt; &#123; return obj[algorithm] &amp;&amp; obj[algorithm](price); &#125;&#125;)();// for testlet price = Price(&#x27;return50&#x27;, 321.13);console.log(price);","tags":["学习"]},{"title":"装饰器","path":"/2019/07/14/装饰器/","content":"装饰器123456789101112131415161718192021222324252627282930313233/** * 为dom元素添加事件 * @param &#123;&#125; dom * @param &#123;*&#125; type * @param &#123;*&#125; fn */function addEvent(dom, type, fn) &#123; if (dom.addEventListener) &#123; dom.addEventListener(type, fn, false); &#125; else if (dom.attachEvent) &#123; dom.attachEvent(&#x27;on&#x27; + type, fn); &#125; else &#123; dom[&#x27;on&#x27; + type] = fn; &#125;&#125;/** * 装饰已有对象 * @param &#123;*&#125; id * @param &#123;*&#125; fn */function decorator(id, fn) &#123; let obj = document.querySelector(id); if (typeof id.onclick === &#x27;function&#x27;) &#123; let oldFn = id.onclick; id.onclick = function () &#123; oldFn(); fn(); &#125; &#125; else &#123; obj.onclick = fn; &#125;&#125; 观察者模式123456789101112131415161718192021222324252627282930313233343536let Observer = (() =&gt; &#123; let _message = &#123;&#125;; return &#123; regist: function (type, fn) &#123; if (typeof _message[type] === &#x27;undefined&#x27;) &#123; _message[type] = [fn]; &#125; else &#123; _message[type].push(fn); &#125; &#125;, fire: function (type, args) &#123; if (!_message[type]) &#123; return; &#125; let events = &#123; type, args: args || &#123;&#125; &#125;; for (let i = 0, len = _message[type].length; i &lt; len; i++) &#123; _message[type][i].call(this, events); &#125; &#125;, remove: function (type, fn) &#123; if (_message[type] instanceof Array) &#123; for (let i = _message[type].length - 1; i &gt;= 0; i--) &#123; _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1); &#125; &#125; &#125; &#125;;&#125;)();Observer.regist(&#x27;test&#x27;, function (e) &#123; // register console.log(e.type, e.args.msg);&#125;)Observer.fire(&#x27;test&#x27;, &#123; msg: &#x27;this is some test message&#x27; &#125;); // send","tags":["学习"]},{"title":"惰性单例","path":"/2019/07/12/惰性单例/","content":"惰性单例12345678910111213141516171819let LazySingle = (() =&gt; &#123; let instance = null; function Single() &#123; return &#123; Method: function () &#123; console.log(&#x27;public method&#x27;); &#125;, Prototype: &#x27;some message&#x27; &#125;; &#125; return () =&gt; &#123; if (!instance) instance = Single(); return instance; &#125;;&#125;)();// for testconsole.log(LazySingle().Prototype);LazySingle().Method();","tags":["学习"]},{"title":"原型模式","path":"/2019/07/11/原型模式/","content":"原型模式12345678910111213141516171819202122232425let LoopImages = function (imageArr,container) &#123; this.imageArr = imageArr; this.container = container;&#125;LoopImages.prototype = &#123; createImage: function () &#123; console.log(&#x27;create image&#x27;); &#125;, changeImage: function () &#123; console.log(&#x27;change image&#x27;); &#125;&#125;;let SlideLoopImg = function (imageArr, container) &#123; LoopImages.call(this, imageArr, container);&#125;;SlideLoopImg.prototype = new LoopImages(); // 继承SlideLoopImg.prototype.changeImage = () =&gt; &#123; // 重写 console.log(&#x27;slide loop change image&#x27;);&#125;;// for testlet slideImage = new SlideLoopImg([&#x27;1.jpg&#x27;, &#x27;2.jpg&#x27;], &#x27;slide&#x27;);console.log(slideImage.container);slideImage.changeImage(); 原型继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * copy object */function prototypeExtend() &#123; let F = function () &#123;&#125; // let F = new Function() for (let i = 0; i &lt; arguments.length; i++) &#123; for (let j in arguments[i]) &#123; F.prototype[j] = arguments[i][j] &#125; &#125; return new F()&#125;// for testlet car = prototypeExtend(&#123; speed: 20, fast: function () &#123; this.speed++ console.log(&#x27;is faster&#x27;) &#125;&#125;, &#123; slow: function () &#123; this.speed-- console.log(&#x27;is slower&#x27;) &#125;&#125;, &#123; stop: function () &#123; this.speed = 0 console.log(&#x27;is stop&#x27;) &#125;&#125;, &#123; currentSpeed: function () &#123; console.log(this.speed) &#125;&#125;);car.fast()car.fast()car.fast()car.fast()car.currentSpeed()car.stop()car.currentSpeed()","tags":["学习"]},{"title":"Builder 模式","path":"/2019/07/10/Builder-模式/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let Human = function (param) &#123; this.skill = param &amp;&amp; param.skill || &#x27;null&#x27;; this.hobby = param &amp;&amp; param.skill || &#x27;null&#x27;;&#125;;Human.prototype = &#123; getSkill: function () &#123; return this.skill; &#125;, getHobby: function () &#123; return this.hobby; &#125;&#125;;let Named = function (name) &#123; let _this = this; ((name, _this) =&gt; &#123; this.wholeName = name; if (name.indexOf(&#x27; &#x27;) &gt; -1) &#123; _this.FirstName = name.slice(0, name.indexOf(&#x27; &#x27;)); _this.LastName = name.slice(name.indexOf(&#x27; &#x27;)); &#125; &#125;)(name, _this);&#125;;let Work = function (work) &#123; let _this = this; ((work, _this) =&gt; &#123; switch (work) &#123; case &#x27;code&#x27;: this.work = &#x27;developer&#x27;; break; case &#x27;design&#x27;: this.work = &#x27;designer&#x27;; break; default: this.work = work; &#125; &#125;)(work, _this);&#125;;Work.prototype.changeWork = function (work) &#123; this.work = work;&#125;/** * to create a Person * @param &#123;*&#125; name * @param &#123;*&#125; work */let Person = function (name, work) &#123; let _person = new Human(); _person.name = new Named(name); _person.work = new Work(work); return _person;&#125;;// for testlet person = new Person(&#x27;Jack Edward&#x27;, &#x27;design&#x27;);console.log(person.work);console.log(person.name);person.work.changeWork(&#x27;code&#x27;);console.log(person.work);","tags":["学习"]},{"title":"工厂模式","path":"/2019/07/09/工厂模式/","content":"工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let Basketball = function () &#123; this.name = &quot;basketball&quot;;&#125;;Basketball.prototype = &#123; getMember: function () &#123; console.log(5); &#125;, getBallSize: function () &#123; console.log(&quot;big&quot;); &#125;,&#125;;let FootBall = function () &#123; this.name = &quot;football&quot;;&#125;;FootBall.prototype = &#123; getMember: function () &#123; console.log(11); &#125;, getBallSize: function () &#123; console.log(&quot;big&quot;); &#125;,&#125;;let Tennis = function () &#123; this.name = &quot;tennis&quot;;&#125;;Tennis.prototype = &#123; getMember: function () &#123; console.log(1); &#125;, getBallSize: function () &#123; console.log(&quot;small&quot;); &#125;,&#125;;let SportFactory = function (name) &#123; switch (name) &#123; case &quot;basketball&quot;: return new Basketball(); case &quot;football&quot;: return new FootBall(); case &quot;tennis&quot;: return new Tennis(); &#125;&#125;;let footBall = new SportFactory(&quot;football&quot;);footBall.getMember(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Product base attributeinterface Product &#123; operation(): string;&#125;class ConcreteProduct1 implements Product &#123; public operation(): string &#123; return &quot;This is Product1&quot;; &#125;&#125;class ConcreteProduct2 implements Product &#123; public operation(): string &#123; return &quot;This is Product2&quot;; &#125;&#125;abstract class Creator &#123; public abstract factoryMethod(): Product; public operation(): string &#123; const product = this.factoryMethod(); return product.operation(); &#125;&#125;class ConcreteCreator1 extends Creator &#123; public factoryMethod(): Product &#123; return new ConcreteProduct1(); &#125;&#125;class ConcreteCreator2 extends Creator &#123; public factoryMethod(): Product &#123; return new ConcreteProduct2(); &#125;&#125;// usagefunction clientCode(creator: Creator) &#123; console.log(creator.operation());&#125;clientCode(new ConcreteCreator1());clientCode(new ConcreteCreator2()); 安全工厂123456789101112131415161718192021222324252627282930let Factory = function (type, content) &#123; if (this instanceof Factory) &#123; // check if is instance Factory return new this[type](content); &#125; else &#123; return new Factory(type, content); &#125;&#125;;Factory.prototype = &#123; Java: function (content) &#123; console.log(content); &#125;, JavaScript: function (content) &#123; console.log(content); &#125;,&#125;;let data = [ &#123; type: &quot;Java&quot;, content: &quot;This is Java&quot;, &#125;, &#123; type: &quot;JavaScript&quot;, content: &quot;This is JavaScript&quot;, &#125;,];// for testfor (let i = 0; i &lt; data.length; i++) Factory(data[i].type, data[i].content); 抽象工厂12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * to extend superType * @param &#123;*&#125; subType * @param &#123;*&#125; superType */let VehicleFactory = (subType, superType) =&gt; &#123; if (typeof VehicleFactory[superType] === &quot;function&quot;) &#123; function F() &#123;&#125; F.prototype = new VehicleFactory[superType](); subType.constuctor = subType; subType.prototype = new F(); &#125; else &#123; throw new Error(&quot;don&#x27; not have this abstract class&quot;); &#125;&#125;;// create base classVehicleFactory.Car = function () &#123; this.type = &quot;car&quot;;&#125;;VehicleFactory.Car.prototype = &#123; getPrice: function () &#123; return new Error(&quot;abstract&quot;); &#125;, getSpeed: function () &#123; return new Error(&quot;abstract&quot;); &#125;,&#125;;let BMW = function (price, speed) &#123; this.price = price; this.speed = speed;&#125;;VehicleFactory(BMW, &quot;Car&quot;); // interfaceBMW.prototype = &#123; getPrice: function () &#123; return this.price; &#125;, getSpeed: function () &#123; return this.speed; &#125;,&#125;;// for testlet myBmw = new BMW(10000, 100);console.log(myBmw.getPrice()); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// product interfaceinterface AbstractProductA &#123; functionA(): string;&#125;interface AbstractProductB &#123; /** * base operation * @return &#123;string&#125; */ functionA(): string; /** * inject some operation * @param &#123;AbstractProductA&#125; product * @return &#123;string&#125; */ functionB(product: AbstractProductA): string;&#125;// concrete productionclass ConcreteProductA1 implements AbstractProductA &#123; functionA(): string &#123; return &quot;This is functionA from ProductA1&quot;; &#125;&#125;class ConcreteProductA2 implements AbstractProductA &#123; functionA(): string &#123; return &quot;This is functionA from ProductA2&quot;; &#125;&#125;class ConcreteProductB1 implements AbstractProductB &#123; functionA(): string &#123; return &quot;This is functionA from ProductB1&quot;; &#125; functionB(product: AbstractProductA): string &#123; return &quot;Function B2: &quot; + product.functionA(); &#125;&#125;class ConcreteProductB2 implements AbstractProductB &#123; functionA(): string &#123; return &quot;This is functionA from ProductB2&quot;; &#125; functionB(product: AbstractProductA): string &#123; return &quot;Function B2: &quot; + product.functionA(); &#125;&#125;// factory interfaceinterface AbstractFactory &#123; createProductA(): AbstractProductA; createProductB(): AbstractProductB;&#125;// concrete factoryclass ConcreteFactory1 implements AbstractFactory &#123; createProductA(): AbstractProductA &#123; return new ConcreteProductA1(); &#125; createProductB(): AbstractProductB &#123; return new ConcreteProductB1(); &#125;&#125;class ConcreteFactory2 implements AbstractFactory &#123; createProductA(): AbstractProductA &#123; return new ConcreteProductA2(); &#125; createProductB(): AbstractProductB &#123; return new ConcreteProductB2(); &#125;&#125;// usage/** * use with different facotry. * @param &#123;AbstractFactory&#125; factory */function clientCode(factory: AbstractFactory) &#123; const productA = factory.createProductA(); const productB = factory.createProductB(); console.log(productB.functionA()); console.log(productB.functionB(productA));&#125;clientCode(new ConcreteFactory1());clientCode(new ConcreteFactory2());","tags":["学习"]},{"title":"继承","path":"/2019/07/09/继承/","content":"子类的原型对象-类式继承123456789101112131415161718192021// 类式继承// parentfunction SuperClass() &#123; this.superValue = true;&#125;SuperClass.prototype.getSuperValue = function () &#123; return this.superValue;&#125;;// childfunction SubClass() &#123; this.subValue = false;&#125;SubClass.prototype = new SuperClass();SubClass.prototype.getSubValue = function () &#123; return this.subValue;&#125;;let child = new SubClass()console.log(child.getSuperValue()); // trueconsole.log(child.getSubValue()); // false 创建即继承-构造函数继承1234567891011121314151617181920212223// parent function SuperClass(id) &#123; this.books = [&#x27;JavaScript&#x27;, &#x27;html&#x27;, &#x27;css&#x27;]; this.id = id;&#125;SuperClass.prototype.showBooks = function () &#123; console.log(this.books);&#125;// childfunction SubClass(id) &#123; SuperClass.call(this, id);&#125;var instance1 = new SubClass(10);var instance2 = new SubClass(20);instance1.books.push(&#x27;test&#x27;);instance2.books.shift()console.log(instance1.books);console.log(instance2.books);// instance1.showBooks(); // Type Error 组合继承12345678910111213141516171819202122// parentfunction SuperClass(name) &#123; this.name = name; this.books = [&#x27;JavaScript&#x27;, &#x27;html&#x27;, &#x27;css&#x27;];&#125;SuperClass.prototype.getName = function () &#123; console.log(this.name);&#125;;// childfunction SubClass(name, time) &#123; SuperClass.call(this, name); this.time = time;&#125;SubClass.prototype = new SuperClass();SubClass.prototype.getTime = function () &#123; console.log(this.time);&#125;;var instance1 = new SubClass(&#x27;js book&#x27;, 1998);var instance2 = new SubClass(&#x27;css book&#x27;, 2003);instance1.getName(); 原型式继承1234567891011121314151617181920function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var book = &#123; name: &#x27;JavaScript&#x27;, alikeBook: [&#x27;css book&#x27;, &#x27;html&#x27;]&#125;;var newBook = inheritObject(book);newBook.name = &#x27;ajax&#x27;;newBook.alikeBook.push(&#x27;xml&#x27;);var otherBook = inheritObject(book);otherBook.name = &#x27;flash&#x27;;otherBook.alikeBook.push(&#x27;as&#x27;);console.log(newBook.name);console.log(newBook.alikeBook); // 引用类型的属性共享 寄生式继承1234567891011121314151617181920212223function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;// base objectvar book = &#123; name: &#x27;js&#x27;, alikeBook: [&#x27;css&#x27;, &#x27;html&#x27;]&#125;;function createBook(obj) &#123; var o = inheritObject(obj); o.getName = function() &#123; console.log(this.name); &#125; return o;&#125;let books = createBook(book)books.getName() 寄生组合式继承1234567891011121314151617181920212223242526272829303132333435function inheritObject(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subClass, superClass) &#123; var p = inheritObject(superClass.prototype); p.constuctor = subClass; subClass.prototype = p;&#125;// for testfunction SuperClass(name) &#123; this.name = name; this.nums = [1, 2, 3];&#125;SuperClass.prototype.getName = function () &#123; console.log(this.name);&#125;;function SubClass(name, time) &#123; SuperClass.call(this, name); this.time = time;&#125;inheritPrototype(SubClass, SuperClass);SubClass.prototype.getTime = function () &#123; console.log(this.time);&#125;var instance1 = new SubClass(&#x27;js book&#x27;, 202);instance1.nums.push(30);var instance2 = new SubClass(&#x27;css book&#x27;, 222);console.log(instance1.nums);console.log(instance2.nums); 多继承123456789101112131415161718192021Object.prototype.mix = function () &#123; let len = arguments.length; for (let i = 0; i &lt; len; i++) &#123; let arg = arguments[i]; for (let property in arg) &#123; this[property] = arg[property]; &#125; &#125;&#125;let book1 = &#123; name: &#x27;JavaScript&#x27;&#125;;let book2 = &#123; price: 34&#125;;let book3 = &#123; foo: &#x27;haha&#x27;&#125;;book3.mix(book1, book2);console.log(book3);","tags":["学习"]},{"title":"HTTP cookies","path":"/2019/05/27/HTTP-cookies/","content":"set-cookie1Set-cookie: value[; expires=date][; domain=domain][; path=path][; secure] 每个选项都是用分号和空格来分开，每个选项都制定了 cookie 在什么情况下会发送给服务器 过期时间选项 expires: 指定了 cookie 最长存储时间，过期后会被浏览器删除。值是一个 date ，格式为 WDY, DD-mm-YYYY HH:MM:SS GMT。 没有设置 expires 选项时，默认为当前会话，所设置的 cookie 在关闭浏览器时会被删除。 1Set-cookie: name=Jack; expires=Tue, 28 May 2019 22:33:22 GMT domain选项 domain: 指定了 cookie 将要被发给哪个域中。 默认情况下会被设置为当前域。 值必须是消息头主机的一部分，不合法的 domain 会直接被忽略。 1Set-cookie: name=Jack; domain=baidu.com path选项 path: 指定了请求资源的 URL 中存在指定路径时，才会发送 cookie。 只有对 domain 匹配成功后才会开始匹配 path 部分。 1Set-cookie: name=Jack; domain=baidu.com; path=/ secure选项 secure: 只是一个标记，当请求通过 SSL 或者 HTTPS 创建时，包含 secure 的 cookie 才会被发送至服务器。 默认情况下， HTTPS 上传输的 cookie 都会被自动加上 secure 选项。 1Set-cookie: name=Jack; secure HTTPOnly选项 HttpOnly: 禁止浏览器通过 JavaScript 来获取 cookie ，防止 XSS 攻击。 这个属性也不能通过 JavaScript 来设置。1Set-cookie: name=Jack; HttpOnly cookie自动删除 会话结束。 超过过期时间。 cookie 数量达到限制，删除部分 cookie 以便为新创建的 cookie 腾出空间。 JavaScript读取cookie可以使用document.cookie来读取 cookie 的值。","tags":["整理"]},{"title":"Linux通信机制 作业","path":"/2019/05/26/Linux通信机制-作业/","content":"要求 程序1从串口读取信息，然后发到消息队列中。使用2个终端运行程序1，创建出2个可从串口读取数据的进程，串口可以使用Windows中的虚拟串口，使用串口助手输入信息。 程序2从消息队列中读取消息，然后在屏幕上将消息内容显示出来。 提交形式 代码 运行结果截图、串口助手截图 Code1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define BUFFER_SIZE 512typedef struct _message &#123; long msg_type; char msg_text[BUFFER_SIZE];&#125; message; 12345678910111213141516171819202122#include &quot;common.h&quot;int main() &#123; int qid; key_t key; message msg; key = ftok(&quot;.&quot;, &#x27;a&#x27;); qid = msgget(key, IPC_CREAT | 0666); do &#123; memset(msg.msg_text, 0, BUFFER_SIZE); msgrcv(qid, (void*)&amp;msg, BUFFER_SIZE, 0, 0); printf(&quot;%s&quot;, msg.msg_text); &#125; while (1); msgctl(qid, IPC_RMID, NULL); exit(0);&#125; 1234567891011121314151617181920212223242526272829303132333435363738#include &quot;common.h&quot;int main() &#123; int qid, fd; key_t key; message msg; char buff[BUFFER_SIZE]; key = ftok(&quot;.&quot;, &#x27;a&#x27;); if (key == -1) &#123; perror(&quot;ftok error&quot;); exit(1); &#125; qid = msgget(key, IPC_CREAT | 0666); if (qid == -1) &#123; perror(&quot;msgget error.&quot;); exit(1); &#125; fd = open(&quot;/dev/ttyS1&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open error.&quot;); exit(1); &#125; read(fd, buff, BUFFER_SIZE); strncpy(msg.msg_text, buff, strlen(buff)); msg.msg_type = getpid(); int size = msgsnd(qid, &amp;msg, strlen(msg.msg_text), 0); if (size &lt; 0) &#123; perror(&quot;message posted.&quot;); exit(1); &#125; exit(0);&#125;","tags":["Linux"]},{"title":"6.006 - 9","path":"/2019/05/22/6-006-9/","content":"Rabin-Karp12345678910111213141516171819202122232425262728293031323334353637class Rabin_Karp &#123; constructor(str) &#123; this._origin = str.split(&#x27;&#x27;); this._len = str.length; &#125; matchResult(str) &#123; let result = [], hash = this._hash(str), strLen = str.split(&#x27;&#x27;).length; console.log(strLen); for (let i = 0, len = this._len - strLen + 1; i &lt; len; i++) &#123; let tmp = this._origin.slice(i, i + strLen).join(&#x27;&#x27;); if (hash === this._hash(tmp) &amp;&amp; this._compare(str, tmp)) &#123; result.push(i); &#125; &#125; return result; &#125; _hash(string) &#123; // DJB hash let hash = 5381; string.toString().split(&#x27;&#x27;).map(i =&gt; hash = ((hash &lt;&lt; 5) + hash) + i.charCodeAt(0)); return hash; &#125; _compare(arr1, arr2) &#123; for (let i = 0, len = arr1.length; i &lt; len; i++) &#123; if (arr1[i] != arr2[i]) return false; &#125; return true; &#125;&#125;let matching = new Rabin_Karp(&#x27;tetesteestfdjklsajtest2tese3trtessstest&#x27;);console.log(matching.matchResult(&#x27;test&#x27;)); result: 1Array(3) [2, 18, 35]","tags":["算法"]},{"title":"6.006 - 8","path":"/2019/05/22/6-006-8/","content":"Hash Table - Table Doubling123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Hash_Table &#123; constructor(size = 8) &#123; this.data = []; this._count = 0; this._size = size; &#125; _hash(str, num) &#123; let hash = 0; str.split(&#x27;&#x27;).map(i =&gt; &#123; hash = (hash &lt;&lt; 5) + i.charCodeAt(0); hash = (hash &amp; hash) % num; &#125;); return hash; &#125; insert(key, value) &#123; let index = this._hash(key, this._size), modify = false, blank = this.data[index]; if (!blank) this.data[index] = (blank = []); blank.map(i =&gt; &#123; if (i[0] === key) &#123; i[1] === value; modify = true; &#125; &#125;); if (!modify) &#123; blank.push([key, value]); this._count++; if (this._count &gt; this.size * 0.75) &#123; this.resize(this.size * 2); &#125; &#125; &#125; _resize(newSize) &#123; let oldData = this.data; this._size = newSize; this._count = 0; this.data = []; oldData.map(i =&gt; &#123; if (!i) return; for (let j = 0; j &lt; i.length; j++) &#123; this.insert(i[j][0], i[j][1]); &#125; &#125;); &#125; remove(key) &#123; let index = this._hash(key, this._size); let current = this.data[index]; if (!current) return null; current.map((i, index) =&gt; &#123; if (i[0] === key) &#123; current.splice(index, 1); this._count--; if (this._count &lt; this._size * 0.25) &#123; this._resize(this._size / 2); &#125; return i[1]; &#125; &#125;); &#125; traverse(key) &#123; let index = this._hash(key, this._size), current = this.data[index]; if (!current) return null; let result = current.filter(i =&gt; i[0] == key)[0] return result === undefined ? null : result[1]; &#125; traverseALl() &#123; console.log(this.data); &#125;&#125;var addressBook = new Hash_Table();addressBook.insert(&#x27;Wendy&#x27;, &#x27;220-02-33&#x27;);addressBook.insert(&#x27;GilesYvette&#x27;, &#x27;746-71-84&#x27;);addressBook.insert(&#x27;Pollitt&#x27;, &#x27;374-34-48&#x27;)addressBook.insert(&#x27;AbeLinda&#x27;, &#x27;040-17-82&#x27;)addressBook.insert(&#x27;StracheyPayne&#x27;, &#x27;129-35-33&#x27;)addressBook.insert(&#x27;JonahIrene&#x27;, &#x27;709-98-46&#x27;);addressBook.insert(&#x27;DorisAngela&#x27;, &#x27;205-74-43&#x27;)addressBook.insert(&#x27;ThoreauTess&#x27;, &#x27;946-62-95&#x27;)addressBook.insert(&#x27;HaggaiFanny&#x27;, &#x27;147-68-09&#x27;);addressBook.insert(&#x27;KentCuritis&#x27;, &#x27;095-94-11&#x27;)addressBook.insert(&#x27;CecilliaFrederica&#x27;, &#x27;273-72-73&#x27;)addressBook.insert(&#x27;HazlittFranklin&#x27;, &#x27;107-49-37&#x27;);addressBook.remove(&#x27;AbeLinda&#x27;);addressBook.remove(&#x27;Pollitt&#x27;);addressBook.traverseALl();console.log(addressBook.traverse(&#x27;CecilliaFrederica&#x27;));console.log(addressBook.traverse(&#x27;Pollitt&#x27;));console.log(addressBook.traverse(&#x27;HaggaiFanny&#x27;));console.log(addressBook.traverse(&#x27;ThoreauTess&#x27;));console.log(addressBook.traverse(&#x27;DorisAngela&#x27;)); result: 123456Array(7) […, Array(4), …, Array(2), Array(0), Array(3), Array(1)]273-72-73null147-68-09946-62-95205-74-43","tags":["算法"]},{"title":"6.006 - 7","path":"/2019/05/21/6-006-7/","content":"Hash Table - Hashing with ChainingIncredibly, the Array.prototype.fill will fill each item with the same Object. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Node &#123; constructor(value) &#123; this.next = null; this.value = value; &#125;&#125;class Hash_Table &#123; constructor(size = 16) &#123; this.size = size; this.data = new Array(this.size); // this.data.fill(&#123; next: null &#125;); for (let i = 0; i &lt; this.size; i++) &#123; this.data[i] = &#123; next: null &#125;; &#125; &#125; _hash(string) &#123; // DJB hash let hash = 5381; string.toString().split(&#x27;&#x27;).map(i =&gt; hash = ((hash &lt;&lt; 5) + hash) + i.charCodeAt(0)); return hash; &#125; insert(key, value) &#123; let pointer = this.data[this._hash(key) % this.size]; if (!pointer.next) &#123; pointer.next = new Node(value); &#125; else &#123; while (pointer.next) &#123; pointer = pointer.next; if (pointer.value === value) return; &#125; pointer.next = new Node(value); &#125; &#125; get(key) &#123; let pointer = this.data[this._hash(key) % this.size], result = []; if (!pointer.next) return new Error(&#x27;Doesn\\&#x27;t exist.&#x27;); else &#123; do &#123; pointer = pointer.next; result.push(pointer.value); &#125; while (pointer.next); return result; &#125; &#125; delete(key) &#123; this.data[this._hash(key) % this.size] = &#123; next: null &#125;; &#125;&#125;let hash = new Hash_Table();hash.insert(&#x27;test&#x27;, 3);hash.insert(&#x27;test&#x27;, 5);hash.insert(&#x27;test&#x27;, 5);hash.insert(&#x27;test&#x27;, 6);hash.insert(12, 44);hash.insert(11, 3);hash.insert(10, 3);console.log(hash.get(&#x27;test&#x27;));hash.delete(12);console.log(hash.get(12)); result: 12Array(3) [3, 5, 6]Error: Doesn&#x27;t exist.","tags":["算法"]},{"title":"6.006 - 6","path":"/2019/05/21/6-006-6/","content":"Simplify Hash Table12345678910111213141516171819202122232425262728293031323334353637383940class Node &#123; constructor(value) &#123; this.next = null; this.value = value; &#125;&#125;class Hash_Table &#123; constructor() &#123; this.size = 1024; this.data = new Array(this.size); &#125; _hash(string) &#123; // DJB hash let hash = 5381; string.toString().split(&#x27;&#x27;).map(i =&gt; hash = ((hash &lt;&lt; 5) + hash) + i.charCodeAt(0)); return hash; &#125; insert(key, value) &#123; this.data[this._hash(key) % this.size] = value; &#125; get(key) &#123; let value = this.data[this._hash(key) % this.size]; return value === undefined ? new Error(&#x27;Doesn\\&#x27;t exist.&#x27;) : value; &#125; delete(key) &#123; this.data[this._hash(key) % this.size] = undefined; &#125;&#125;let hash = new Hash_Table();hash.insert(&#x27;test&#x27;, 3);console.log(hash.get(&#x27;test&#x27;));hash.delete(&#x27;test&#x27;);console.log(hash.get(&#x27;test&#x27;));hash.insert(12, 44);console.log(hash.get(12)); result: 1233Error: Doesn&#x27;t exist.44","tags":["算法"]},{"title":"6.006 - 5","path":"/2019/05/20/6-006-5/","content":"AVL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153class Node &#123; constructor(key) &#123; this.key = key; this.leftChild = null; this.rightChild = null; &#125;&#125;class AVL &#123; constructor() &#123; this.root = null; this.parent = null; this.deleted = null; &#125; getRoot() &#123; return this.root; &#125; _heightNode(node) &#123; return node === null ? -1 : Math.max(this._heightNode(node.leftChild), this._heightNode(node.rightChild)) + 1; &#125; _rotationLeftLeft(node) &#123; let tmp = node.leftChild; node.leftChild = tmp.rightChild; tmp.rightChild = node; return tmp; &#125; _rotationRightRight(node) &#123; let tmp = node.rightChild; node.rightChild = tmp.leftChild; tmp.leftChild = node; return tmp; &#125; _rotationLeftRight(node) &#123; node.leftChild = this._rotationRightRight(node.leftChild); return this._rotationLeftLeft(node); &#125; _rotationRightLeft(node) &#123; node.rightChild = this._rotationLeftLeft(node.rightChild); return this._rotationRightRight(node); &#125; _insertNode(node, value) &#123; if (node === null) &#123; node = new Node(value); // put the node &#125; else if (value &lt; node.key) &#123; node.leftChild = this._insertNode(node.leftChild, value); if (node.leftChild !== null) &#123; if (this._heightNode(node.leftChild) - this._heightNode(node.rightChild) &gt; 1) &#123; // check the height if (value &lt; node.leftChild.key) &#123; node = this._rotationLeftLeft(node); &#125; else &#123; node = this._rotationLeftRight(node); &#125; &#125; &#125; &#125; else if (value &gt; node.key) &#123; node.rightChild = this._insertNode(node.rightChild, value); if (node.rightChild !== null) &#123; if (this._heightNode(node.rightChild) - this._heightNode(node.leftChild) &gt; 1) &#123; // check the height if (value &gt; node.rightChild.key) &#123; node = this._rotationRightRight(node); &#125; else &#123; node = this._rotationRightLeft(node); &#125; &#125; &#125; &#125; return node; &#125; insert(value) &#123; this.root = this._insertNode(this.root, value); &#125; _removeNode(node, value) &#123; if (node === null) return node; this.parent = node; if (value &lt; node.key) &#123; node.leftChild = _removeNode(node.leftChild, value); &#125; else &#123; this.deleted = node; node.rightChild = _removeNode(node.rightChild, value); &#125; if (node === this.parent) &#123; if (this.deleted !== null &amp;&amp; value === this.deleted.key) &#123; if (this.deleted === this.parent) &#123; node = node.leftChild; &#125; else &#123; [this.deleted.key, this.parent.key] = [this.parent.key, this.deleted.key]; node = node.rightChild; &#125; &#125; &#125; else &#123; if (this._heightNode(node.leftChild) - this._heightNode(node.rightChild) === 2) &#123; if (value &lt; node.leftChild.key) &#123; node = this._rotationLeftRight(node); &#125; else &#123; node = this._rotationLeftLeft(node); &#125; &#125; if (this._heightNode(node.rightChild) - this._heightNode(node.leftChild) === 2) &#123; if (value &gt; node.rightChild.key) &#123; node = this._rotationRightLeft(node); &#125; else &#123; node = this._rotationRightRight(node); &#125; &#125; &#125; return node; &#125; remove(value) &#123; this.parent = null; this.deleted = null; this.root = this._removeNode(this.root, value); &#125; inOrderTraverse() &#123; this._inOrderTraverse(this.root); &#125; _inOrderTraverse(node) &#123; if (node) &#123; this._inOrderTraverse(node.leftChild); console.log(node.key); this._inOrderTraverse(node.rightChild); &#125; &#125;&#125;let avl = new AVL();avl.insert(6);avl.insert(7);avl.insert(14);avl.insert(15);avl.insert(13);console.log(avl.getRoot());avl.inOrderTraverse(); result: 123456Node &#123;key: 7, leftChild: Node, rightChild: Node&#125;67131415","tags":["算法"]},{"title":"Some Lists","path":"/2019/05/20/Some-Lists/","content":"TV series Game of Thrones WestWorld Chernobyl Fantasmagorias Love, Death &amp; Robots Music King Boomba’s Crew - Edison Chen&#x2F;MC Hotdog Woman27 - MC Hotdog 贫民百万歌星 - MC Hotdog 差不多先生 - MC Hotdog 毒 - MC Hotdog 嘿嘿Taxi - MC Hotdog 十三号天使 - MC Hotdog 轻熟女27 - MC Hotdog 烦死人 - MC Hotdog 1999 - Charli XCX&#x2F;Troye Sivan Nothing on you - Bruno Mars&#x2F;B.o.B Mr.Sandman - Edison Chen Salute - Edsion Chen 金翅鸟2012 - MC仁 Stuttering - Fefe Dobson Friend Like Me(End Title) - Will Smith&#x2F;DJ Khaled Prince Ali - Will Smith 少女的祈祷 - 杨千嬅 浪子回头 - 茄子蛋 年少有为 - 李荣浩 Movies Aladdin - 2019","tags":["整理"]},{"title":"Linux进程通信 作业","path":"/2019/05/20/Linux进程通信-作业/","content":"有名管道 父进程创建一个有名管道，然后创建1个子进程，父进程阻塞的方式等待有名管道的信息，当读取到信息之后，在屏幕上打印出来；当从有名管道中读取到“QUIT”之后，父进程终止。 子进程1使用定时器，每5秒钟向有名管道输入“this is process 1”；当收到信号SIGQUIT时，向有名管道输出“QUIT”，并在屏幕上输出“process 1 exit”之后，进程终止。 提交形式 代码 运行结果截图 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;signal.h&gt;#define FIFO &quot;/tmp/fifo&quot;#define MAX_BUFFER_SIZE PIPE_BUFpid_t pid, pr;char buff[MAX_BUFFER_SIZE];void child_func(int sign_no) &#123; if (sign_no == SIGALRM) &#123; int fdChild = open(FIFO, O_WRONLY); if (fdChild == -1) &#123; printf(&quot;Open fifo file error &quot;); exit(1); &#125; sscanf(&quot;this is progress 1 &quot;, &quot;%[^ ]&quot;, buff); write(fdChild, buff, MAX_BUFFER_SIZE); close(fdChild); &#125; else if (sign_no == SIGQUIT) &#123; int fdChild = open(FIFO, O_WRONLY); if (fdChild == -1) &#123; printf(&quot;Open fifo file error &quot;); exit(1); &#125; sscanf(&quot;QUIT &quot;, &quot;%[^ ]&quot;, buff); write(fdChild, buff, MAX_BUFFER_SIZE); close(fdChild); printf(&quot;process 1 exit. &quot;); exit(0); &#125;&#125;int main() &#123; pid = fork(); if (pid &lt; 0) &#123; printf(&quot;Fork error &quot;); exit(1); &#125; else if (pid == 0) &#123; // child thread signal(SIGALRM, child_func); // handle SIG_ALARM signal(SIGQUIT, child_func); // handle SIGQUIT while (1) &#123; alarm(5); // ALARM SIGN sleep(5); &#125; &#125; else &#123; // parent thread if (access(FIFO, F_OK) == -1) &#123; // if unexist then create if ((mkfifo(FIFO, 0666) &lt; 0) &amp;&amp; errno != EEXIST) &#123; printf(&quot;Cannot create fifo file &quot;); exit(1); &#125; &#125; int fdParent = open(FIFO, O_RDONLY); if (fdParent == -1) &#123; printf(&quot;Open fifo file error &quot;); exit(1); &#125; do &#123; signal(SIGQUIT, child_func); // handle the SIGQUIT from parent thread pr = waitpid(pid, NULL, WNOHANG); memset(buff, 0, sizeof(buff)); // reset the buff read(fdParent, buff, MAX_BUFFER_SIZE); // read buff if (strcmp(&quot;&quot;, buff) == 0) continue; if (strcmp(&quot;QUIT&quot;, buff) == 0) exit(0); // if buff equals &quot;QUIT&quot; then quit printf(&quot;%s &quot;, buff); sleep(1); &#125; while (pr == 0); close(fdParent); &#125; exit(0);&#125; 信号量机制 一个海底隧道中只有一个车道，规定同一个方向的可以连续过隧道；某方向有列车过隧道时，另一个方向的列车就要等待，现在东岸和西岸都有列车要过隧道，如果把每个过隧道的列车看作一个进程，为保证安全，使用信号量机制实现正确管理。 使用屏幕输出信息，来表示列车通行情况。 提交形式 代码 运行结果截图 Code12345678910111213141516171819202122232425262728293031323334#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; pid_t A; int sem_id; sem_id = semget(ftok(&quot;.&quot;, &#x27;a&#x27;), 1, 0666 | IPC_CREAT); init_sem(sem_id, 1); A = fork(); if (A == -1) &#123; perror(&quot;Fork error &quot;); exit(1); &#125; else if (A == 0) &#123; while (1) &#123; sem_p(sem_id); printf(&quot;A -&gt; B &quot;); sem_v(sem_id); &#125; &#125; else &#123; while (1) &#123; sem_p(sem_id); printf(&quot;B -&gt; A &quot;); sem_v(sem_id); &#125; &#125; del_sem(sem_id); exit(0);&#125; 12345union semun &#123; int val; struct semid_ds* buf; unsigned short* array;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;sem_com.h&quot;#include &lt;sys/sem.h&gt;int init_sem(int sem_id, int init_value) &#123; union semun sem_union; sem_union.val = init_value; if (semctl(sem_id, 0, SETVAL, sem_union) == -1) &#123; perror(&quot;Initialize semaphore&quot;); return -1; &#125; return 0;&#125;int del_sem(int sem_id) &#123; union semun sem_union; if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1) &#123; perror(&quot;Delete semaphore&quot;); return -1; &#125; return 0;&#125;int sem_p(int sem_id) &#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P operation&quot;); return -1; &#125; return 0;&#125;int sem_v(int sem_id) &#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;V operation&quot;); return -1; &#125; return 0;&#125;","tags":["Linux"]},{"title":"Linux多线程 作业","path":"/2019/05/20/Linux多线程-作业/","content":"要求父进程创建3个进程，父进程等待子进程2运行完成之后，自行退出；其中子进程1运行系统命令“cp &#x2F;bin&#x2F;ls &#x2F;tmp”；等待2秒后退出；子进程2使用标准I&#x2F;O函数打开文件src_file，向其内写入“this is process 2 ”，之后等待5秒后退出；子进程3处理为守护进程，每隔5秒向日志文件&#x2F;var&#x2F;log&#x2F;messages写入“this is process 3 ” 提交形式 代码 运行结果截图 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t child, child1, child2, daemon; int i, fd, sid; char* message1 = &quot;this is a process 2. &quot;; char* message2 = &quot;this is a process 3. &quot;; child1 = fork(); if (child1 &lt; 0) &#123; printf(&quot;Child1 fork error. &quot;); exit(1); &#125; else if (child1 == 0) &#123; // child1 thread if (execlp(&quot;cp&quot;, &quot;cp&quot;, &quot;/bin/ls&quot;, &quot;/tmp&quot;, NULL) &lt; 0) &#123; printf(&quot;Child1&quot;); &#125; sleep(2); exit(0); &#125; else &#123; // father thread child2 = fork(); if (child2 == -1) &#123; printf(&quot;Child2 fork error. &quot;); exit(1); &#125; else if (child2 == 0) &#123; // child2 thread if ((fd = open(&quot;./src_file&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; printf(&quot;Open file error. &quot;); exit(1); &#125; write(fd, message1, strlen(message1) + 1); sleep(5); exit(0); &#125; do &#123; child = waitpid(child1, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child1 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); do &#123; child = waitpid(child2, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child2 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); daemon = fork(); // fork daemon openlog(&quot;test_syslog&quot;, LOG_PID, LOG_DAEMON); // open syslog if (daemon &lt; 0) &#123; printf(&quot;Daemon fork error. &quot;); exit(1); &#125; else if (daemon &gt; 0) &#123; exit(0); // father thread exit &#125; if ((sid = setsid()) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;setsid&quot;); exit(1); &#125; if ((sid = chdir(&quot;/&quot;)) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;chdir&quot;); exit(1); &#125; // start make daemon thread umask(0); for (i = 0; i &lt; getdtablesize(); i++) &#123; close(i); &#125; while (1) &#123; // start run daemon thread if ((fd = open(&quot;/var/log/message&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; // get the fildes syslog(LOG_ERR, &quot;open&quot;); exit(1); &#125; write(fd, message2, strlen(message2) + 1); close(fd); sleep(5); &#125; closelog(); exit(0); &#125; exit(0);&#125;","tags":["Linux"]},{"title":"6.006 - 4","path":"/2019/05/15/6-006-4/","content":"BST123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145class Node &#123; constructor(value) &#123; this.data = value; this.leftChild = null; this.rightChild = null; &#125;&#125;class BST &#123; constructor() &#123; this.root = null; &#125; insert(value) &#123; let node = new Node(value); if (!this.root) &#123; this.root = node; return; &#125; this._insertNode(this.root, node); &#125; min() &#123; return this._findMin(this.root); &#125; _findMin(node) &#123; if (!node) return null; while (node.leftChild) node = node.leftChild; return node; &#125; max() &#123; return this._findMax(this.root); &#125; _findMax(node) &#123; if (!node) return null; while (node.rightChild) node = node.rightChild; return node; &#125; remove(data) &#123; this.root = this._remove(this.root, data); &#125; _remove(node, key) &#123; if (!node) return null; if (key &lt; node.data) &#123; node.leftChild = this._remove(node.leftChild, key); return node; &#125; else if (key &gt; node.data) &#123; node.rightChild = this._remove(node.rightChild, key); return node; &#125; else &#123; if (node.leftChild === null &amp;&amp; node.rightChild === null) &#123; node = null; return node; &#125; else if (node.rightChild === null) &#123; node = node.leftChild; return node; &#125; else if (node.leftChild === null) &#123; node = node.rightChild; return node; &#125; let min = this._findMin(node.rightChild); node.data = min.data; node.rightChild = this._remove(node.rightChild, min.data); return node; &#125; &#125; _insertNode(node, newNode) &#123; if (newNode.data &lt; node.data) &#123; if (node.leftChild === null) node.leftChild = newNode; else this._insertNode(node.leftChild, newNode); &#125; else &#123; if (node.rightChild === null) node.rightChild = newNode; else this._insertNode(node.rightChild, newNode); &#125; &#125; preOrderTraverseTree() &#123; this._preOrderTraverse(this.root); &#125; _preOrderTraverse(node) &#123; if (node) &#123; console.log(node.data); this._preOrderTraverse(node.leftChild); this._preOrderTraverse(node.rightChild); &#125; &#125; inOrderTraverseTree() &#123; this._inOrderTraverse(this.root); &#125; _inOrderTraverse(node) &#123; if (node) &#123; this._inOrderTraverse(node.leftChild); console.log(node.data); this._inOrderTraverse(node.rightChild); &#125; &#125; postOrderTraverseTree() &#123; this._postOrderTraverse(this.root); &#125; _postOrderTraverse(node) &#123; if (node) &#123; this._postOrderTraverse(node.leftChild); this._postOrderTraverse(node.rightChild); console.log(node.data); &#125; &#125;&#125;let bst = new BST();bst.insert(2);bst.insert(3);bst.insert(1);bst.insert(-1);bst.insert(5);bst.insert(-2);// bst.preOrderTraverseTree();bst.inOrderTraverseTree();// bst.postOrderTraverseTree();console.log(bst.min());console.log(bst.max());bst.remove(2);bst.inOrderTraverseTree(); result: 123456789101112-2-1125Node &#123;data: -2, leftChild: null, rightChild: null&#125;Node &#123;data: 5, leftChild: null, rightChild: null&#125;-2-1135","tags":["算法"]},{"title":"6.006 - 3","path":"/2019/05/15/6-006-3/","content":"about the heap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Heap &#123; constructor(arr) &#123; this.data = arr.reduce((arr, elem) =&gt; &#123; arr.push(elem); return arr; &#125;, []); this.size = this.data.length; &#125; isEmpty() &#123; return this.size === 0; &#125; build_max_heap() &#123; if (this.size &lt;= 1) return; for (let i = Math.floor(this.size / 2); i &gt;= 0; i--) &#123; // start from the n / 2 because of the elem after n / 2 are all leaves this.max_heapify(i); &#125; &#125; sort() &#123; let result = []; while (!this.isEmpty()) &#123; result.push(this.data.shift()); // pop the max this.size--; this.build_max_heap(); // rebuild the heap &#125; this.data = result; this.size = result.length; &#125; add(value) &#123; this.data.push(value); this.size++; this.build_max_heap(); &#125; max_heapify(current) &#123; let left = 2 * current, // get the left child right = 2 * current + 1, // get the right child largest = current; // get the max node if (left &lt; this.size &amp;&amp; this.data[left] &gt; this.data[largest]) largest = left; // left child is max if (right &lt; this.size &amp;&amp; this.data[right] &gt; this.data[largest]) largest = right; // right child is max if (largest !== current) &#123; // if the max node is not the current node [this.data[largest], this.data[current]] = [this.data[current], this.data[largest]]; // swap the value this.max_heapify(largest); // recursive to check the modify child heap if is max heapify &#125; &#125; print() &#123; let str = &#x27;&#x27;; this.data.map(i =&gt; str += i + &#x27; &#x27;); console.log(str); &#125;&#125;let heap = new Heap([1, 2, 3, 6, 4, 5, 9, 8, 11, 14]);heap.build_max_heap();heap.print();heap.sort();heap.print();heap.add(30);heap.add(12);heap.print();heap.sort();heap.print(); result: 123414 11 5 9 4 1 6 8 3 214 11 9 8 6 5 4 3 2 130 14 12 8 6 11 4 3 2 1 5 930 14 12 11 9 8 6 5 4 3 2 1","tags":["算法"]},{"title":"6.006 - 2","path":"/2019/05/15/6-006-2/","content":"sort123456789101112131415161718192021/** * sort array * @param &#123;Array&lt;number&gt;&#125; arr * @returns &#123;Array&lt;number&gt;&#125; */let sort = arr =&gt; &#123; for (let i = 1, len = arr.length; i &lt; len ; i++) &#123; let j = i; while (arr[j] &lt; arr[j - 1]) &#123; [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; if (j == 1) break; j--; &#125; &#125; return arr;&#125;let arr = [5, 2, 4, 6, 1, 3];console.log(sort(arr)); result:1 2 3 4 5 6","tags":["算法"]},{"title":"6.006 - 1","path":"/2019/05/14/6-006-1/","content":"find the peak.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Find the peek 1D * @param &#123;Array&lt;number&gt;&#125; arr arr * @param &#123;number&#125; i the index to start * @param &#123;number&#125; j the index to end * @returns &#123;number&#125; the peak */let findThePeak = (arr, i, j) =&gt; &#123; let current = parseInt((i + j) / 2); if (arr[current] &lt; arr[current + 1]) return findThePeak(arr, current, j); else if (arr[current] &lt; arr[current - 1]) return findThePeak(arr, i, current); else return arr[current];&#125;/** * Find the peak 2D * @param &#123;Array&lt;Array&lt;number&gt;&gt;&#125; arr the Number[][] array * @param &#123;number&#125; start start row * @param &#123;number&#125; end end row * @returns &#123;number&#125; the peak of the array */let findThePeak2 = (arr, start, end) =&gt; &#123; let current = parseInt((start + end) / 2); let rowMax = findThePeak(arr[current], 0, arr[current].length); // get the index of column // let i = arr[current].indexOf(rowMax) let i = arr[current].map((i, index) =&gt; i === rowMax &amp;&amp; index).filter(i =&gt; i !== false)[0]; if (current - 1 &gt;= 0 &amp;&amp; arr[current][i] &lt; arr[current - 1][i]) &#123; // check the left part return findThePeak2(arr, start, current); &#125; else if (current &lt; end - 1 &amp;&amp; arr[current][i] &lt; arr[current + 1][i]) &#123; // check the right part return findThePeak2(arr, current, end); &#125; else &#123; return rowMax; &#125;&#125;let arr = [5, 4, 3, 2, 4, 5, 6, ];let arr2 = [ [6, 3, 8], [3, 2, 1], [4, 6, 1]];console.log(findThePeak(arr, 0, arr.length));console.log(findThePeak2(arr2, 0, arr2.length)); result:6 8","tags":["算法"]},{"title":"document.cookie","path":"/2019/05/06/document-cookie/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041/** * set the cookie * @param &#123;String&#125; name * @param &#123;String&#125; value * @param &#123;Number&#125; day */let setCookie = (name, value, day) =&gt; &#123; let date = new Date(); date.setDate(date.getDate() + day); document.cookie = name + &#x27;=&#x27; + value + &#x27;;expires=&#x27; + date;&#125;/** * get the cookie by name * @param &#123;String&#125; name */let getCookie = name =&gt; &#123; let str = document.cookie.split(&#x27;; &#x27;).filter(i =&gt; &#123; let result = i.split(&#x27;=&#x27;) return result[0] == name &#125;); return str.length ? str[0].split(&#x27;=&#x27;)[1] : &#x27;&#x27;;&#125;/** * check user */let checkCookie = () =&gt; &#123; let username = document.cookie ? getCookie(&#x27;username&#x27;) : &#x27;&#x27;; if (username != &#x27;&#x27;) &#123; alert(&#x27;Welcome &#x27; + username); &#125; else &#123; username = prompt(&#x27;please input your username&#x27;); if (username &amp;&amp; username != &#x27;&#x27;) &#123; setCookie(&#x27;username&#x27;, username, 7); &#125; &#125;&#125;checkCookie()console.log(getCookie(&#x27;username&#x27;));","tags":["整理"]},{"title":"Linux基本命令","path":"/2019/04/23/Linux基本命令/","content":"Linux常用命令 man: an interface to the on-line reference manuals su [options] [username]: change user ID or become superuser useradd [options] LOGIN: create a new user or update default new user information userdel [options] LOGIN: delete a user account and related files passwd [options] [LOGIN]: change user password ps [options]: report a snapshot of the current process. kill [options] […]: send a signal to a process fdisk [options] device: manipulate disk partition table mount: mount a filesystem chown [OPTION] … [OWNER][:[GROUP]] FILE …: change file owner and group chgrp [OPTION] … GROUP FILE …: change group ownership chmod [OPTION] … MODE[,MODE] … FILE …: change file mode bits grep [OPTION] PATTERN [FILE…]: print lines matching a pattern find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point…] [expression]: search for files in a directory hierarchy ln: make links between files gzip, gunzip, zcat: compress or expand files tar: an archiving utility diff [OPTION] … FILES: compare files line by line patch -pnum &lt; patchfile: apply a diff file to an original ifconfig: configure a network interface","tags":["整理","Linux"]},{"title":"Haskell 命令行参数","path":"/2019/04/22/Haskell-命令行参数/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344import System.Environmentimport System.Directoryimport System.IOimport Data.Listmain = do (command:args) &lt;- getArgs -- get the command let (Just action) = lookup command dispatch -- find the command action args -- do somethingadd :: [String] -&gt; IO ()add [fileName, todoItem] = appendFile fileName (todoItem ++ &quot; &quot;) -- add the todoItemview :: [String] -&gt; IO ()view [fileName] = do -- match the filename contents &lt;- readFile fileName -- read the file let todoTasks = lines contents -- get the contents numberedTasks = zipWith ( line -&gt; show n ++ &quot;: &quot; ++ line) [0..] todoTasks putStrLn $ unlines numberedTasks -- show the itemsremove :: [String] -&gt; IO ()remove [fileName, numberString] = do -- get the filename and the line number handle &lt;- openFile fileName ReadMode (tempName, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; -- create a temp file contents &lt;- hGetContents handle -- get contents from the handle let number = read numberString -- read the String to Number todoTasks = lines contents newTodoTasks = delete (todoTasks !! number) todoTasks -- remove the line of the number hPutStr tempHandle $ unlines newTodoTasks -- putStr into the tempfile hClose handle -- close handles hClose tempHandle removeFile fileName renameFile tempName fileNamedispatch :: [(String, [String] -&gt; IO ())]dispatch = [ (&quot;add&quot;, add), (&quot;view&quot;, view), (&quot;remove&quot;, remove) ]-- runhaskell arags-test.hs view newData.txt-- runhaskell args-test.hs add newData.txt &quot;Say Hello&quot;-- runhaskell args-test.hs remove newData.txt 4","tags":["整理"]},{"title":"Linux文件及文件系统","path":"/2019/04/22/Linux文件及文件系统/","content":"文件类型 普通文件 目录文件 链接文件：类似Windows的快捷方式，分软链接和硬链接 设备文件：一般在&#x2F;dev目录下，一种是块设备文件，一种是字符设备文件 文件属性-rwxrwxrwx r: read w: write x: execute 第一个字符： - : 普通文件 d : 目录文件 l : 链接文件 c : 字符设备 b : 块设备 p : 命名管道，如FIFO f : 堆栈文件，如LIFO s : 套接字 之后的三个三位字符组： 第一组代表文件拥有者(u)对该文件的权限 第二组代表文件用户组(g)对该文件的权限 第三组代表系统其它用户(o)对该文件的权限 文件系统类型 ext2 &amp; ext3：ext3是ext2的升级版本 swap：交换分区使用 vfat：DOS中的系统（FAT12、FAT16和FAT32等） NFS：网络文件系统 ISO9660：光盘文件系统 Red Hat目录结构 &#x2F;bin: Linux常用操作命令的执行文件（mv、ls、mkdir），有时与&#x2F;usr&#x2F;bin一样，放置一般用户执行文件 &#x2F;boot: 操作系统启动时所用到的程序，如&#x2F;boot&#x2F;grub &#x2F;dev: Linux系统中使用的外部设备，逻辑地址 &#x2F;etc: 系统管理时用到的配置文件和子目录（网络配置文件、文件系统、设备配置信息、设置用户信息等） &#x2F;etc&#x2F;rc.d: Linux启用和关闭时用到的脚本文件 &#x2F;etc&#x2F;rc.d&#x2F;init: Linux服务默认启动的脚本（可能用到&#x2F;etc&#x2F;xinetd.d下的内容） &#x2F;home: Linux默认的用户工作目录 &#x2F;lib: 系统动态链接共享库 &#x2F;lost+found: 系统遗失的片段存放在此目录 &#x2F;media: 光驱和软驱的挂载点 &#x2F;misc: 从DOS下安装的tools &#x2F;mnt: 光驱、软驱、硬盘的挂载点。也可挂载临时文件 &#x2F;proc: 系统核心与执行程序的信息 &#x2F;root: su用户登录的主目录 &#x2F;sbin: su用户常用的系统管理程序 &#x2F;tmp: 临时文件 &#x2F;usr: 类似Windows的Program Files &#x2F;usr&#x2F;bin: 系统用户使用的程序 &#x2F;usr&#x2F;sbin: su用户使用的管理程序和守护程序 &#x2F;usr&#x2F;src: 内核源码默认放置目录 &#x2F;srv: 存放服务启动后需要提取的数据 &#x2F;var: 服务日志信息 Linux C 编程exec函数组：执行后，如果出错才会返回-1，否则会取代进程。多进程例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;syslog.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t child, child1, child2, daemon; int i, fd, sid; char* message1 = &quot;this is a process 2. &quot;; char* message2 = &quot;this is a process 3. &quot;; child1 = fork(); if (child1 &lt; 0) &#123; printf(&quot;Child1 fork error. &quot;); exit(1); &#125; else if (child1 == 0) &#123; // child1 thread if (execlp(&quot;cp&quot;, &quot;cp&quot;, &quot;/bin/ls&quot;, &quot;/tmp&quot;, NULL) &lt; 0) &#123; printf(&quot;Child1&quot;); &#125; sleep(2); exit(0); &#125; else &#123; // father thread child2 = fork(); if (child2 == -1) &#123; printf(&quot;Child2 fork error. &quot;); exit(1); &#125; else if (child2 == 0) &#123; // child2 thread if ((fd = open(&quot;./src_file&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; printf(&quot;Open file error. &quot;); exit(1); &#125; write(fd, message1, strlen(message1) + 1); sleep(5); exit(0); &#125; do &#123; child = waitpid(child1, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child1 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); do &#123; child = waitpid(child2, NULL, WNOHANG); if (child == 0) &#123; printf(&quot;child2 is running. &quot;); sleep(1); &#125; &#125; while (child == 0); daemon = fork(); // fork daemon openlog(&quot;test_syslog&quot;, LOG_PID, LOG_DAEMON); // open syslog if (daemon &lt; 0) &#123; printf(&quot;Daemon fork error. &quot;); exit(1); &#125; else if (daemon &gt; 0) &#123; exit(0); // father thread exit &#125; if ((sid = setsid()) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;setsid&quot;); exit(1); &#125; if ((sid = chdir(&quot;/&quot;)) &lt; 0) &#123; syslog(LOG_ERR, &quot;%s &quot;, &quot;chdir&quot;); exit(1); &#125; // start make daemon thread umask(0); for (i = 0; i &lt; getdtablesize(); i++) &#123; close(i); &#125; while (1) &#123; // start run daemon thread if ((fd = open(&quot;/var/log/message&quot;, O_CREAT|O_WRONLY|O_APPEND, 0600)) &lt; 0) &#123; // get the fildes syslog(LOG_ERR, &quot;open&quot;); exit(1); &#125; write(fd, message2, strlen(message2) + 1); close(fd); sleep(5); &#125; closelog(); exit(0); &#125; exit(0);&#125;","tags":["整理","Linux"]},{"title":"Block-level function","path":"/2019/04/17/Block-level-function/","content":"在某个论坛有人问了下面的一段代码123456789101112function f() &#123; console.log(&#x27;outside&#x27;);&#125;function a() &#123; f() &#123; function f() &#123; console.log(&#x27;inside&#x27;); &#125; &#125;&#125;a() 问的是为什么在浏览器中是f is not a function。这个问题其实很好回答，存在函数提升，但是仔细想想又不对，因为函数提升是把整个函数都提升到当前作用域，所以按理来说f并不会是undefined。如果按照函数提升的话，结果应该是像这样： 1234567891011121314function f() &#123; console.log(&#x27;outside&#x27;);&#125;function a() &#123; function f() &#123; console.log(&#x27;inside&#x27;); &#125; f() &#123; &#125;&#125;a() 所以结果应该是inside才对，用IE7可以发现结果确实是inside。那这里为什么是undefined呢？后面那位兄弟说在阮一峰的《ES6入门》中说道，ES6规定块级作用域中的函数定义规定为函数表达式。如果是定义为函数表达式的话，那就会像这样： 1234567891011121314function f() &#123; console.log(&#x27;outside&#x27;);&#125;function a() &#123; var f f() &#123; var f = function f() &#123; console.log(&#x27;inside&#x27;); &#125; &#125;&#125;a() 这么一来这个undefined就可以解释了，因为只存在变量提升，而还未定义，所以就会出现undefined。但是那本书后还加了一句，浏览器并未遵循实现。后面在starkoverflow上找到了一个老哥的回答，他的解释为这是因为strict &amp; non-strict mode的不同。 let和const在两种模式下行为一样 function在两种模式下的行为就不是一样的，因为浏览器会扩展非严格模式，从而兼容老代码。 所以，在strict mode中，第一段代码输出的是outside，non-strict mode中就会报错，因为会变成下面这样： 12345678910111213function f() &#123; console.log(&#x27;outside&#x27;);&#125;function a() &#123; var f // function-scoped f() &#123; let f1 = function () &#123; console.log(&#x27;inside&#x27;); &#125; // block-scoped f = f1 &#125;&#125;a() MDN中关于Block-level functions in non-strict code的也只有一句话： Don&#39;t.","tags":["整理"]},{"title":"巴黎圣母院大火","path":"/2019/04/16/巴黎圣母院大火/","content":"又一次的见证历史。 卡西莫多失去了他心爱的姑娘，也失去了他心爱的钟楼。 废墟中的十字架依旧闪发着光芒 PS： 看到一条推，说你看大火都没有把十字架给损毁，难道你还不相信上帝吗？下面回：因为金的熔点比木高很多。XD","tags":["history"]},{"title":"随便聊聊","path":"/2019/04/15/随便聊聊/","content":"一篇文章昨天晚上看了某乎的一篇文章，叫《比 996 更该死的那些人》，里面的开头： 这几年真的觉得这个世界真的已经变得不可救药了勤劳和奋斗不仅不再被传颂和赞扬，竟然成了被鄙视，被视作愚蠢的品质。而享乐，投机取巧成这些在过去难以启齿的行为，成了光明正大，人人争相炫耀的东西。 虽然这篇文章我开了开头就没看了，但是还是让我感触颇深，我不赞同第二句，但是第三句我是非常赞同的。在以前我是不会羡慕别人的，不知道从什么时候开始，我会越来越羡慕那些比我强、过的比我好、智商比我高的人。是欲望变了吗？我觉得是的。那个无欲无求的日子，我是不想去回忆的，因为对我来说，和坐牢一样。 从不会去鄙视那些勤劳和奋斗的人，因为他们不知道什么时候就已经追上你并且超过你了，学如逆水行舟，不进则退，但是我实在无法理解的是，投机取巧，为什么在某些人眼里成了政治正确。炫耀享乐，这个我还是可以理解的，毕竟大部分的人还是喜欢被别夸，被别人羡慕嫉妒，当然也有真正是为了分享快乐。 投机取巧的话，不知道是否是因为圈子不同，我觉得我周围认为投机取巧的人是正确的人还不少，甚至于在学校加大监管的情况下，组队进行“帮助”，并且在成绩还可以的时候，去蛊惑那些认真考试但成绩不佳的同学，试图拉他们下水。实在是不能理解那些人心里的想法，是为了让别人顺从自己从而获得心里的快感吗？我不太懂。似乎各大高校都有这种人的存在，这到底是为什么呢？ 一张图片已经很久没有这样让人舒适的天气了，温度刚好，湿度刚好，风力刚好，阴天，简直完美。上一次让我有这种感觉的时候，还是在高一，也许是高二，青涩懵懂的高中时代，已经过去三年了。高中阶段，可以说是我目前最快乐的阶段，没有学习压力，没有生活压力，一个人住，晚上想出来溜达就出来溜达。 一件事情同样是某乎上的一件事，《如何看待杭州一女子月薪 4K，买两万元名牌包被丈夫指责这一事件？》： 林海觉得，妻子和其他的女人不一样，不会想要买这个买那个，不贪慕虚荣。 然而，就在前几天，妻子收到一个包裹，打开以后，是一个包装精美的奢侈品包包。据妻子解释，是她找人代购的，花了四个月工资。“一瞬间感觉我已经不认识眼前的这个女人了。四个月的工资就买个包吗？那她跟其他那些爱慕虚荣的女人有什么区别呢？我现在事业刚刚有点起步，我们家的收入状况比起刚结婚时，是好了一些。但离“土豪”的程度还很远啊！” 据林海介绍，夫妻两人都是工薪阶层。妻子每个月工资拿到手五千不到，而自己的收入全看绩效，每个月并不稳定。这让他很无奈：“房贷大部分是我还的，都不知道要还多少年。这下好了，小半年，都要靠我一个人了。”两人现在还没有孩子，但对孩子的态度，他也有了改观：“没孩子也好，有了孩子，又是一笔支出。养孩子要买奶粉钱，还要买包，那能花得过来吗？” 妻子回复：心寒。他根本没有看到我这几年为家里的付出。我想不明白，我用我自己的积蓄，用我自己的钱，给自己买了人生当中第一个奢侈品，有问题吗？我三十多岁了，跟他谈恋爱到结婚已经八年了。没伸手问他要过一分钱，他也从来没有送过我一个超过 700 元的礼物。那天我闺蜜要跟他老公去法国旅行，问我有什么想要带的吗？我也是狠狠心，让她帮我带了这个包包回来。这个包我在网上已经反反复复看了大半年了，我都没有勇气跟老公提出来说，老公能不能把这个包送给我？我自己刷卡买的！ 这件事下的回答，很有趣，我也看了很多。有的人，是从家庭的观点出发的；有的人，是从女人的角度出发的；还有的人，是从男人的角度出发的。 对于一个家庭来说，我觉得很少有哪个家庭，会为了买一个不必要的东西而花费一个人四个月的积蓄。可能是自身家庭的原因，我觉得一个家庭，积蓄的多少决定了可以承担的风险有多大，因为你不知道明天和意外哪个先来，如果出了意外的话，家里的积蓄可以让你不那么艰难。所以，对于一个家庭来说，我觉得花费一个人四个月的积蓄，去买一个包，这是非常不正确的，奢侈品不是人人都需要的，也不是必要的，也许是虚荣心，一时眼红买了一个包，这是冲动，但人和动物的区别，就是可以克制自己。也像有的评论说的那样，你穿的很差，背着一个很好的包，谁都觉得背的是 A 货，但是如果你穿的很好，背着一个 A 货，大家肯定都认为你背的是正品，这样看来，买这个包也没什么必要了。而且，婚后的收入是共有的，你的开销，实际上有你伴侣的一半，所以较大的开销我觉得可以双方商量一下，再考虑是买还是不买。还有的评论说，在买的情况为 0%的时候，为什么要商量？这就好比不管你同不同意我都要买，这不是耍无赖吗？不考虑别的感受，私自做决定，我觉得会对双方关系造成很大的影响。 对于一个男人来说，自己辛苦挣钱还房贷，常年吃不到一顿好的，在这种情况下，自己的老婆花将近半年的钱去买一个包，你心里会怎么想？如果照着女方的观念，我花的是我自己的钱，凭什么管，那男方完全也可以进行一下这种操作，贷款两人平分，其他开支各付个的，但是这样的话，就会有某些人跳出来说：那老娘还结婚干什么。我觉得有个评论说的很对，妻子的不幸，不是丈夫造成的： 妻子的不幸，不是丈夫造成的。妻子的不幸是商家，媒体，给妻子提供了看上去精美，却实质有毒的思想和生活。丈夫的不幸是商家，媒体，用有毒的思想改造了他妻子，让他失去了最后的依靠。大众只要接受了商家的教育，媒体的洗脑，ta 们这辈子注定活得悲惨，没有价值。当无产阶级省吃俭用，存钱半年，甚至一年，买入人生第一件奢侈品。这恰恰不是她们获得幸福和希望的起点，而是走向悲惨和痛苦的开端。在资产阶级的残酷压迫下，无产阶级的相互扶持，从来就不是鸟语花香，风轻云淡。在家庭竭力抵御社会压迫时，任何一方的软弱和逃离，都只会让脆弱敏感的联盟走向瓦解。 我不知道多少人，每天在微博和抖音上混着，我也不知道他们到底是经济基础太好，整天不上班，还是太懒，整天不想上班。微博和抖音，可以说我特别讨厌这两个东西，一个是给人洗脑，一个是消费碎片时间。简单来说，有人问为什么现在的男生&#x2F;女生质量那么差？也许是因为他们的标准太高了，整天在微博上看别人的男朋友女朋友，然后当做自己的择偶目标，也不是说不行，但是你得先看看自己有没有这个实力去匹配这类目标。都说门当户对是旧社会，但是，门当户对确实还挺重要的，经济基础好的人和经济基础差的人，消费观是不一样的。你让一个月平均消费 1k 的人，去消费一个 20k 的东西，而且还是一个不必要的东西，我觉得他是绝对不会去消费的，但是你让一个月均消费 10k 的人，20k 对他来说就是两个月而已。 所以，现实中找不到对的人，就期待去网上寻找自己的真爱，就会出现“见光死”，被骗财骗色等等情况，然后又去微博上，继续看着他们心目中的男神&#x2F;女神。看得越多，商家媒体就越高兴，这都是流量啊，然后找男神&#x2F;女神代言个什么产品，就会有很多人去买，流量转化为利益，男神&#x2F;女神也开心，然后购买了产品的人也觉得自己和男神&#x2F;女神用同款，所以自己也开心，皆大欢喜，质量和性价比什么的，滚一边去。这就直接导致了为什么现在这么多自媒体，为什么这么多人想红，我觉得原因都在这。 再就是抖音，简直是谋杀。你的时间不知不觉中就会被它吃掉，而且你丝毫不会察觉，短视频，刷了一时爽，一直刷一直爽。年轻人，不应该使用这两个东西，当然也不应该使用某乎，以前某乎上确实有许多干货，但最近看来，还是不用去碰了，到处都是无营养的帖子，评论玩段子，偷换概念。年轻人嘛，就应该多学习，多看看新闻，了解下还有许多水深火热的底层人民等着你们去拯救，而不是和某乎一样，人人 985 月薪 30k。 对于一个女人来说，丈夫这么多年来没有送过自己一个礼物，我也会觉得这个丈夫心里没有我。自己从一穷二白的时候就决定要跟他，到现在都不能用自己的积蓄去买自己喜欢的东西，看着别人和自己的爱人到处旅游，也是很羡慕嫉妒的。所以，自己偷偷攒了半年，给自己买了一个心爱的礼物，我觉得没有任何不妥。女人化妆大部分时候不是为了给男人看的，而是为了给其他女人看，不能让自己被其他女人比下去，这样想的话，一个好的包似乎也成为有必要的了。 对于这件事，我觉得双方都有错，但都在情理之中。作为丈夫，妻子这么多年的陪伴连件小礼物都没有，换做是我我也会内疚，所以我们应时不时的给点小惊喜（但是前提是得有自己的小金库），有空的时候多交流，多想想对方需要什么，自己能否做到，尽自己可能的去做，这才是个称职的丈夫。作为妻子，不应该把家庭和丈夫绑在一起，可以看出妻子每个月 4k 还可以攒出小金库，说明这个家的房贷大部分是靠丈夫来支撑的，所以或许她的观念是，丈夫的钱他自己用了，所以我的钱我自己用没什么不妥，但是家庭是需要每个人付出的，如果你的钱大部分拿来还房贷，他花一两万去买个表，相信也会心里憋屈。夫妻双方应多沟通，特别是这种算是比较大的事情，一定要双方达成共识，如果瞒着一方，这就算欺骗。 一些年纪 人总是会回忆过去的，但不能待在过去 不知道多少岁： 听奶奶说我从桌子上摔地上了，头着地，有个很大的包。 大概一岁吧，不知道有没有一岁，我只记得父亲用抓了只蜻蜓放在名片盒里让我玩，母亲在喂我吃饭，那时我的脸还挺肥的。 大概是三四岁？记不太清：开始上学前班了，记不得多少这时候的事情，只记得父亲给我买了一个熊的面包，我很喜欢。或许这段记忆也是梦里的。 五岁，一年级：在明珠学校读的，学校进门有个小店，那个老板在玩红警，我现在都记得。也许是那时候对电脑产生了兴趣。开学，父亲带我去教室，因为没有带水杯，所以用矿泉水瓶去给我接热水，当然了，矿泉水瓶怎么可以接开水，一碰就瘪了，所以就没有喝。到了教室，父亲只说了句，坐着啊，我走了。然后我就看着他走了，我还是挺害怕的，但是周围同学都在那坐着，我也就好好坐着了。 六岁，二年级：开始自己走路上学，其实也不远，和父母上班的地方也近，但是每天起的比较早，就自己去上学了。学校有一栋建筑物后面是一片草地，上面有三叶草（只记得形状是三篇叶子），同学说是甜的，我也尝了尝，三叶草不难吃，反而有清香的味道。做过两件事，第一件趴校车车底，第二件和同学打弹珠忘记回家。也不知道当时为啥趴校车车底，如果车子开动了，不敢想会有什么样的结果。哦，还有从后山翻进学校，被蚊子叮的很多包。还碰见了一个从外地来的同学，应该是家境不怎么好吧，学校帮了很多。那时候最喜欢的事就是，站在楼底，然后抬头望着天空，那时候天还很蓝，楼也没有那么多反光的玻璃，看着云就好像楼要压到我身上，或者楼要往那边倒了一样，很奇妙，经常看的忘记时间，看久了脖子痛（当时为什么不躺着呢）。当时似乎班上还有个家境很好的同学，跟着他有辣条吃，于是天天基本就跟在他后面玩。 七岁，三年级：转学了，应该是育英学校，因为父母工作的地方换了。吃不到辣条了，但是会偶尔从家里拿一两块钱，冬天的时候去校门口买油炸火腿肠。校门口还有画糖画的，似乎我还在学校吃食堂吃过一段日子。班上同学我就认识一两个，现在只记得一个姓赵的了。记得那时候中午快迟到了，跑步上课，然后撞到了一个一年级的，导致门牙坏了，拔了四颗牙齿，和吸血鬼一样。学校后门有一种花，上次在广州也见着了，橘黄色的，长条。也是同学跟我说是甜的，我也摘了从后面吮吸，还真是甜的。学了画画，但是实在是没有天分。还记得那时候查发热，每个人进校门都要被红外线温度计测一下，我似乎有点症状，然后就被领到保安亭了，后面趁着没人就跑出来了，天生就不喜欢去医院。 八岁，四年级：转学，去锦华实验了，从那时候起有校车坐了，因为是住在奶奶家。应该也是在食堂吃饭的，依稀记得撞了个高年级的然后被骂了，饭菜一般。那时候有课外活动了，想选计算机来着，可惜人满了，所以一开始选了葫芦丝，后面又去学毛笔了。还在校庆的时候上台表演了一下葫芦丝，现在应该是不会了，只记得那几个唱名是怎么放的。偶尔下大雨的时候校车也会来，然后通知我们回去，不用上课，那时候我就会在家待着干点其他的。后面跑去学毛笔字，也是没学多久就不学了，因为没兴趣，只记得高年级的同学总是叫我们低年级的去洗砚台，我觉得自己的砚台就应该自己洗。比较开心的事是坐校车，因为可以看见外面，尽管没什么风景，但是我每次都是在最后那站，所以后面都是一个人在一辆车里，吹着风。 九岁，五年级：转学，去龙丰学校了，听说原来的班主任还来我家问我为什么没来上课，因为学费涨了负担不起，所以只能转学读一个学费低一点的学校，班主任说我的成绩可以和学校申请减免学费，但是还是没有回去。是一个不太好的学校，这年学会了进网吧，学校后山是一个部队，和同学进去想游泳，结果被撵出来了，还被不知道什么蚂蚁咬了肿了很大一块。我弟弟妹妹也在我这个学校读学前班，所以放学的时候都是我把他们带回来。刚报道的时候，不知道是哪个班级，就随便进了一个，那个老师把我安排在了最后面，周围都是看起来不善的同学，他们下课就打牌，上课吃零食。后面又换了一个班，那个班还不错，同学都比较友善。记得上音乐课，老师放《土耳其进行曲》给我们听，然后说里面有三种片段，要我们听了之后把片段写出来，我写的 ABCBAB，但是其他同学都没有最后的 B 片段，最后老师说班上只有我一个人是正确的，我很开心。那时候还认识了一个好朋友，但那时也没有什么联系方式，所以就断了。 十岁，六年级：转学，回老家了，我小学六年读了五个学校，但是我很少跟人提起过。这五年其实也挨了不少的打，也拿了不少的奖，但都不太值得回忆，就不打算写了。奖状的话，似乎有一两斤重。一开始去那个学校，还要给我做一个测试题，不得不说，老家的教育水平和深圳还是有很大差距的，他们六年级学的东西我四五年级就学完了。但是不知为什么，我还是得去完成小升初的考试，所以就读了六年级。六年级就认识了比较多的同学朋友了，但是唯一让我不爽的是，每天七节课，只有语文数学和英语，偶尔说有体育课，其实就是让我们去拔杂草。忘记哪个周末，和班里的同学约好下课去网吧，结果有个同学没来，跑去告老师了，然后第二天我们就在办公室站了一上午。数学老师很严，其他老师没什么印象，只记得数学老师严，上学第一天就把我的数学书给撕了，因为他上午说带草稿本，而我没带，因为我上午根本就还没来班上，也不听你解释，直接撕，估计是杀鸡儆猴吧。我最讨厌那些不让别人说话，自己判断的人。似乎那年我还学过一点奥数，不太记得了，小房间，幼儿园的那种桌椅，写字十分不舒服。后面听说那个以前玩的好的同学还找我，听说我回老家了，一直在等我什么时候回来。 十一岁，初一：升初中了，开始住老师家了。似乎就是这个阶段我是无欲无求的，每天两点一线，吃饭，睡觉，上课，没有什么其他的事情。老师还不错，化学老师是班上一个同学的爷爷，物理老师是班上一个同学的父亲，语文老师的女儿后面也来我们学校了，后面听说物理老师当了副校长，化学老师不知道退休了没有，老曾，怀念，还有英语老师，那次回去在路上看见了，可惜我在车里，她在路上，还有在路上碰见同学去上课，还能认出我，那都是高中时候的事情了。初一没什么特别的事情，大家都安安分分的上课，同学们也都相互认识，班长是个女生，现在成绩也不错，令我很敬佩的女生，如果现在碰见她，还是会叫一声老班长。 十二岁，初二：分班了，有些成绩差的同学都出去了，就留下了大概五六十个人，和深圳的标准一班四十人不同，老家多的有八九十人，少的才四五十人。教室也换了，在校长办公室楼上，偶尔下楼会碰见校长。和我们一起的就十八班，在隔壁。平平淡淡，上课想听就听一下，不想听就看点杂志，困了就睡一下，还参加了一个歌唱比赛，似乎拿了奖。那年学校有计算机课了，我还记得开机是七喜电脑，还有长虹电脑，我们在那学 flash 动画，那时候觉得很难，然后有个示例动画，好像是熊猫人，很流畅，还有剧情，虽然只有短短的五分钟。似乎是这年，我每天中午不想在住的地方待着，我就选择去学校睡，不记得是不是被老师跟踪过了，可能是，也可能不是。初二物理竞赛还拿了二等奖。 十三岁，初三：又搬到初一那栋楼了，听说校长那个已经是危房，不能住了。老师们那年到临川一中学习，回来之后马上给我们教室的喇叭装了一个开关，这样中午放学如果拖课，就可以把喇叭关了，这样就听不见那嘈杂的音乐了。那年老曾来班上了，我们这是初三才学化学，如果有人上课凳子坏了掉地上了，他还会从办公室拿锤子过来给我们修凳子。生物老师是个很奇特的东西，初一的时候他教我们地理，初二的时候他教我们生物，初三的时候看见他在别的班当体育老师，他脾气很暴躁，但是教的确实很好，如果我们不学习也是会真的生气，但是他从不打人，只打多媒体的桌子，铁皮的，有时候一巴掌可以打凹进去。英语老师很好玩，也跟我们讲她儿子在国外上大学的趣事，一直也想回去看看他们。有天晚上，我睡觉，然后看着窗外，然后突然有个橘黄色的圆环从我眼前飞过，我爬起来却看不见了，我觉得那是外星人的飞船吧。记得那时还得考个物理化学实验，物理实验因为做过很多次了，所以比较快，但是化学的话，由于从没摸过试管烧杯什么的，手滴定的时候一直在抖，旁边老师都看笑了，还好没什么大碍。 十四岁，高一：我似乎是班上唯一一个来临川一中的，但是我不是班上成绩最好的。临川一中教会了我很多东西。高一的时候入学还要个分班考试，也不知道是不是真的会看，因为考试的人比较多，两三千号人，而且考完过几天就分班了，所以我觉得是没有看的。学校还有社团，通过社团和贴吧认识了好大波的朋友，高一的时候还是很愉快的。虽然也是住在别人家，但是管的不是很严，所以晚上可以晚点回去，在外面吃点东西。班主任是黄老师，教数学的，挺搞笑的一个人，后面分班之后跑去教文 A 班了，今年招不到学生的时候还让我帮他招一些学生。政治历史老师没什么印象，因为从来不听课，语文老师倒是印象挺深的，他不怎么讲课，没激情，经常上课的时候跑去他班上管事，因为他觉得他班上太吵了。后面申请换了个语文老师，新老师太有激情了，导致一节课下来很累。夏天，有一天狂风骤雨，然后有爆炸声，似乎是某个烟花厂被雷电给打了，起火爆炸了。 十五岁，高二：文理分班，从六楼去二楼了。这一年，撒贝宁来了，去做了个志愿者；这一年，饶 boss 还是 boss；这一年，朋友们都还没毕业。班主任换成了老吴，我回去看他时还和他聊起同学们，他说：天天关照的同学没有一个回来看我的，反而是你们这些整天被我骂的人回来看我们。这年结束的时候，很多朋友都毕业了，贴吧没了他们也冷清了，就连学校我都觉得少了点熟悉的感觉。但是认识了新的同学，龙兄、谢老板、隔壁老王、隔壁老吴和小焯等。我们这几个算是班上最调皮捣蛋的了，但是这么多年过去了，我们几个似乎混的也还不错，有早早去工作的了，也有准备考研的，一直也没机会聚一聚，只能到某个地方，就去见某个人。龙兄和谢老板在班上还有个外号叫“天龙八部”，因为两个人一起被没收了八部手机。 十六岁，高三：八月中就开始补课了，高三正式开始。校长也退休了，新校长上任三把火，治理了一波不学习的同学，也包括我。可能是对学科没多大的兴趣吧，所以不怎么想学，所以在老师眼里就是那种不学习，整天不知道在干什么的孩子。那年买了第一本的编程书，是关于 PHP 的，但是由于没有电脑实际操作，所以看不了多少。当时班上有一个同学，高一就开始自学信安了，当他在看密码学，XSS，这种书籍时，我才刚开始接触这东西；人家在高中毕业就经济独立了，而我还不知道我的明天在哪。也是从那时开始，我羡慕别人有技术，失去了纯真。当时与父母谈过这个问题，他们还是劝我说读个大学更重要，现在想想，他们是对的，如果我当时不去念大学而是去学技术，万一技术没学好，我连后路都没有了。这一年，有的朋友也回去高考了，他们是贵州的，来我们学校学习，然后回去考贵州卷，记得当时我们全国一卷，分数线是全国最高的。毕业那天，以前的传统是撕书嘛，那天不知道谁偷偷运了个烟花进来，有幸欣赏了一波烟花秀。毕业那天，我们去喝酒，但是最后，也是我们这几个平常不怎么学习的人去陪着老师走了最后的一段路，聊了很多，老师也跟我们说，其实你们不是智商低，你们只是不愿学，以后努力吧，毕竟上了大学，就没有老师可以管你们了。直到现在，我们也会有时间就去一起去看看曾经的老师，曾经的学校，看看曾经的人，曾经的物。 FIREWORKS SHOW 到了大学，学到了自己喜欢的学科，我觉得很荣幸。 终于可以开心的码代码，算是完成了一个梦想吧。","tags":["雜談"]},{"title":"归纳法","path":"/2019/04/14/归纳法/","content":"自然数上的一般归纳原理假设$P$是自然数上的一个性质，则如果 $P(0)$成立 – base case 对所有的自然数$k$，$P(k)$蕴涵$P(k+1)$ – induction step 则$P(n)$对所有自然数$n$成立$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ [P(k)]\\\\frac{P(0)\\ P(k+1)}{P(n)}$$$[P(k)]$为归纳假设，$k$不能出现在$P(k + 1)$的任何假设中 定理：每个自然是要么是偶数，要么是奇数。用归纳法来证明： 0是偶数 -&gt; 0是偶数或奇数 假设k是偶数或奇数，证明k + 1是奇数或偶数： k是偶数，则k + 1是奇数 k是奇数，则k + 1是偶数 得证 自然数上的完全归纳原理假设$P$是自然数上的一个性质，则：如果对每个自然数$k$，假定$P(i)$对所有自然数$i(i &lt; k)$成立，则可以证明$P(k)$成立$$[\\forall i &lt; k.P(i)]\\\\frac{P(k)}{P(n)}$$$k$不能出现在其他前提条件的其他假设中 定理：所有$n \\geq 2$的自然数都可以写成素数的乘积$n &#x3D; p_1…p_k$对$n$进行完全归纳： $n$是素数，那么$n &#x3D; n$ $n$不是素数，则$\\exists\\ n % m &#x3D; 0(1 &lt; m &lt; n)$所以$n &#x3D; m * \\frac{n}{m}$，对$m$和$\\frac{n}{m}$再次归纳，得$m &#x3D; p_1…p_k$且$\\frac{n}{m} &#x3D; q_1…q_k$得$$n &#x3D; m * \\frac{n}{m} &#x3D; p_1…p_kq_1…q_k$$ 得证 字典序归纳原理假设$P$是自然数序对上的一个性质，则：如果对每个自然数序对$(m, n)$，假定$P(m’, n’)$对所有的$(m’, n’) &lt; (m, n)$成立，则可以证明$P(m, n)$成立 结构归纳法形式1假设$P$是某个文法产生的任一表达式$e$上的一个性质，则： 对每个原子表达式$e$，证明$P(e)$为真 对直接子表达式为$e_1,…,e_k$的任何复合表达式$e$，证明如果$P(e_i)(i &#x3D; 1, …, k)$都为真，则$P(e)$也为真 形式2假设$P$是某个文法产生的任一表达式$e$上的一个性质，则： 对每个原子表达式$e$，证明$P(e)$为真 对任何表达式$e$的任何子表达式$e’$，证明如果$P(e’)$都为真，则$P(e)$也为真 表的结构归纳法假设P是元素类型为$\\tau$的表(list)上的一个性质，则： $P([])$, []表示空表 对类型为$\\tau$的所有元素$y$以及类型为$\\tau$ list的表$ys$都有$P(ys)$蕴涵$P(y::ys)$，则$P(xs)$对所有类型为$\\tau$ list的表$xs$成立$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ [P(ys)]\\\\frac{P([])\\ P(y::ys)}{P(xs)}$$$y$和$ys$不能出现在$P(y::ys)$的其他假设中 定理：所有的表都不等于自己的表尾对$xs$结构归纳： $\\forall x.[x] eq []$，两个表是相等的当且仅当它们具有相同的长度且对应的元素也相等 假定$\\forall x.x::ys eq ys$成立，并对于任意的$y$和$ys$证明$\\forall x.x::(y::ys) eq y::ys$，所以只要证明两边表尾不相等：即证明$y::ys eq ys$不适用于无穷表，$[n, n, …]$等于它自己的表尾 定理：对于所有的表xs和ys，有$len(xs@ys) &#x3D; len\\ xs + len\\ ys$（@连接运算）对xs结构归纳： $len([]@ys) &#x3D; len[] + len\\ ys$成立 假定$len(xs\\ @\\ ys) &#x3D; len\\ xs + len\\ ys$成立，那么我们可以证明对于所有的$x$和$xs$，有$len((x::xs)\\ @\\ ys) &#x3D; len(x::xs) + len\\ ys$也成立$$len((x::xs)@ys) &#x3D; len(x::(xs@ys))\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; 1 + len(xs@ys)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; 1 + (len\\ xs + len\\ ys)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; (1 + len\\ xs) + len\\ ys\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ &#x3D; len(x::xs) + len\\ ys$$ 树的结构归纳法假设P是类型$\\tau$ tree的树的一个性质，则： $P(empty)$ 对于所有类型为$\\tau$的元素$x$以及类型为$\\tau$ tree的树$t_1$和$t_2$都有，$P(t_1)$和$P(t_2)$蕴涵$P(node(x, t_1, t_2))$$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ [P(t_1), P(t_2)]\\\\frac{P(empty)\\ P(node(x, t_1, t_2))}{P(t)}$$$x$、$t_1$和$t_2$不能出现在$P(node(x, t_1, t_2))$的其他假设中 证明上的归纳假设一个公式可以证明的，那么：推理规则：若一组公式可证，则另一个公式也证$\\frac{A_1…A_n}{B}$，如果$A_1,…,A_n$（前提）都可证，那么B（结论）也可证 相等性的自反公理： $e &#x3D; e$ 相等性的传递规则：$\\frac{e_1 &#x3D; e_2\\ e_2 &#x3D; e_3}{e_1 &#x3D; e_3}$ 所以一个证明可以定义为一个公式序列，该序列中的每个公式都是公理或是由先前的公式通过一条推理规则得到的结论。可以有两个方法来归纳： 对公式序列的长度进行自然数归纳法 把证明看成树，所用的公理看叶节点，推理规则看成内部节点，由对$A_1, …, A_n$的证明来构造对$B$的证明 在某个证明系统中，证明对每个证明$\\alpha$，$P(\\alpha)$为真： 对该系统中的每个公理，证明$P$成立 假定对$\\alpha_1,…,\\alpha_k$，$P$都成立，证明$P(\\alpha)$也成立，则$\\alpha$是$\\alpha_1,…,\\alpha_k$延伸出的一个证明 证明系统的可靠性：在公式的某种特定解释下，每个可证的公式都为真。","tags":["学习"]},{"title":"等式公理","path":"/2019/04/14/等式公理/","content":"公式: $$P{Q}R\\ ({P}Q{R})$$P和R都是一阶公式, 如果前提条件P在执行Q前成立, 则执行后得到满足条件R的状态部分正确性断言: 如果P在Q执行前为真, 那么, 如果Q的执行终止,则终止在使R为真的某个状态终止性断言:如果P在Q执行前为真, 那么Q将终止在使R为真的某个状态赋值公理: $$\\vdash P_0 {x:&#x3D;f} P$$ 推理规则的表示$$\\frac{premise -&gt; f_0, f_1, …, f_n}{conclusion -&gt; f_0}$$ 推理规则 Rules of Consequence:$$\\frac{P{Q}R,\\ R\\rightarrow S}{P{Q}S}\\ \\ \\ \\ \\ \\frac{P{Q}R,\\ S\\rightarrow P}{S{Q}R}$$ Rule of Composition:$$\\frac{P{Q_1}R_1,\\ R_1{Q_2}R}{P{Q_1, Q_2}R}$$ Rules of Iteration:$$\\frac{P\\ &amp;\\ B{S}P}{P\\ {while\\ B\\ do\\ S}\\ eg B \\ &amp;\\ P}$$ 等式公理 代换: $[N&#x2F;x]M$ 表示表示M中的自由变元x用N代换的结果, N中的自由变元代换后不能成为约束变元 约束变元改名: $\\lambda x:\\sigma .M &#x3D; \\lambda y:\\sigma.[y&#x2F;x]M$ 例如:$\\lambda x:\\sigma.x + y &#x3D; \\lambda z:\\sigma .z+y$ 等价公理: 计算函数实际就是在函数中使用实在变元替换形式变元, $(\\lambda x:\\sigma.M)N &#x3D; [N&#x2F;x]M$ 同余性规则: 相等的函数作用于相等的变元产生相等的结果, $\\frac{M_1&#x3D;M_2,\\ N_1&#x3D;N_2}{M_1N_1&#x3D;M_2N_2}$","tags":["学习"]},{"title":"简陋VDOM","path":"/2019/04/11/简陋VDOM/","content":"一个简陋的VDOM希望以后会慢慢完善吧… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let data = &#123; tag: &#x27;div&#x27;, children: [&#123; tag: &#x27;span&#x27;, children: [&#123; tag: &#x27;#text&#x27;, content: &#x27;hello world&#x27; &#125;] &#125;, &#123; tag: &#x27;p&#x27;, children: [&#123; tag: &#x27;#text&#x27;, content: &#x27;This is a paragraph!&#x27; &#125;, &#123; tag: &#x27;h1&#x27;, children: [&#123; tag: &#x27;#text&#x27;, content: &#x27;This is a H1 tag&#x27; &#125;] &#125;, &#123; tag: &#x27;h6&#x27;, children: [&#123; tag: &#x27;#text&#x27;, content: &#x27;and I\\&#x27;m h6&#x27; &#125;] &#125;] &#125; ]&#125;class VDOM &#123; constructor(data) &#123; this.tag = data.tag this.children = data.children this.content = data.content &#125; static render(data) &#123; let _this = new VDOM(data) if (_this.tag === &#x27;#text&#x27;) &#123; return document.createTextNode(_this.content) &#125; let node = document.createElement(_this.tag) _this.children.map(child =&gt; node.appendChild(VDOM.render(child))) return node &#125;&#125;let diff = (root, oldV, newV, current = 0) =&gt; &#123; if (!oldV) root.appendChild(newV) else if (!newV) root.removeChild(root.childNodes[current]) else if (newV.tag !== oldV.tag || newV.content !== oldV.content) root.replaceChild(new VDOM(newV).render(), root.childNodes[current]) // 递归判断 else for (let i = 0; i &lt; newV.children.length || i &lt; oldV.children.length; i++) diff(root.childNodes[i], oldV.children[i], newV.children[i], i)&#125;document.querySelector(&#x27;#root&#x27;).appendChild(VDOM.render(data)) 结构为: 12345678910&lt;div id=&quot;root&quot;&gt; &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;p&gt; This is a paragraph! &lt;h1&gt;This is a H1 tag&lt;/h1&gt; &lt;h6&gt;and I&#x27;m h6&lt;/h6&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;","tags":["整理"]},{"title":"首张黑洞照片","path":"/2019/04/10/首张黑洞照片/","content":"见证历史爱因斯坦是正确的!","tags":["history"]},{"title":"Maybe","path":"/2019/03/29/Maybe/","content":"ContainerLet’s create a normal container first. 1234567891011class Container &#123; constructor(x) &#123; this._value = x; &#125; // use the of to create the container static of(x) &#123; return new Container(x); &#125;&#125;Container.of(2); // Container &#123; _value: 2 &#125;Container.of(&#123; name: &#x27;jack&#x27; &#125;); // Container &#123; _value: &#123; name: &#x27;jack&#x27; &#125; &#125; But we should not directly manipulate the data in the container. We need a function to do this. 123456// Container.prototype.map :: (a -&gt; b) -&gt; Container a -&gt; Container bContainer.prototype.map = function (f) &#123; return Container.of(f(this._value));&#125;let six = Container.of(2).map(x =&gt; x * 3); // Container &#123; _value: 6 &#125;six.map(x =&gt; x.toString()).map(x =&gt; &#x27;number: &#x27; + x + &#x27;!&#x27;); // Container &#123; _value: &#x27;number: 6!&#x27; &#125; After passing the values in the Container to the map function, we can let them manipulate it; after the operation is completed, in order to prevent accidents, put them back into the Container they belong to. The result is that we can call the map continuously, running any function we want to run.And the Functor is a container type that implements the map function and adheres to certain rules. MaybeIn Haskell, the Maybe type is defined as follow: 1data Maybe a = Just a | Nothing Maybe will check if its value is empty before calling the passed function. So let’s create a simple one. 1234567891011121314151617class Maybe &#123; constructor(x) &#123; this._value = x; &#125; static of(x) &#123; return new Maybe(x); &#125; isNothing() &#123; return this._value === null || this._value === undefined; &#125; // map :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b map(f) &#123; return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this._value)); &#125;&#125;Maybe.of(&#x27;hello world&#x27;).map(match(/o/ig)); // Maybe &#123; _value: [ &#x27;o&#x27;, &#x27;o&#x27; ] &#125; Maybe.of(&#123; name: &#x27;jack&#x27; &#125;).map($.prop(&#x27;age&#x27;)).map(x =&gt; x + 10); // Maybe &#123; _value: null &#125; Error handlingThere is a class called Either in scala that represents the value of one of two possible types. Instances of Either are either an instance of Left or Right.Now we need to create the Left and the Right. 12345678910111213141516171819202122232425class Left &#123; constructor(x) &#123; this._value = x; &#125; static of(x) &#123; return new Left(x); &#125; // do nothing map(f) &#123; return this; &#125;&#125;class Right &#123; constructor(x) &#123; this._value = x; &#125; static of(x) &#123; return new Right(x); &#125; map(f) &#123; return Right.of(f(this._value)); &#125;&#125;Left.of(2).map(x =&gt; x + 2); // Left &#123; _value: 2 &#125;Right.of(2).map(x =&gt; x + 2); //Right &#123; _value: 4 &#125; Use it: 1234567891011121314151617181920212223242526// getChange :: a -&gt; b -&gt; Either(String, Number)let getChange = curry((a, b) =&gt; &#123; if (a &lt; b) return Left.of(&#x27;You need to give more money.&#x27;); return Right.of(a - b);&#125;);getChange(10, 8); // Right &#123; _value: &#x27;Get the change: 2&#x27; &#125;getChange(10, 15); // Left &#123; _value: &#x27;You need to give more money.&#x27; &#125;// eigher :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; cvar either = curry((f, g, e) =&gt; &#123; switch(e.constructor) &#123; case Left: return f(e._value); case Right: return g(e._value); &#125;&#125;);// faild :: a -&gt; avar faild = x =&gt; x;// success :: a -&gt; bvar success = x =&gt; &#123; return &#x27;get change: &#x27; + x;&#125;// foo :: a -&gt; a -&gt; cvar foo = $.compose(either(faild, success), getChange);foo(0, 2); // You need to give more money. foo(4, 2); // get change: 2","tags":["整理"]},{"title":"The composition","path":"/2019/03/28/The-Composition/","content":"Function CompositionIn computer science, function composition is an act or mechanism to combine simple functions to build more complicated ones. Like the usual composition of functions in mathematics, the result of each function is passed as the argument of the next, and the result of the last one is the result of the whole. -- Wikipedia Example: 123456var compose = (f, g) =&gt; x =&gt; f(g(x));var head = x =&gt; x[0];var reverse = reduce((a, x) =&gt; [x].concat(a), []);var last = compose(head, reverse);last([&#x27;first&#x27;, &#x27;second&#x27;, &#x27;last&#x27;]); // &#x27;last&#x27; In the definition of compose, g will be executed before f, thus creating a right-to-left data stream. This is much more readable than nesting a bunch of function calls. AssociativityLike many other functional programming concepts, associativity is derived from math.It is an expression in which the order of evaluation does not affect the end result provided the sequence of the operands does not get changed. -- JOSEPH REX Example: 122 + (3 + 4) === (2 + 3) + 4; // true2 * (3 * 4) === (2 * 3) * 4; // true Because of the grouping of calls to compose is not important, so the result is the same. This also gives us the ability to write a variadic compose.Like this: 12345678910var last = compose(head, reverse);last([&#x27;first&#x27;, &#x27;second&#x27;, &#x27;last&#x27;]); // &#x27;last&#x27;var upperLast = compose(head, reverse, toUppercase);upperLast([&#x27;first&#x27;, &#x27;second&#x27;, &#x27;last&#x27;]); // &#x27;LAST&#x27;var mediaUrl = _.compose(_.prop(&#x27;m&#x27;), _.prop(&#x27;media&#x27;));// var images = _.compose(_.map(img), _.map(mediaUrl), _.prop(&#x27;items&#x27;));// use the associativityvar images = _.compose(_.map(_.compose(img, mediaUrl)), _.prop(&#x27;items&#x27;)); There is no standard answer on how to composition, just make it more reusable. Tacit programmingTacit programming, also called point-free style, is a programming paradigm in which function definitions do not identify the arguments (or &quot;points&quot;) on which they operate. -- Wikipedia 1234567891011var head = x =&gt; x[0];var toUppercase = x =&gt; x.toUpperCase();// not pointfree// it used the namevar foo1 = name =&gt; name.split(&#x27; &#x27;).map(compose(toUppercase, head)).join(&#x27;.&#x27;);foo1(&#x27;Edward Wang&#x27;); // E.W// pointfreevar foo2 = compose(join(&#x27;.&#x27;), map(compose(toUppercase, head)), split(&#x27; &#x27;));foo2(&#x27;Edward Wang&#x27;); // E.W some practiceUse compose in rambda. 1234567891011121314151617181920212223242526272829303132333435// test datavar dragons = [ &#123; name: &#x27;thiny dragon&#x27;, height: 600, price: 700, sold: true &#125;, &#123; name: &#x27;tall dragon&#x27;, height: 6600, price: 1700, sold: false &#125;, &#123; name: &#x27;dangerous dragon&#x27;, height: 5200, price: 700, sold: false &#125;, &#123; name: &#x27;small dragon&#x27;, height: 200, price: 1300, sold: false &#125;, &#123; name: &#x27;fat dragon&#x27;, height: 400, price: 900, sold: true &#125;, &#123; name: &#x27;gold dragon&#x27;, height: 500, price: 2000, sold: false &#125;,]// 1. rewrite the following with the compose. Tip: the prop is curry function.// var isLastSold = xs =&gt; &#123;// var x = $.last(xs);// return $.prop(&#x27;sold&#x27;, x);// &#125;var isLastSold = $.compose($.prop(&#x27;sold&#x27;), $.last);isLastSold(dragons); // false// 2. use the compose, prop and head to get the name of first dragon.var nameOfFirst = $.compose($.prop(&#x27;name&#x27;), $.head);nameOfFirst(dragons); // &#x27;thiny dragon&#x27;// 3. refactoring the averagePrice with the average to make it composition.var _average = xs =&gt; reduce(add, 0, xs) / xs.length;// var averagePrice = xs =&gt; &#123;// var p = map(x =&gt; x.price, xs);// return _average(p);// &#125;var averagePrice = $.compose(_average, map($.prop(&#x27;price&#x27;)));averagePrice(dragons); // 1216.6666666666667// 4. write a function that =&gt; &#x27;gold dragon&#x27; =&gt; &#x27;GOLD_DRAGON&#x27;var replaceSpace = replace(/\\W+/g, &#x27;_&#x27;);var changeName = $.map($.compose(replaceSpace, toUppercase, $.prop(&#x27;name&#x27;)));changeName(dragons); //[ &#x27;THINY_DRAGON&#x27;, &#x27;TALL_DRAGON&#x27;, &#x27;DANGEROUS_DRAGON&#x27;, &#x27;SMALL_DRAGON&#x27;, &#x27;FAT_DRAGON&#x27;, &#x27;GOLD_DRAGON&#x27; ] Test Application123456789101112131415161718192021222324requirejs.config(&#123; paths: &#123; ramda: &#x27;https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min&#x27;, jquery: &#x27;https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min&#x27; &#125;&#125;);require([&#x27;ramda&#x27;, &#x27;jquery&#x27;], (_, $) =&gt; &#123; var log = _.curry((tag, x) =&gt; &#123; console.log(tag, x); return x; &#125;); var url = term =&gt; &#x27;https://api.flickr.com/services/feeds/photos_public.gne?tags=&#x27; + term + &#x27;&amp;format=json&amp;jsoncallback=?&#x27;; var img = url =&gt; $(&#x27;&lt;img /&gt;&#x27;, &#123; src: url &#125;); var setHtml = _.curry((tag, html) =&gt; $(tag).html(html)); var getJSON = _.curry((callback, url) =&gt; $.getJSON(url, callback)); var mediaUrl = _.compose(_.prop(&#x27;m&#x27;), _.prop(&#x27;media&#x27;)); var mediaToImg = _.compose(img, mediaUrl); var images = _.compose(_.map(mediaToImg), _.prop(&#x27;items&#x27;)); var renderImages = _.compose(setHtml(&#x27;body&#x27;), images); var app = _.compose(getJSON(renderImages), url); app(&#x27;car&#x27;);&#125;)","tags":["学习"]},{"title":"The Currying","path":"/2019/03/27/The-currying/","content":"What is curryingCurrying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument. -- WikipediaIt mean this: 12345let add = (x) =&gt; (y) =&gt; x + ylet addOne = add(1)let addTwo = add(2)addOne(11) // 12addTwo(11) // 13 In order to define functions more easily, we need the loadsh, it will help us to currying the function. make some using thing12345678910111213var _ = require(&#x27;loadsh&#x27;).curryvar match = _((regex, str) =&gt; str.match(regex))var replace = _((regex, replacement, str) =&gt; str.replace(regex, replacement))var filter = _((f, array) =&gt; array.filter(f))match(/\\s+/g, &#x27;test Message&#x27;) // [&#x27; &#x27;]match(/\\s+/g)(&#x27;test Message&#x27;) // [&#x27; &#x27;]var hasSpace = match(/\\s+/g)hasSpace(&#x27;testMessage&#x27;) // nullfilter(hasSpace, [&#x27;testMessage1&#x27;, &#x27;test Message2&#x27;, &#x27;test Message 3&#x27;]) // [&#x27;test Message2&#x27;, &#x27;test Message 3&#x27;]var noA = replace(/[Aa]+/g, &#x27;*&#x27;)noA(&#x27;aaaabbbAAAc&#x27;) // &#x27;*bbb*c&#x27; some practiceUse curry in rambda. 123456789101112131415161718192021222324252627282930313233343536// support functionslet curry = require(&#x27;rambda&#x27;).currylet compose = require(&#x27;rambda&#x27;).composelet add = curry((a, b) =&gt; a + b)let match = curry((regex, str) =&gt; str.match(regex))let replace = curry((regex, replacement, str) =&gt; str.replace(regex, replacement),)let filter = curry((f, arr) =&gt; arr.filter(f))let map = curry((f, arr) =&gt; arr.map(f))let split = curry((symbol, str) =&gt; str.split(symbol))let reduce = curry((f, arr, x) =&gt; x.reduce(f, arr))let join = curry((symbol, arr) =&gt; arr.join(symbol))let toUppercase = curry((str) =&gt; str.toUpperCase())let toLowercase = curry((str) =&gt; str.toLowerCase())// 1. remove all the arguments// var words = str =&gt; split(&#x27; &#x27;, str);var words = split(&#x27; &#x27;)words(&#x27;hello world !&#x27;) // [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;!&#x27;]// 2. create a new words function with map to enable mainpulation of string arrayvar theWords = map(words)theWords([&#x27;first message&#x27;, &#x27;seconde message&#x27;]) // [[&#x27;first&#x27;, &#x27;message&#x27;], [&#x27;second&#x27;, &#x27;message&#x27;]]// 3. remove all the arguments// var filterQString = xs =&gt; filter(x =&gt; match(/q/i, x), xs);var filterAString = filter(match(/a/i))filterAString([&#x27;quick&#x27;, &#x27;queue&#x27;, &#x27;apple&#x27;, &#x27;two&#x27;]) // [&#x27;apple&#x27;]// 4. Refactor max with the help function _max to make it a curry functionvar _max = (a, b) =&gt; (a &gt;= b ? a : b)// var max = xs =&gt; reduce((account, x) =&gt; _max(account, x), -Infinity, xs);var max = reduce(_max, -Infinity)max([1, 2, 3, 4]) // 4 Currying add12345678910111213141516function add(x) &#123; let sum = x function f(y) &#123; sum += y return f &#125; f.end = function () &#123; return sum &#125; return f&#125;console.log(add(0)(1)(2).end())","tags":["学习"]},{"title":"What is the Pure Function","path":"/2019/03/27/whatIsPureFunction/","content":"Functionfunction has special rules: It must work for every possible input value And it has only one relationship for each input value Although each input will only have one output, but for different inputs may have the same output. Pure functionGiven all these, pure functions have a big set of advantages. They are easier to read and understand, as they do one thing. There is no need to look outside the function code and check for variables. There is no need to think how changing the value of the variable will affect other functions. No mutations in other functions will affect the result of the pure function for a specific input.Pure functions are easier to test, as all dependencies are in the function definition and they do one thing.For Example: 12345678910var arr = [1, 2, 3];// Purearr.slice(0, 2); // [1, 2]arr.slice(0, 2); // [1, 2]arr.slice(2, 3); // [3]// Impurearr.splice(0, 2); // [1, 2]arr.splice(0, 2); // [3] Another Example: 1234567891011// Impurevar sign = 3;// The return value depends on the system statusvar isBigger = num =&gt; num &gt; 3;// Purevar isBigger = num =&gt; &#123; var sign = 3; return num &gt; sign;&#125;","tags":["学习"]},{"title":"Start learning FP","path":"/2019/03/27/初涉FP/","content":"Functional Programming经过这几天的了解，越觉得 FP 十分有趣给个例子: 12345678// a simple functionfunction add(a, b) &#123; return a + b;&#125;/// the same aslet add = function (a, b) &#123; return a + b;&#125; 在 ES6 中，存在着箭头函数。所以上面的函数可以写成这个形式： 1let add = (a, b) =&gt; a + b; 构造另一个 function现在写一个新的 function : 1let multipy = (x, y) =&gt; x * y Let’s start现在我们用上面两个例子计算下 2 * 3 + 2 * 4： 12let result = add(multipy(2, 3), multipy(2, 4));result // 14 试试 2 + (2 + 3) == (2 + 2) + 3是正确的吗： 12345let result1 = add(2, add(2, 3));let result2 = add(add(2, 2), 3);result1 === result2; // true// 可以看出 add(a, add(b, c)) === add(add(a, b), c) 再试试 2 * 3 + 2 * 4 === (2 + 4) * 2： 1234let result1 = add(multipy(2, 3), multipy(2, 4));let result2 = multipy(add(3, 4), 2);result1 === result2; // true// Nice Job add的链式调用12345678910function add(n) &#123; if (n === undefined) &#123; return add.result; &#125; else &#123; add.result += n; return add; &#125;&#125;add.result = 0;console.log(add(1)(1)(1)()); result: 13","tags":["学习"]},{"title":"自用vscode插件","path":"/2019/03/27/自用vscode插件/","content":"background: 背景的可爱萌妹子, 当然可以自定义背景 beautify: 代码格式化 Dracula Official: 颜色主题 Haskell Syntax Highlighting: Haskell 语法高亮 HTML Snippets: HTML自动补全 HTML CSS Support JavaScript (ES6) code snippets: JS自动补全 Markdown PDF: 神器, 但是默认会装一个Chromium npm Intellisense: 自动导入模块 Path Intellisense: 自动补全文件名 Quokka.js: 方便debug Vetur vscode-icons: vscode文件图标 Vue 2 Snippets yddict(npm): 查词, 非常方便, 安装:sudo npm i yddict -g, 用法: yd hello http-server(npm)","tags":["整理"]},{"title":"01背包问题","path":"/2019/03/19/01背包问题/","content":"问题描述背包： 总重 M物品数量： S物品： 重量 thingM ，价值 thingT需求：在背包能够承受的重量下，装下价值大的物品输入格式第一行为 2 个数字，分别为背包的总重 M 和物品的数量 S接下来的 M 行为每个物品的重量 thingM 以及物品的价值 thingTM &lt;&#x3D; 100 且 S &lt;&#x3D; 1000输出格式一个整数，代表能拿到的最大的价值 样例数据 123470 371 10069 11 2 分析问题01背包问题就在于一个物品，只有两种情况：拿或者不拿。这时就可以进行判断： 重量允许的情况下，拿价值高的方案 重量不允许则不拿 实现1234567891011121314Scanner input = new Scanner(System.in);int dp[][] = new int[101][1001];int M = input.nextInt(), S = input.nextInt();for (int i = 1; i &lt;= S; i++) &#123; int thingM = input.nextInt(), thingT = input.nextInt(); for (int j = 1; j &lt;= M; j++) &#123; if (j &gt;= thingM) &#123; // 可以拿 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - thingM] + thingT); &#125; else dp[i][j] = dp[i - 1][j]; // 不拿 &#125;&#125;System.out.println(dp[S][M]); 输出3 例题2一辆车，总共可以装 M 质量的物品，有 N 件物品，每件物品重 thingM 。能装的都装完后，还能剩下多少质量？输入格式第一行为一个整数，代表车的容量 M 。第二行为一个整数，代表物品数量 N 。接下来的 N 行，代表每个物品的重量。0 &lt;&#x3D; M &lt;&#x3D; 20000 且 0 &lt;&#x3D; N &lt;&#x3D; 20输出格式一个整数，代表剩余容量。样例数据 123456782468312797 代码12345678910111213int dp[][] = new int[31][20001];Scanner input = new Scanner(System.in);int V = input.nextInt(), Len = input.nextInt();for (int i = 1; i &lt;= Len; i++) &#123; int thingS = input.nextInt(); for (int j = 1; j &lt;= V; j++) &#123; if (j &gt;= thingS) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - thingS] + thingS); &#125; else dp[i][j] = dp[i - 1][j]; &#125;&#125;System.out.println(V - dp[Len][V]); 输出0","tags":["算法"]},{"title":"动态规划","path":"/2019/03/14/动态规划/","content":"思想通过把问题分解成子问题，再根据子问题的解得出原问题的解。例如：1+1+1 = 3，1+1+1+2 = 5。因为(1+1+1)+2 = 3 + 2 = 5。这时我们可以把每次计算过的值给存起来，这样下次计算时就不用重新计算。 用最少的东西拿需求的重量假设有个包，现在有1, 3, 3, 4四样东西，如何在规定的重量内拿到最少的物品。假设需要拿6重量的东西，如果用贪心就会拿到[4, 1, 1]，但是显然我们需要的是[3, 3]，这时就需要使用到上面的思想。 如果拿1重量的东西，需要[1] 如果拿3重量的东西，需要[3] 如果拿4重量的东西，需要[4] 如果拿5重量的东西，需要[4, 1] 如果拿6重量的东西，有[3, 3]和[4, 1, 1]两种解法，这时就需判是否有更优解。 代码： 12345678910111213141516171819202122232425262728293031323334print = (key) =&gt; console.log(key);class Package &#123; constructor(things) &#123; this.things = things; // 存放物品的数组 this.cache = &#123;&#125;; // 用于缓存 &#125; pick(weight) &#123; if (weight == 0) return []; let minWeight = []; // 查询缓存 if (this.cache[weight]) return this.cache[weight]; for (let i = 0, len = this.things.length; i &lt; len; i++) &#123; // 除去当前重量 let leftWeight = weight - this.things[i], newMinWeight; if (leftWeight &gt;= 0) &#123; // 用剩下的重量去查询 newMinWeight = this.pick(leftWeight); // 如果查询到的比现在的数组长度更短，更换数组 if (newMinWeight.length &lt; minWeight.length || minWeight.length == 0) minWeight = [this.things[i]].concat(newMinWeight); &#125; &#125; // 存放至缓存中 return this.cache[weight] = minWeight; &#125;&#125; 测试： 123var package = new Package([1, 3, 3, 4])print(package.pick(6)); // [3, 3]print(package.pick(10)); // [4, 3, 3]","tags":["整理"]},{"title":"图的邻接表表示法","path":"/2019/03/14/图的邻接表表示法/","content":"邻接表存储方式：表头存放节点，相邻节点存放于之后的链表中。** 使用 Map 模拟 ** 123456789101112131415161718192021222324class Graph &#123;constructor() &#123;this.point = [];this.map = new Map();&#125; addPoint(point) &#123; this.point.push(point); this.map.set(point, []); &#125; // 无向 addEdge(pointA, pointB) &#123; this.map.get(pointA).push(pointB); this.map.get(pointB).push(pointA); &#125; print() &#123; for (let item of this.point) &#123; console.log(item + &#x27; -&gt; &#x27; + this.map.get(item).join(&#x27;,&#x27;)); &#125; &#125;&#125; Test123456789101112131415var graph = new Graph()var topArr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;]for (let item of topArr) &#123;graph.addPoint(item);&#125;graph.addEdge(&#x27;A&#x27;, &#x27;B&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;E&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;H&#x27;);graph.addEdge(&#x27;F&#x27;, &#x27;G&#x27;);graph.addEdge(&#x27;I&#x27;, &#x27;B&#x27;);graph.addEdge(&#x27;I&#x27;, &#x27;C&#x27;);graph.print();","tags":["整理"]},{"title":"BST","path":"/2019/03/14/BST/","content":"Binary Search Tree 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。 若右子树不空，则右子树上所有结点的值均大于它的根结点的值。 左、右子树也分别为二叉排序树。 没有键值相等的节点。 实现Node： 12345678let print = (key) =&gt; console.log(key);class Node &#123; constructor(key) &#123; this.key = key; this.left = null; this.right = null; &#125;&#125; Tree： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145class BinarySearchTree &#123; constructor() &#123; this.root = null; &#125; insert(key) &#123; const node = new Node(key); if (this.root == null) &#123; this.root = node; &#125; else &#123; insertNode(this.root, node); &#125; function insertNode(parent, node) &#123; if (parent.key &gt; node.key) &#123; if (parent.left == null) &#123; parent.left = node; &#125; else &#123; insertNode(parent.left, node); &#125; &#125; else &#123; if (parent.right == null) &#123; parent.right = node; &#125; else &#123; insertNode(parent.right, node); &#125; &#125; &#125; &#125; inOrderTraverse() &#123; // 中序遍历 inOrderTraverse(this.root); function inOrderTraverse(node) &#123; if (node) &#123; inOrderTraverse(node.left); print(node.key); inOrderTraverse(node.right); &#125; &#125; &#125; preOrderTraverse() &#123; // 先序遍历 preOrderTraverse(this.root); function preOrderTraverse(node) &#123; print(node.key); preOrderTraverse(node.left); preOrderTraverse(node.right); &#125; &#125; postOrderTraverse() &#123; // 后序遍历 postOrderTraverse(this.root); function postOrderTraverse(node) &#123; postOrderTraverse(node.left); postOrderTraverse(node.right); print(node.key); &#125; &#125; max() &#123; let maxNode = &#123;&#125;; function getMax(node) &#123; if (node &amp;&amp; node.right) &#123; maxNode = node; getMax(node.right); &#125; &#125; getMax(this.root); return maxNode.key; &#125; min() &#123; let minNode = &#123;&#125;; function getMin(node) &#123; if (node &amp;&amp; node.left) &#123; minNode = node; getMin(node.left); &#125; &#125; getMin(this.root); return minNode.key; &#125; search(key) &#123; function findNode(node) &#123; if (!node) return false; if (key &gt; node.key) &#123; return findNode(node.right); &#125; else if (key &lt; node.key) &#123; return findNode(node.left); &#125; return node; &#125; return findNode(this.root); &#125; remove(key) &#123; if (!this.search(key)) return; // 调整二叉树 function adjustNode(current, key) &#123; if (key &lt; current.key) &#123; current.left = adjustNode(current.left, key); return current; &#125; else if (key &gt; current.key) &#123; current.right = adjustNode(current.right, key); return current; &#125; else &#123; // 左右都空直接删除 if (current.left === null &amp;&amp; current.right === null) &#123; return current = null; &#125; else if (current.right === null) &#123; // 处理左边不空 let temp = current.left; current = null; return temp; &#125; else if (current.left === null) &#123; // 处理右边不空 let temp = current.right; current = null; return temp; &#125; // 从需要删除的节点的右边寻找一个最小的节点，放置当前位置 current.key = minNode(current.right); // 调整后处理那个节点 current.right = adjustNode(current.right, current.key); return current; &#125; &#125; function minNode(node) &#123; if (node.left) return minNode(node.left); return node; &#125; adjustNode(this.root, key) &#125;&#125; ** Test ** 12345678910111213var tree = new BinarySearchTree()for (let i = 5; i &lt; 15; i++) &#123; tree.insert(i);&#125;for (let i = 30; i &gt; 15; i--) &#123; tree.insert(i);&#125;print(tree.search(6));tree.remove(15);tree.remove(10);tree.remove(29);tree.inOrderTraverse();","tags":["算法"]},{"title":"并查集","path":"/2019/03/13/并查集/","content":"并查集用集合中的某个元素来代表这个集合，该元素称为集合的代表元。一个集合内的所有元素组织成以代表元为根的树形结构。对于每一个元素parent[x]指向x在树形结构上的父亲节点。如果x是根节点，则令parent[x] = x。对于查找操作，假设需要确定x所在的的集合，也就是确定集合的代表元。可以沿着parent[x]不断在树形结构中向上移动，直到到达根节点。 节点表示： 1234var maxSize = 1000000;var parent = []; // 父亲节点数组var rank = []; // 深度数组var data = []; // 数据数组 初始化时都设置 parent 为自己的标号： 1234function makeSet(i) &#123; parent[i] = i; rank[i] = 0;&#125; 查找： 12345function findSet(i) &#123; if (parent[i] == i) return parent[i]; return findSet(parent[i]);&#125; 合并： 123456789101112function union(i, j) &#123; i = findSet(i); j = findSet(j); if (i == j) return; if (rank[i] &gt; rank[j]) &#123; parent[j] = i; &#125; else &#123; if (rank[i] == rank[j]) rank[j]++; parent[i] = j; &#125;&#125;","tags":["整理"]},{"title":"广度优先搜索","path":"/2019/03/13/广度优先搜索/","content":"广度优先搜索在 N * M 的网格中，从 start 走到 end 。广度解法：需要一个队列，从 start 节点开始，当一个节点抛出时，将它周围的节点入队，直至抛出的节点是 end 节点。模拟网格： 12345678910var map = [ // map[x][y] [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2],];find(map); 算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104function find(map) &#123; var maxX = map.length - 1, // 最大x坐标 maxY, // 最大y坐标 queue = [], // 寻路队列 start_x = -1, // 起始位置x坐标 start_y = -1, // 起始位置y坐标 end_x = -1, // 结束位置x坐标 end_y = -1, // 结束位置y坐标 unpassed = []; // 用于判断是否经过的数组 // 如果数组长度为0，返回 if (maxX &gt;= 0) &#123; maxY = map[0].length - 1; &#125; else &#123; return; &#125; // 寻找起始坐标和终止坐标 for (let i = 0, len = map.length; i &lt; len; i++) &#123; for (let j = 0, innerLen = map[i].length; j &lt; innerLen; j++) &#123; if (map[i][j] == 1) &#123; start_x = i; start_y = j; &#125; if (map[i][j] == 2) &#123; end_x = i; end_y = j; &#125; &#125; if (start_x != -1 &amp;&amp; end_x != -1) break; &#125; // 缺少起始位置或者结束位置 if (start_x == -1 || end_x == -1) &#123; console.log(&#x27;地图有误&#x27;); return; &#125; // 初始化路径数组 for (let i = 0, len = map.length; i &lt; len; i++) &#123; var result = []; for (let j = 0, innerLen = map[i].length; j &lt; innerLen; j++) &#123; result.push(true); &#125; unpassed.push(result); &#125; // 起始位置进入队列 queue.push([start_x, start_y]); do &#123; // 取出当前位置 var [current_x, current_y] = queue.shift(); // 判断是否经过 if (unpassed[current_x][current_y]) &#123; unpassed[current_x][current_y] = false; &#125; else &#123; continue; &#125; // 打印路径数组 show(unpassed); // 到达终点 if (current_x == end_x &amp;&amp; current_y == end_y) break; else &#123; // 上方位置入队 if (current_x &gt; 0) &#123; queue.push([current_x - 1, current_y]); &#125; // 右方位置入队 if (current_y &lt; maxY) &#123; queue.push([current_x, current_y + 1]); &#125; // 下方位置入队 if (current_x &lt; maxX) &#123; queue.push([current_x + 1, current_y]); &#125; // 左方位置入队 if (current_y &gt; 0) &#123; queue.push([current_x, current_y - 1]); &#125; &#125; &#125; while (true);&#125;function show(map) &#123; for (let i = 0, len = map.length; i &lt; len; i++) &#123; var str = &#x27;&#x27;; for (let j = 0, innerLen = map[i].length; j &lt; innerLen; j++) &#123; if (!map[i][j]) &#123; str += &#x27;*&#x27;; &#125; else str += &#x27;0&#x27;; &#125; console.log(str); &#125; console.log(&#x27;------&#x27;);&#125;","tags":["算法"]},{"title":"CSS垂直居中","path":"/2019/03/12/CSS垂直居中/","content":"HTML框架123456789101112131415&lt;style&gt; #box &#123; width: 300px; height: 300px; background-color: #ddd; &#125; #child &#123; width: 200px; height: 100px; background-color: orange; &#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt;target&lt;/div&gt;&lt;/div&gt; 绝对定位 + 负外边距 112345678#box &#123; position: relative;&#125;#child &#123; position: absolute; top: 50%; margin: -50px 0 0 0;&#125; 缺点：需要知道目标元素的高度 绝对定位 + 负外边距 2123456789#box &#123; position: relative;&#125;#child &#123; height: 30%; position: absolute; top: 50%; margin: -15% 0 0 0;&#125; 绝对定位 + transform12345678#box &#123; position: relative;&#125;#child &#123; position: absolute; top: 50%; transform: translate(0, -50%);&#125; 绝对定位 + margin: auto12345678910#box &#123; position: relative;&#125;#child &#123; position: absolute; top: 0; bottom: 0; margin: auto; line-height: 100px;&#125; flex1234#box &#123; display: flex; align-items: center;&#125;","tags":["整理"]},{"title":"前后端通信","path":"/2019/03/12/前后端通信/","content":"同源策略 同源策略（MDN 解释）：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 源：协议、域名、端口。 限制：无法获取 Cookie 、 LocalStorage 和 IndexDB ，无法操作 dom ，不能发送 Ajax 。 前后端通信方式 Ajax：不支持跨域。 WebSocket：支持跨域。 CORS：支持跨域。 onreadystatechange 事件readyState： 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求完成，响应就绪 触发顺序： xhr.onreadystatechange xhr.onloadstart xhr.upload.onloadstart xhr.upload.onprogress xhr.upload.onload xhr.upload.onloaded xhr.onprogress xhr.onload xhr.onloaded Ajax 请求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var ajax = function (param) &#123; // 兼容性处理 var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;) var type = (param.type || &#x27;get&#x27;).toUpperCase() var url = param.url if (!url) &#123; return &#125; var data = param.data, dataArr = [] // 构造数组 for (var key in data) &#123; dataArr.push(key + &#x27;=&#x27; + data[key]) &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;) xhr.open(type, url) xhr.send() &#125; else if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url) // post 请求头 xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) xhr.send(dataArr.join(&#x27;&amp;&#x27;)) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200 || xhr.status == 304) &#123; if (param.success &amp;&amp; param.success instanceof Function) &#123; var result = xhr.responseText if (typeof result === &#x27;string&#x27;) &#123; result = JSON.parse(result) param.success.call(xhr, result) &#125; &#125; &#125; &#125; &#125;&#125; update: Promise 改造 12345678910111213141516171819202122232425262728293031323334353637var ajax = (&#123;type, url, data, header&#125;) =&gt; new Promise((resolve, reject) =&gt; &#123; // 兼容性处理 var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;) type = (type || &#x27;get&#x27;).toUpperCase() if (!url) return let dataArr = [] // 构造数组 for (var key in data) &#123; dataArr.push(key + &#x27;=&#x27; + data[key]) &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;) xhr.open(type, url) xhr.send() &#125; else if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url) // post 请求头 xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) for (let key in header) xhr.setRequestHeader(key, header[key]) xhr.send(dataArr.join(&#x27;&amp;&#x27;)) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200 || xhr.status == 304) &#123; resolve.call(undefined, xhr.responseText) &#125; else reject.call(undefined, xhr) &#125; &#125; &#125;) 跨域通信的方式： JSONP：只支持 GET 请求，通过 script 的异步加载实现 WebSocket CORS：跨域时，会在请求头增加 Origin 字段 Hash postMessage： window.postMessage() 发送","tags":["整理"]},{"title":"前端 .gitignore文件的配置","path":"/2019/03/05/前端-gitignore文件的配置/","content":".gitignore文件的配置123456789101112131415161718192021222324252627282930313233343536373839404142# Numerous always-ignore extensions *.bak *.patch *.diff *.err # temp file for git conflict merging *.orig *.log *.rej *.swo *.swp *.zip *.vi *~ *.sass-cache *.tmp.html *.dump # OS or Editor folders .DS_Store ._* .cache .project .settings .tmproj *.esproj *.sublime-project *.sublime-workspace nbproject thumbs.db *.iml # Folders to ignore .hg .svn .CVS .idea node_modules/ jscoverage_lib/ bower_components/ dist/","tags":["整理"]},{"title":"全排列思想","path":"/2019/03/05/全排列思想/","content":"全排列的思想从n个不同元素中任取m（m&lt;&#x3D;n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m&#x3D;n时所有的排列情况叫全排列。这时候我们就可以来思考，如何取得所有排列的情况。例如数组[1, 2, 3, 4]，我们可以先固定一个数字1，这时候剩下的数组就变成了[2, 3, 4]。此时再固定一个数字2，数组剩下[3, 4]。再固定3，这时候数组就只剩下[4]，就可以输出一个序列 -&gt; [1, 2, 3, 4]。这时候将3解除固定，与4交换，再固定4，这时又可以输出一个序列 -&gt; [1, 2, 4, 3]。这样固定1, 2时候的所有情况就排列出来了，再继续将2解除固定，并与3交换。这时候就固定了1, 3，数组剩下[2, 4]，再重复上面的方法，直到所有固定两个数的排列都排完后，再交换固定的第一个数，这样就可以推出全排列。 递归的实现12345678910111213141516171819202122232425262728293031323334353637function Perm(arr, current, count) &#123; // 前面的数都已固定完 if (current == count) &#123; let str = &#x27;&#x27;; for (let i = 0; i &lt;= count; i++) &#123; str += arr[i]; &#125; console.log(str); &#125; else &#123; for (let i = current; i &lt;= count; i++) &#123; // 不相同才交换 if (sample(arr, current, i)) &#123; // 将数字挨个交换 [arr[i], arr[current]] = [arr[current], arr[i]]; // 交换后执行递归函数 Perm(arr, current + 1, count); // 数字交换后需要复原 [arr[i], arr[current]] = [arr[current], arr[i]]; &#125; &#125; &#125;&#125;function sample(arr, start, end) &#123; for (let i = start; i &lt; end; i++) &#123; if (arr[i] == arr[end]) &#123; return false; &#125; &#125; return true;&#125;let arr = [1, 2, 2, 1];Perm(arr, 0, arr.length - 1); 结果： 123456122112121122212121122211 非递归的实现** 会重复 ** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function permutation(arr) &#123; let total = 1; // 计算排列种数 for (let i = 2; i &lt;= arr.length; i++) &#123; total *= i; &#125; print_r(arr); for (let i = 0; i &lt; total; i++) &#123; let k = arr.length - 1, min = Number.MAX_VALUE, minIndex = 0; // 从后开始遍历，找到底一个非增的元素，和后面某个刚好大于它的元素替换 while (k &gt; 0 &amp;&amp; arr[k] &lt; arr[--k]); // 找到刚好比替换到前面大的元素 for (let j = arr.length - 1; j &gt;= k + 1; j--) &#123; if (arr[j] &gt; arr[k] &amp;&amp; min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; //与找到的元素 进行交换 [arr[k], arr[minIndex]] = [arr[minIndex], arr[k]]; // 数组倒置 for (let m = 0; m &lt; (arr.length - k - 1) / 2; m++) &#123; [arr[k + 1 + m], arr[arr.length - 1 - m]] = [arr[arr.length - 1 - m], arr[k + 1 + m]] &#125; print_r(arr); &#125;&#125;function sample(arr, start, end) &#123; for (let i = start; i &lt; end; i++) &#123; if (arr[i] == arr[end]) &#123; return false; &#125; &#125; return true;&#125;function print_r(arr) &#123; let str = &#x27;&#x27;; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; str += arr[i]; &#125; console.log(str);&#125;","tags":["算法"]},{"title":"排序算法","path":"/2019/02/28/排序算法/","content":"简单插入排序1234567891011121314151617function insertSort(arr) &#123; for (let i = 1, len = arr.length; i &lt; len; i++) &#123; if (arr[i] &lt; arr[i - 1]) &#123; let current = i - 1; // the position need to move let temp = arr[i]; // the value need to insert arr[i] = arr[current]; while (temp &lt; arr[current]) &#123; arr[current + 1] = arr[current]; // move backward current--; &#125; arr[current + 1] = temp; &#125; &#125;&#125;let arr = [6, 7, 2, 3, 1, 5, 4];insertSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 希尔排序由于JavaScript的数据都是用浮点数存储的，所以需要用到parseInt() 123456789101112131415161718192021222324function shellSort(arr) &#123; let dert = parseInt(arr.length / 2); while (dert &gt;= 1) &#123; shellInsertSort(arr, dert); dert = parseInt(dert / 2); // compute the shell step &#125;&#125;function shellInsertSort(arr, dert) &#123; for (let i = dert, len = arr.length; i &lt; len; i++) &#123; if (arr[i] &lt; arr[i - dert]) &#123; let current = i - dert; let temp = arr[i]; arr[i] = arr[current]; while (temp &lt; arr[current]) &#123; arr[current + dert] = arr[current]; current -= dert; &#125; arr[current + dert] = temp; &#125; &#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];shellSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 简单选择排序123456789101112131415161718192021function minIndex(arr, start) &#123; // find the mini index let min = start; for (let i = start + 1, len = arr.length; i &lt; len; i++) &#123; if (arr[min] &gt; arr[i]) min = i; &#125; return min;&#125;function selectSort(arr) &#123; let key = 0; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; key = minIndex(arr, i); if (key != i) &#123; // if the mini index is not the current index then exchange value [arr[key], arr[i]] = [arr[i], arr[key]]; &#125; &#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];selectSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 堆排序1234567891011121314151617181920212223242526272829303132333435363738function heapAdjust(arr, index, length) &#123; // adjust the heap let temp = arr[index], child = index * 2 + 1; while (child &lt; length) &#123; if (child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123; // find the more big child child++; &#125; if (arr[index] &lt; arr[child]) &#123; // exchange the parentNode and the childNode arr[index] = arr[child]; index = child; child = index * 2 + 1; &#125; else &#123; break; &#125; &#125; arr[index] = temp;&#125;function buildHeap(arr) &#123; // create the heap let len = arr.length; for (let i = (arr.length - 1) / 2; i &gt;= 0; i--) &#123; heapAdjust(arr, i, len); &#125;&#125;function heapSort(arr) &#123; buildHeap(arr); for (let i = arr.length - 1; i &gt;= 0; i--) &#123; // exchange the 0th value and ith value [arr[i], arr[0]] = [arr[0], arr[i]]; heapAdjust(arr, 0, i); &#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];heapSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 冒泡排序12345678910111213141516function bubbleSort(arr) &#123; let index = arr.length - 1; while (index &gt; 0) &#123; let pos = 0; for (let j = 0; j &lt; index; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; pos = j; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; index = pos; &#125;&#125;let arr = [6, 7, 2, 3, 1, 4, 5];bubbleSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 快速排序1234567891011121314151617181920212223242526function partition(arr, low, high) &#123; let key = arr[low]; while (low &lt; high) &#123; // from right to left to find a value that lower than key while (low &lt; high &amp;&amp; arr[high] &gt;= key) high--; [arr[low], arr[high]] = [arr[high], arr[low]]; // from left to right to find a value thar large than key while (low &lt; high &amp;&amp; arr[low] &lt;= key) low++; [arr[low], arr[high]] = [arr[high], arr[low]]; &#125; return low;&#125;function quickSortFunc(arr, low, high) &#123; if (low &lt; high) &#123; // binary iterations let local = partition(arr, low, high); quickSortFunc(arr, low, local - 1); quickSortFunc(arr, local + 1, high); &#125;&#125;function quickSort(arr) &#123; quickSortFunc(arr, 0, arr.length - 1);&#125;let arr = [6, 7, 2, 3, 1, 4, 5];quickSort(arr);console.log(arr); 结果：Array(7) [1, 2, 3, 4, 5, 6, 7] 归并排序1234567891011121314151617181920212223function merge(arr1, arr2) &#123; let result = [], length1 = arr1.length, length2 = arr2.length, index1 = 0, index2 = 0, reindex = 0; while (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123; if (arr1[index1] &lt; arr2[index2]) &#123; result[reindex++] = arr1[index1++]; &#125; else &#123; result[reindex++] = arr2[index2++]; &#125; &#125; while (index1 &lt; length1) result[reindex++] = arr1[index1++]; while (index2 &lt; length2) result[reindex++] = arr2[index2++]; return result;&#125;let arr1 = [2, 4, 6, 8, 10], arr2 = [1, 3, 5, 7, 9];let result = merge(arr1, arr2);console.log(result); 结果：Array(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","tags":["算法"]},{"title":"简单的LinkList实现","path":"/2019/02/28/简单的LinkList实现/","content":"简单的LinkList实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Node &#123; constructor(data = -1, prev = null, next = null) &#123; this.data = data; this.prev = prev; // 向前指针 this.next = next; // 向后指针 &#125;&#125;class LinkList &#123; constructor() &#123; this.head = this.tail = null; // 首、尾指针 this.size = 0; // 元素个数 &#125; addHead(elem) &#123; let elemNode = new Node(elem); if (this.size == 0) &#123; this.head = this.tail = elemNode; this.size++; &#125; else &#123; this.head.prev = elemNode; elemNode.next = this.head; this.head = elemNode; this.size++; &#125; return true; &#125; deleteHead() &#123; if (this.size != 0) &#123; let elem = this.head.data; this.head.prev = null; this.head = this.head.next; this.size--; return elem; &#125; else &#123; console.log(&#x27;list is empty&#x27;); return; &#125; &#125; addTail(elem) &#123; let elemNode = new Node(elem); if (this.size == 0) &#123; this.head = this.tail = elemNode; this.size++; &#125; else &#123; elemNode.prev = this.tail; this.tail.next = elemNode; this.tail = elemNode; this.size++; &#125; return true; &#125; deleteTail() &#123; if (this.size != 0) &#123; let elem = this.tail.data; this.tail.next = null; this.tail = this.tail.prev; this.size--; return elem; &#125; else &#123; console.log(&#x27;list is empty&#x27;); return; &#125; &#125; display() &#123; let current = this.head, count = this.size, str = &#x27;&#x27;; while (count &gt; 0) &#123; str += current.data + &#x27; &#x27; current = current.next; count--; &#125; console.log(str); &#125;&#125;let linklist = new LinkList();linklist.addHead(1);linklist.addHead(2);linklist.addHead(3);linklist.deleteHead();linklist.addTail(4);linklist.display(); 结果2 1 4","tags":["算法"]},{"title":"简单的Queue实现","path":"/2019/02/28/简单的Queue实现/","content":"简单的Queue实现数组实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Queue &#123; constructor(size = 10) &#123; this.size = size; // 队列最大长度 this.top = 0; // 首位置 this.bottom = -1; // 尾位置 this.elems = 0; // 成员个数 this.arr = [] // 队列 &#125; add(elem) &#123; if (this.elems == this.size) &#123; console.log(&#x27;Queue is full&#x27;); return; &#125; if (this.bottom == this.size - 1) &#123; // 循环队列 this.bottom = -1; &#125; this.arr[++this.bottom] = elem; this.elems++; return true; &#125; out() &#123; if (this.elems == 0) &#123; console.log(&#x27;Queue is empty&#x27;); return; &#125; let elem = this.arr[this.top] this.arr[this.top] = null; this.top++; if (this.top == this.size) &#123; this.top = 0; &#125; this.elems--; return elem; &#125;&#125;var queue = new Queue();queue.add(3);queue.add(2);console.log(queue.out())console.log(queue.out())console.log(queue.out()) 链式实现12345678910111213141516171819202122232425262728293031323334353637class Node &#123; constructor(data = -1, next = null) &#123; this.data = data; this.next = next; &#125;&#125;class Queue &#123; constructor() &#123; this.top = null; // 首指针 this.bottom = null; // 尾指针 this.elems = 0; // 成员个数 &#125; add(elem) &#123; if (this.elems == 0) &#123; this.top = this.bottom = new Node(elem); &#125; else &#123; let newNode = new Node(elem); this.bottom.next = newNode; this.bottom = newNode; &#125; this.elems++; &#125; out() &#123; if (this.elems == 0) &#123; console.log(&#x27;queue is empty&#x27;); return; &#125; let current = this.top; let value = current.data; this.top = this.top.next; this.elems--; this.current = null; return value; &#125;&#125; 结果123432Queue is emptyundefined","tags":["算法"]},{"title":"简单的Stack实现","path":"/2019/02/28/简单的Stack实现/","content":"简单的Stack实现数组实现1234567891011121314151617181920212223242526272829303132333435363738394041class Stack &#123; constructor(size = 10) &#123; this.arr = []; // 栈 this.size = size; // 最大长度 this.top = -1; // 栈顶 &#125; push(elem) &#123; if (this.top == this.size) &#123; this.size *= 2; &#125; this.arr[++this.top] = elem; return true; &#125; pop() &#123; let elem = this.arr[this.top--]; return elem; &#125; peekTop() &#123; if (this.top == -1) &#123; console.log(&#x27;stack is empty&#x27;); return; &#125; return this.arr[this.top]; &#125; print() &#123; let str = &#x27;&#x27; for (let i = 0; i &lt;= this.top; i++) &#123; str += this.arr[i] + &#x27; &#x27; &#125; console.log(str) &#125;&#125;var stack = new Stack();stack.push(1);stack.push(2);stack.pop();console.log(stack.peekTop()) 链式实现12345678910111213141516171819202122232425262728293031323334class Node &#123; constructor(data = -1, next = null) &#123; this.data = data; this.next = next; &#125;&#125;class Stack &#123; constructor() &#123; this.top = null; // 栈顶 this.elems = 0; // 成员个数 &#125; push(elem) &#123; this.top = new Node(elem, this.top); this.elems++; &#125; pop() &#123; if (this.elems == 0) &#123; console.log(&#x27;stack is empty&#x27;); return; &#125; let current = this.top; let elem = current.data; this.top = this.top.next; this.elems--; current = null; return elem; &#125; peekTop() &#123; return this.top.data; &#125;&#125; 结果：1","tags":["算法"]},{"title":"简单的Array实现","path":"/2019/02/28/简单的Array实现/","content":"简单的Array实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Array &#123; constructor(size = 10) &#123; this.arr = []; // 数组 this.size = size; // 最大长度 this.elems = 0; // 成员数量 &#125; add(elem) &#123; if (this.arr.length == this.size) &#123; console.log(&#x27;Array is full&#x27;); return; &#125; this.arr[this.elems++] = elem; return true; &#125; find(elem) &#123; for (let i = 0, len = this.elems; i &lt; len; i++) &#123; if (this.arr[i] == elem) return i; &#125; return -1; &#125; delete(elem) &#123; let index = this.find(elem); if (index == -1) &#123; console.log(&#x27;Element not found&#x27;); return; &#125; for (let i = index, len = this.elems - 1; i &lt; len; i++) this.arr[i] = this.arr[i + 1]; this.elems--; return true; &#125; update(oldVal, newVal) &#123; // only use for unique element let index = this.find(oldVal); if (index == -1) &#123; console.log(&#x27;Element not found&#x27;); return; &#125; this.arr[index] = newVal; return true; &#125; display() &#123; let srt = &#x27;&#x27;; for (let i = 0, len = this.elems; i &lt; len; i++) &#123; srt += &#x27;&#x27; + this.arr[i] + &#x27; &#x27;; &#125; console.log(srt); &#125; length() &#123; return this.elems; &#125;&#125;var arr = new Array();arr.add(1);arr.add(2);arr.add(3);arr.add(4);arr.display();console.log(arr.length()); 结果121 2 3 44","tags":["算法"]},{"title":"一道有趣的题目","path":"/2019/02/26/一道有趣的题目/","content":"在CodeWars上遇见的一道3kyu的题目** Task **You’re given an array of integers a and two integers x and y. Count the number of elements in the array such that x ≤ a[i] ≤ y, where i is the 0-based index of the element. ** Code Limit **Less than 48 characters. ** Example **For a &#x3D; [2, 5, 6, 7, 1, 3, 4, 11, 56, 49], x &#x3D; 1 and y &#x3D; 7, the output should be 7. elements 2, 5, 6, 7, 1, 3, 4 should be counted. 这道题有趣的地方在于，代码长度限制在48个字符内。最开始我用的是forEach去遍历，结果长度超出了一倍，后面考虑用filter： 1checkRange=(a,x,y)=&gt;a.filter(e=&gt;e&gt;=x&amp;&amp;e&lt;=y).length 但是此时代码长度也有50，考虑使用map来改造，但是map和filter不一样，数组的长度无法改变，所以就考虑使用一个变量来统计。 1234// 在JS中数值与true相加会使得结果增加一，所以可以考虑使用变量来与判断的结果相加。// i=0未定义，在此是全局变量。// Array | Number =&gt; parseInt(Array) | Number =&gt; NaN | Number =&gt; Number, 所以 i 就被返回出去了checkRange=(a,x,y)=&gt;a.map(e=&gt;i+=(x&lt;=e&amp;&amp;e&lt;=y),i=0)|i 但是此时长度还是不够，问题在于x&lt;&#x3D;e&amp;&amp;x&lt;&#x3D;y这。仔细分析可知，不满足条件的话，有两种情况，第一种就是a[i] &lt; x，第二种是a[i] &gt; y所以只要a[i] &lt; x &amp;&amp; a[i] &gt; y的结果为false的话 那么就是不满足条件的。此时可以改造为 x &gt; a[i] &#x3D;&#x3D; a[i] &gt; y a[i] &lt; x &lt; y &#x3D;&gt; true &#x3D;&#x3D; false &#x3D;&gt; false x &lt; y &lt; a[i] &#x3D;&gt; false &#x3D;&#x3D; true &#x3D;&gt; false x &lt; a[i] &lt; y &#x3D;&gt; false &#x3D;&#x3D; false &#x3D;&gt; true 此时满足条件。 最后答案为： 1checkRange=(a,x,y)=&gt;a.map(e=&gt;i+=x&gt;e==e&gt;y,i=0)|i","tags":["算法","整理"]},{"title":"ES6读取文件","path":"/2019/02/26/ES6读取文件/","content":"** 需求：已知一个路径，读取文件内容并返回 ** 普通读取文件方式：123456const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)fs.readFile(path.join(__dirname, &#x27;./1.txt&#x27;), &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123; if (err) throw err console.log(dataStr)&#125;) 封装函数：12345678function getFileByPath(fpath, callback) &#123; fs.readFile(fpath, &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123; // 如果报错，后面的代码无意义 if (err) return callback(err) // console.log(dataStr) callback(null, dataStr) &#125;)&#125; 调用函数：1234getFileByPath(path.join(__dirname, &#x27;./1.txt&#x27;), (err, dataStr) =&gt; &#123; if (err) return console.log(err.message) console.log(dataStr);&#125;) ** 新需求：顺序读取文件 ** 回调嵌套：123456789getFileByPath(path.join(__dirname, &#x27;./1.txt&#x27;), data =&gt; &#123; console.log(data) getFileByPath(path.join(__dirname, &#x27;./2.txt&#x27;), data =&gt; &#123; console.log(data) getFileByPath(path.join(__dirname, &#x27;./3.txt&#x27;), data =&gt; &#123; console.log(data) &#125;) &#125;)&#125;) 用Promise改造：12345678910111213141516171819202122232425function getFileByPath(fpath) &#123; // 改造function return new Promise(function (resolve, reject) &#123; fs.readFile(fpath, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;getFileByPath(&#x27;./1.txt&#x27;).then(function (data) &#123; // 读取文件 console.log(data) return getFileByPath(&#x27;./2.txt&#x27;)&#125;, function (err) &#123; console.log(err.message) return getFileByPath(&#x27;./2.txt&#x27;)&#125;).then(function (data) &#123; console.log(data) return getFileByPath(&#x27;./3.txt&#x27;)&#125;, function (err) &#123; console.log(err.message) return getFileByPath(&#x27;./3.txt&#x27;)&#125;).then(function (data) &#123; console.log(data)&#125;, function (err) &#123; console.log(err.message)&#125;)","tags":["整理"],"categories":["ECMAScript"]},{"title":"Vue总结（三）","path":"/2019/02/26/Vue总结（三）/","content":"computed123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;&#x27;, lastName: &#x27;&#x27;, &#125;, computed: &#123; // 使用计算属性不需要() // 只要此function中使用的任何数据发生变化，就会重新计算值 fullName: function () &#123; return this.firstName + &#x27;-&#x27; + this.lastName &#125; &#125; &#125;)&lt;/script&gt; watch123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; @keyup=&quot;getFullName&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; @keyup=&quot;getFullName&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;&#x27;, lastName: &#x27;&#x27;, fullName: &#x27;&#x27; &#125;, methods: &#123; getFullName() &#123; this.fullName = this.firstName + &#x27;-&#x27; + this.lastName &#125; &#125;, watch: &#123; firstName: function (newValue, oldValue) &#123; this.fullName = newValue + &#x27;-&#x27; + this.lastName console.log(oldValue) &#125;, lastName: function (newValue) &#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125; &#125;)&lt;/script&gt; 全局组件1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component2&gt;&lt;/my-component2&gt;&lt;/div&gt;&lt;template id=&quot;tmp1&quot;&gt; &lt;h1&gt;template 1&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; var com1 = Vue.extend(&#123; template: `&lt;h3&gt;Vue.extend&lt;/h3&gt;` &#125;) Vue.component(&#x27;my-component2&#x27;, &#123; template: &#x27;#tmp1&#x27; &#125;) Vue.component(&#x27;my-component&#x27;, com1) var vm = new Vue(&#123; el: &#x27;#app&#x27;, &#125;)&lt;/script&gt; 私有组件1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;login&gt;&lt;/login&gt; &lt;test-component&gt;&lt;/test-component&gt;&lt;/div&gt;&lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt;Message&lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; login: &#123; template: &#x27;&lt;h1&gt;private component&lt;/h1&gt;&#x27; &#125;, testComponent: &#123; template: &#x27;#tmp1&#x27; &#125; &#125; &#125;)&lt;/script&gt; 组件传值123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;com1 v-bind:parent-msg=&quot;msg&quot;&gt;&lt;/com1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;parent message&#x27; &#125;, components: &#123; com1: &#123; props: [&#x27;parentMsg&#x27;], // 父组件的数据 readonly template: &#x27;&lt;h1 @click=&quot;change&quot;&gt;fff --- &#123; &#123; parentMsg &#125; &#125;&lt;/h1&gt;&#x27;, data() &#123; // 组件私有的，ajax请求的数据可以放在组件的data上 readwrite return &#123; title: &#x27;abd&#x27; &#125; &#125;, methods: &#123; change() &#123; this.parentMsg = &#x27;changed&#x27; &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 组件传递method123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;app&quot;&gt; &lt;com2 v-on:func=&quot;show&quot;&gt;&lt;/com2&gt;&lt;/div&gt;&lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;child template&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;child button&quot; v-on:click=&quot;myClick&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var com2 = &#123; template: &#x27;#tmpl&#x27;, data() &#123; return &#123; childMsg: &#123; name: &#x27;Edward&#x27;, age: 3 &#125; &#125; &#125;, methods: &#123; myClick() &#123; console.log(&#x27;myClick called&#x27;) this.$emit(&#x27;func&#x27;, this.childMsg) &#125; &#125; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dataFromChild: null &#125;, components: &#123; com2 &#125;, methods: &#123; show(data) &#123; this.dataFromChild = data // 子组件向父组件传值 &#125; &#125; &#125;)&lt;/script&gt; 组件切换123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;flag = true&quot;&gt;Login in&lt;/a&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;flag = false&quot;&gt;Sign in&lt;/a&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else&gt;&lt;/register&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;comName = &#x27;login&#x27;&quot;&gt;Login in&lt;/a&gt; &lt;a href=&quot;&quot; v-on:click.prevent=&quot;comName = &#x27;register&#x27;&quot;&gt;Sign in&lt;/a&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;Login&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;Register&lt;/h3&gt;&#x27; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true, comName: &#x27;login&#x27; &#125; &#125;)&lt;/script&gt; vue-router123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;!-- tag改变展示元素 --&gt; &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;login&lt;/h1&gt;&#x27; &#125; var register = &#123; template: &#x27;&lt;h1&gt;register&lt;/h1&gt;&#x27; &#125; const routerObj = new VueRouter(&#123; routes: [ // 路由匹配规则 path, component必须参数 &#123; path: &#x27;/&#x27;, redirect: &#x27;/login&#x27; &#125;, // redirect 重定向 &#123; path: &#x27;/login&#x27;, component: login &#125;, &#123; path: &#x27;/register&#x27;, component: register &#125; ], linkActiveClass: &#x27;myactive&#x27; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; &#125;, router: routerObj &#125;)&lt;/script&gt; 路由传参123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login?id=10&amp;name=zhangsan&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;Login --- &#123; &#123; $route.query.id &#125; &#125; --- &#123; &#123; $route.query.name &#125; &#125;&lt;/h1&gt;&#x27;, data() &#123; return &#123; msg: &#x27;123&#x27; &#125; &#125;, created() &#123; // 组件的生命周期 console.log(this.$route.query.id) &#125;, &#125; var register = &#123; template: &#x27;&lt;h1&gt;Register&lt;/h1&gt;&#x27; &#125; const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/login&#x27;, component: login &#125;, &#123; path: &#x27;/register&#x27;, component: register &#125; ] &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, router &#125;)&lt;/script&gt; 路由嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;Account component&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;Register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var account = &#123; template: &#x27;#tmpl&#x27; &#125; var login = &#123; template: &#x27;&lt;h1&gt;Login&lt;/h1&gt;&#x27; &#125; var register = &#123; template: &#x27;&lt;h1&gt;Register&lt;/h1&gt;&#x27; &#125; const router = new VueRouter(&#123; routes: [&#123; path: &#x27;/account&#x27;, component: account, children: [ // 子路由path不带 &#x27;/&#x27; 否则以根目录还是匹配 &#123; path: &#x27;login&#x27;, component: login &#125;, &#123; path: &#x27;register&#x27;, component: register &#125; ] &#125;, ] &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, router &#125;)&lt;/script&gt; render渲染组件123456789101112131415161718&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;Login&lt;/h1&gt;&#x27; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; &#125;, render: function (createElements) &#123; // 将指定的模板渲染成html return createElements(login) // return的结果会替换el指定的容器 &#125; &#125;)&lt;/script&gt;","tags":["整理"],"categories":["Vue"]},{"title":"Vue总结（二）","path":"/2019/02/26/Vue总结（二）/","content":"filter123456789101112Vue.filter(&#x27;msgFormat&#x27;, function (msg, arg) &#123; return msg.replace(/test/g, arg)&#125;)Vue.filter(&#x27;test&#x27;, function (msg) &#123; return msg + &#x27;====&#x27;&#125;)var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;test1 test2 test3&#x27; &#125;&#125;) privateFilter12345678910111213141516171819202122var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dt: new Date() &#125;, filters: &#123; dateFormate: function (dateStr, pattern = &#x27;&#x27;) &#123; var dt = new Date(dateStr) var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() if (pattern.toLowerCase() == &#x27;yyyy-mm-dd&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125;&#125;) ** eg: ** 12345678910111213141516171819202122var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dt: new Date() &#125;, filters: &#123; dateFormate: function (dateStr, pattern = &#x27;&#x27;) &#123; var dt = new Date(dateStr) var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, &#x27;0&#x27;) var d = dt.getDate().toString().padStart(2, &#x27;0&#x27;) if (pattern.toLowerCase() == &#x27;yyyy-mm-dd&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` else &#123; var hh = dt.getHours().toString().padStart(2, &#x27;0&#x27;) var mm = dt.getMinutes().toString().padStart(2, &#x27;0&#x27;) var ss = dt.getSeconds().toString().padStart(2, &#x27;0&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125;&#125;) Lifecycle1234567891011121314151617181920212223242526272829303132333435363738394041424344var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;ok&#x27; &#125;, methods: &#123; show() &#123; console.log(&#x27;run show&#x27;) &#125; &#125;, beforeCreate() &#123; // data和methods数据都未初始化 // console.log(this.msg) // this.show() &#125;, created() &#123; console.log(this.msg) this.show() &#125;, beforeMount() &#123; // 编译好了模板，还未挂载到页面中 console.log(document.getElementById(&#x27;h3&#x27;).innerText) &#125;, mounted() &#123; // 模板已经挂载到页面中 console.log(document.getElementById(&#x27;h3&#x27;).innerText) // mounted之后表示Vue实例已经被完全创建好了 &#125;, beforeUpdate() &#123; // 数据改变，页面未变 console.log(document.getElementById(&#x27;h3&#x27;).innerText) &#125;, updated() &#123; // 数据和页面都改变了 &#125;, beforeDestroy() &#123; // data 和 methods 都可以使用 &#125;, destroyed() &#123; // 完全销毁 &#125;,&#125;)","tags":["整理"],"categories":["Vue"]},{"title":"Vue总结（一）","path":"/2019/02/26/Vue总结（一）/","content":":class绑定12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;[&#x27;italic&#x27;, &#x27;red&#x27;, &#123;&#x27;active&#x27;: flag&#125;]&quot;&gt;Test H1 Message&lt;/h1&gt; &lt;h1 :class=&quot;classObj&quot;&gt;Test H1 Message&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true, classObj: &#123; red:true, thin:true, italic:true, active:false&#125; &#125; &#125;)&lt;/script&gt; :style绑定1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;[styleObj, styleObj2]&quot;&gt;This is H1&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; styleObj: &#123; color: &#x27;red&#x27;, &#x27;font-weight&#x27;: &#x27;280&#x27; &#125;, styleObj2: &#123; &#x27;font-style&#x27;: &#x27;italic&#x27; &#125; &#125; &#125;)&lt;/script&gt; preventDefault123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;inner&quot; @click=&quot;divHandler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;click me&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;a href=&quot;http://github.io&quot; @click.prevent=&quot;linkClick&quot;&gt;link&lt;/a&gt; &lt;div class=&quot;inner&quot; @click.capture=&quot;divHandler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;click me&quot; @click.stop=&quot;btnHandler&quot;&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot; @click.self=&quot;divHandler&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;click me&quot; @click.self=&quot;btnHandler&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; divHandler() &#123; console.log(&#x27;inner div&#x27;) &#125;, btnHandler() &#123; console.log(&#x27;btn click&#x27;) &#125;, linkClick() &#123; console.log(&#x27;link click&#x27;) &#125; &#125; &#125;)&lt;/script&gt; v-cloak1234567891011121314151617&lt;style&gt; [v-cloak] &#123; display: none !important; &#125; &lt;/style&gt;&lt;div id=&quot;app&quot; v-cloak&gt; &lt;p&gt;&#123; &#123; msg &#125; &#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;ss&#x27; &#125; &#125;)&lt;/script&gt; v-for123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;item in list&quot;&gt;&#123; &#123; item.id &#125; &#125; --- &#123; &#123; item.name &#125; &#125;&lt;/p&gt; &lt;p v-for=&quot;(value, key) in user&quot;&gt;&#123; &#123; key &#125; &#125; -- &#123; &#123; value &#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#123; id: 1, name: &#x27;name1&#x27; &#125;, &#123; id: 2, name: &#x27;name2&#x27; &#125;, &#123; id: 3, name: &#x27;name3&#x27; &#125;, &#123; id: 4, name: &#x27;name4&#x27; &#125;, ], user: &#123; id: 1, name: &#x27;Hello world&#x27;, gender: &#x27;male&#x27; &#125; &#125; &#125;)&lt;/script&gt; ** eg: ** 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label for=&quot;id&quot;&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label for=&quot;name&quot;&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;p v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;&#123; &#123; item.id &#125; &#125; --- &#123; &#123; item.name &#125; &#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [&#123; id: 1, name: &#x27;孔子&#x27; &#125;, &#123; id: 2, name: &#x27;孟子&#x27; &#125;, &#123; id: 3, name: &#x27;韩非子&#x27; &#125;, ] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;)&lt;/script&gt; v-if1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag = !flag&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;V-IF&lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt;V-SHOW&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;)&lt;/script&gt;","tags":["整理"],"categories":["Vue"]},{"title":"webpack配置","path":"/2019/02/25/webpack配置/","content":"项目文件目录123456789101112-Demo|--build|--dist |--css |--js |--view|--node_modules|--src |--|--package.json|--webpack.config.js|--webpack.production.config.js src：代码开发目录 build：开发环境webpack输出目录 dist：生产环境webpack输出目录 package.json：项目配置 webpack.config.js：开发环境配置 webpack.production.config.js：生产环境配置 webpack配置文件需命名为webpack.config.js 123456789101112131415161718192021222324252627282930313233const path = require(&#x27;path&#x27;) // 模块module.exports = &#123; mode: &#x27;development&#x27;, entry: path.join(__dirname, &#x27;./src/main.js&#x27;), // 入口文件 output: &#123; path: path.join(__dirname, &#x27;./dist&#x27;), // 输出文件 filename: &#x27;bundle.js&#x27; &#125;, plugins: [ // 插件 ], module: &#123; rules: [ // 路由规则 &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: &#x27;url-loader?limit=1111&amp;name=[hash:8]-[name].[ext]&#x27; &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: &#x27;url-loader&#x27; &#125;, &#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125;, ] &#125;,&#125; webpack-dev-server 通过npm安装：npm i webpack-dev-server 运行命令：webpack-dev-server –devtool eval –port 9876 –progress –colors – compress –hot –inline –content-base .&#x2F;build可以在package.json中的script加一个启动项。 –devtool eval：在报错时精确到文件的行号 –progress：显示编译的输出内容进度 –compress：启用gzip压缩 –hot：热更新，无需刷新浏览器 –colors：显示编译的输出内容颜色 –inline：自动刷新模式。默认为iframe。 –content-base：设置输出目录。","tags":["整理","学习"]},{"title":"广州之行","path":"/2018/12/24/广州之行/","content":"导语想着下学期开始可能没有太多时间了，而且大学间还没有旅过游，所以就挑了个时间去了广州。由于时间不是很足，所以去的地方不是很多，主要还是那几个比较火的地点： 上下九 北京路 江南西 海珠区 而且……拍的照也不是很多。 上火车本以为挑的时间段算比较好的，但是失算了。火车上挺多人的，但是与春运相比又显得人挺少的。可能大部分都是去考研的吧，很多背着包的大学生。对面的老大爷和右边的是一家，听口音像是潮州那边的。半道老大爷还拿出了一瓶葡萄酒，喝了起来。中途老大爷睡着了，长得和家有儿女里夏雨的爷爷相似。临走时估摸着大爷听见了我们也是去广州的，并没有与普通人说帅哥，而是说了句“靓仔” 其实坐火车也是很有趣的一件事，比坐医院里观察人要欢乐的多。 到达广州在晚上九点多到达了广州站，出来明显感觉到热！不是一般的热！看了看天气似乎是 25℃。与其他火车站一样，出站口聚集了许多住宿的房东。好在提前订好了房间，于是出发乘坐地铁去往住处。路线是 广州站-&gt;2 号线-&gt;江南西 广州第一餐或许是赶上了互联网行业下班时间，路上有许多背着瑞士包的男生，少数格子衫的，地铁人挺多，但是算不上挤。到达广州第一餐，就是久违的 MacDonald，对，MacDonald。当然也就是解解馋了，毕竟上学的地方只有一家MacDonald，而且在车站。 肠粉这次来广州只吃了一次肠粉，因为时间关系不能再吃第二餐，只能等回家吃了。准备吃的时候，发现了两家，一家是华辉拉肠，一家是银记肠粉。虽然听过银记肠粉的名头，但是还是选择了华辉拉肠，原因是——有个本地人说了句华辉拉肠好吃。点了一个普通的蛋肠和皮蛋瘦肉粥，但是当我吃第一口的时候我就后悔了。酱料，不应该叫做酱料，应该叫酱油，而且还是老抽。这和我小时候吃的普通肠粉、石磨肠粉、簸箕肠粉完全就是两个味道，实在是太失望了，而且没有酱汁，这是最大的槽点。肠粉没了酱汁，我觉得就不能叫做肠粉了。吃完后已经快十二点了，所以选择回去休息。 住处住处是在 Airbnb 上找的，但是可能是专业人士经营的，买的没有卖的精。虽说实物与网图差距不是很大，但还是挺不满意的。唯一的满意之处也就是与众不同+交通方便了吧。只摄了一张图（没错就是我的脚）： 第一天这天起的挺早的，还在收拾的时候就听见楼下传来一声“点外卖用饿了吗”，几十个外卖小哥骑着小蓝车开始刷街了，也不知道是不是饿了吗的传统活动。住的地方在江南西，周围挺多网红店的，但是营业时间大部分都是早上十点开始，所以考虑晚上回来再看看。 江南西-&gt;宝业路-&gt;沙园 一早去的地方是宝业路，但是几乎都是烧烤店，所以就没有做过多停留，选择去寻找一家烤西瓜的店。地图上看的那家店在一家商场里，但是转了很久都没找着，根据定位判断，可能是不开了，因为那家店的位置开了家新店，而且在搞活动：所以，我们决定去北京路。 沙园-&gt;8 号线-&gt;2 号线-&gt;6 号线-&gt;北京路 不得不说北京路的小吃非常多，各种小吃都有。但是，人多，很多都是长长的队伍。买了根蟹肉棒：原味脆皮棒（给我的感觉就是泡芙）：时间已经差不多到午饭的点了，附近刚好有家点都德，就决定去了。过了早茶的时间，人不是很多，来的也大部分都是游客，都是奔着拍照来的。椰汁糕，没得说的：排骨（牙齿整形 ing 咬不动）：灌汤包（被我手快夹了一个）：还有虾饺，云吞，港式混酱肠粉。嗯，混酱，芝麻酱、甜面酱、酱油，负分！吃饱后开始散食了，附近兜兜转转，赏赏花：顺便顺着地图找到了家店——步步高昇钵仔糕：这家店不一样的原因是会放鸡蛋，与普通的钵仔糕不一样，普通的一般不放或者放椰果什么的（其实钵仔糕没什么味道）：感觉逛得差不多了，想吃的吃的着的都吃了，吃不着的都是人，决定换个地方。 北京路-&gt;6 号线-&gt;文化公园 文化公园往前走点，就发现了大大的招牌：与北京路差不多，人挺多的，但是小吃感觉挺少的，大部分还是服饰的商家。让我倍感神奇的是，臭豆腐也可以排那么长的队伍。逛了逛手信，还是觉得鸡仔饼可以让我提起兴趣，其余的在小时候已经吃腻了。顺带买了瓶凉茶治咳嗽（现在觉得一点效果也没有）：然后就一路走到了黄沙，途中遇到了迪卡侬（滴滴）：也差不多一下午就逛完了，还是决定去北京路附近吃。 黄沙-&gt;6 号线-&gt;北京路 这次路过了大头虾，排队的人依然很多，本准备翻翻菜单就走，然后发现有两人的位置，于是就进去了。上菜速度还是有点慢的，而且，越式菜也有点吃不惯。三色刨冰：越式春卷（味道怪怪的，但是配上酱料还算能吃）：盐焗基围虾：越式炒米（大赞，要不是吃不下了）：虽然吃的不多，但是会有饱的感觉（也许是错觉）。临走看看排队的人们： 北京路-&gt;天字码头-&gt;大沙头游船码头 又到了散食时间，沿着北京路一直往下走，去江边看看。沿途经过的酒吧：江边有挺多拍照的人，也许是光线挺美的吧：还有苟：本来想着直接走去看广州塔的，看了看地图……行吧，坐地铁。 东湖-&gt;6 号线-&gt;1 号线-&gt;5 号线-&gt;珠江新城 不直接去广州塔的原因是我觉得站在塔底反而不好拍了。到了珠江新城，崩溃了，为什么这个出口可以这么长，走了快十分钟还没出去。但是终于，还是看见了广州塔：趁着没有人合影的时机，来了张：旁边就是 K11：但是由于已经挺晚的了，回去晚了没地铁了，所以就没进去。 第一天到这就差不多结束了，回去收拾收拾就碎觉了。 第二天第二天就起的比较晚了，而且下午就得上车，所以也就在广州东附近转了几圈。 江南西-&gt;2 号线-&gt;8 号线-&gt;3 号线-&gt;广州东上 3 号线时本以为大家都是去广州东的，结果后面两站一车厢只剩几个人了，来这第一次在地铁上可以坐着。 去了广州东站寄存了行李后，就出来觅食了。在大众点评上看好了一家店，奔着那出发。途中经过一家一点点，只有一个人，这也是在广州第一次看见没人排队的一点点，买到了红茶冰淇淋：花了近二十分钟到了那家店，发现门上贴着一张纸：“臨时休息”，好嘛白跑一趟。决定去路上经过的鸟剑居酒屋（十号店），坐下后发现周围三桌都是日本家庭，女性有很明显的家庭主妇的气质。鱼籽寿司：日式薄饼：照烧鸡扒定食：吃完了就差不多到了该上车的点了，至此本次旅行也画上了句号。 至此我的大学首次旅行也结束了，有的地方还是没有做足准备，但是总的来说还是不错的。","tags":["旅游"]},{"title":"C %s格式化输出","path":"/2018/11/07/C-s格式化输出/","content":"写题时遇见的一个东西123char* s = &quot;hello world&quot;;printf(&quot;%15.2s&quot;, s);//result: he 找到如下用法： *%ms:输出的字符串占m列，如字符串本身长度大于m,则突破获m的限制，将字符串全部输出。若串长小于m,则左补空格。 *%-ms:如果串长小于m,则在m列范围内，字符串向左靠，右补空格。 *%m.ns:输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格，注意：如果n未指定，默认为0. *%-m.ns:其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n&gt;m,则自动取n值，即保证n个字符正常输出，注意：如果n未指定，默认为0. 如果是sprintf(desc, “%m.ns”, sour); 如果desc空间够的话，会在%m.ns 串 的结尾自动补null字符，不同于strncpy.例如 :sprintf(desc, “%.3s”, “123456”); desc如果空间&gt;&#x3D;4字节的话，第4个字节将是null字符。","tags":["整理","学习"],"categories":["C"]},{"title":"跨浏览器处理处理XML","path":"/2018/11/01/跨浏览器处理处理XML/","content":"一个简单的处理XML的函数1234567891011121314151617181920function parseXml(xml) &#123; //跨浏览器处理XML var xmldom = null; if (typeof DOMParser != &#x27;undefined&#x27;) &#123; xmldom = (new DOMParser()).parseFromString(xml, &#x27;text/xml&#x27;); var errors = xmldom.getElementsByTagName(&#x27;parsererror&#x27;); if (errors.length) &#123; throw new Error(&#x27;XML parsing error:&#x27; + errors[0].textContent); &#125; &#125; else if (typeof ActiveXObject != &#x27;undefined&#x27;) &#123; xmldom = createDocument(); xmldom.loadXML(xml); if (xmldom.parseError != 0) &#123; throw new Error(&#x27;XML parsing error:&#x27; + xmldom.parseError.reason); &#125; &#125; else &#123; throw new Error(&#x27;No XML parser available.&#x27;); &#125; return xmldom;&#125; 序列化XML文档12345678910111213//序列化xmldom文档function serializeXML(xmldom)&#123; if(typeof XMLSerializer!=&quot;undefined&quot;)&#123; //兼容ie9+ safari Chrome opera var serializer = new XMLSerializer(); return (serializer.serializeToString(xmldom)); &#125; else if((typeof xmldom.xml)!=undefined)&#123;//兼容ie9.0以下 return (xmldom.xml); &#125; else&#123; throw new Error(&quot;serialize XML Dom failed!&quot;); &#125;&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"EventUtil.js","path":"/2018/11/01/EventUtil-js/","content":"EventUtil为了在不同的浏览器中处理相同的事件，需要编写一段可以兼容大部分浏览器的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var EventUtil = &#123; addHandler: function (element, type, handler) &#123; //添加事件 if (element.addEventListener) &#123; element.addEventListener(type, handler, false); //使用DOM2级方法添加事件 &#125; else if (element.attachEvent) &#123; //使用IE方法添加事件 element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; //使用DOM0级方法添加事件 &#125; &#125;, removeHandler: function (element, type, handler) &#123; //取消事件 if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, getEvent: function (event) &#123; //使用这个方法跨浏览器取得event对象 return event ? event : window.event; &#125;, getTarget: function (event) &#123; //返回事件的实际目标 return event.target || event.srcElement; &#125;, preventDefault: function (event) &#123; //阻止事件的默认行为 if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function (event) &#123; //立即停止事件在DOM中的传播 //避免触发注册在document.body上面的事件处理程序 if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, getRelatedTarget: function (event) &#123; //获取mouseover和mouseout相关元素 if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; //兼容IE8- return event.toElement; &#125; else if (event.formElement) &#123; return event.formElement; &#125; else &#123; return null; &#125; &#125;, getButton: function (event) &#123; //获取mousedown或mouseup按下或释放的按钮是鼠标中的哪一个 if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)) &#123; return event.button; &#125; else &#123; switch (event.button) &#123; //将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1: case 3: case 5: case 7: return 0; //按下的是鼠标主按钮 case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮 &#125; &#125; &#125;, getWheelDelta: function (event) &#123; //获取表示鼠标滚轮滚动方向的数值 if (event.wheelDelta) &#123; return event.wheelDelta; &#125; else &#123; return -event.detail * 40; &#125; &#125;, getCharCode: function (event) &#123; //以跨浏览器取得相同的字符编码，需在keypress事件中使用 if (typeof event.charCode == &quot;number&quot;) &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;&#125;;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"new Study","path":"/2018/10/30/new-Study/","content":"开始新一轮的学习大晴天，白天上课，晚上班会。在傍晚时发现了有一丝的腰疼。晚上回到寝室突然又有点心绞痛的迹象···。年纪轻轻应该不会有大碍，应该吧···毕竟也没有去检查过身体。今天开始应该会把兼职辞了，开始新的学习吧。驾照什么的···就留着寒暑假有空再说吧。 date: 22:35 2018&#x2F;10&#x2F;30","tags":["雜談"]},{"title":"Generator","path":"/2018/09/01/Generator/","content":"基本用法12345678910function* testGenerator() &#123; yield &#x27;hello&#x27; yield &#x27;world&#x27; return &#x27;done&#x27;&#125;let test = testGenerator()test.next() // &#123; value : &#x27;hello&#x27;, done : false &#125;test.next() // &#123; value : &#x27;world&#x27;, done : false &#125;test.next() // &#123; value : &#x27;done&#x27;, done : true &#125;test.next() // &#123; value : undefined, done : true &#125; yield 表达式Generator 的 next 方法运行逻辑如下： 遇到 yield 语句就暂停执行后面的操作，并将紧跟在 yield 后的表达式的值作为的对象的 value 属性值 下一次调用 next 方法时在继续往下执行，直到遇到下一条 yield 语句 如果没有遇到新的 yield 语句，就一直运行到函数结束，知道运行到 return 为止，并将 return 语句后面的表达式作为返回对象的 value 属性值 如果该函数没有 return 语句，则返回对象的 value 属性值为 undefined yield 是惰性求值的： 123function* gen() &#123; yield 123 + 456&#125; 以上的代码只有在 next 将指针移到这一句时才求值。Generator 函数可以不使用 yield 语句，此时就变成了一个暂缓执行的函数，只有在调用了 next 时才执行： 12345function* f() &#123; console.log(&#x27;run&#x27;)&#125;let generator = f()setTimeout(() =&gt; generator.next(), 3000) 展开数组嵌套： 123456789101112131415var arr = [[1, 2], 3, [4, [5]]]var flat = function* (arr) &#123; var length = arr.length for (var i = 0; i &lt; length; i++) &#123; var item = arr[i] if (typeof item !== &#x27;number&#x27;) &#123; yield* flat(item) &#125; else &#123; yield item &#125; &#125;&#125;for (var f of flat(arr)) &#123; console.log(f) // 1, 2, 3, 4, 5&#125; next 方法的参数next 可以带有一个参数，该参数会被当做上一条 yield 语句的返回值，这样就可以在 Generator 函数运行的不同阶段从外部向内部注入不同的值，从而调整函数的行为： 123456789101112131415function* f() &#123; for (var i = 0; true; i++) &#123; var reset = yield i if (reset) &#123; i = -1 &#125; &#125;&#125;let generator = f()generator.next() // &#123; value : 0, done : false &#125;generator.next() // &#123; value : 1, done : false &#125;generator.next() // &#123; value : 2, done : false &#125;generator.next(true) // &#123; value : 0, done : false &#125;generator.next() // &#123; value : 1, done : false &#125;generator.next() // &#123; value : 2, done : false &#125; V8 引擎直接忽略第一次使用 next 时的参数，只有第二次使用 next 开始的参数才是有效的向内部注入值的例子： 12345678910function* dataConsumer() &#123; console.log(&#x27;start&#x27;) console.log(`1. $&#123;yield&#125;`) console.log(`2. $&#123;yield&#125;`) return &#x27;result&#x27;&#125;let run = dataConsumer()run.next() // &#x27;start&#x27;run.next(&#x27;first&#x27;) // 1. firstrun.next(&#x27;haha&#x27;) // 2. haha Generator.prototype.throw()throw 方法可以在函数体外抛出错误，然后在 Generator 函数体内捕获： 123456789101112131415var g = function* () &#123; try &#123; yield &#125; catch (e) &#123; console.log(&#x27;内部捕获&#x27;, e) &#125;&#125;var i = g()i.next()try &#123; i.throw(&#x27;a&#x27;) // 内部捕获 a i.throw(&#x27;b&#x27;) // 外部捕获 b&#125; catch (e) &#123; console.log(&#x27;外部捕获&#x27;, e)&#125; throw 方法可以接受一个参数，该参数会被 catch 语句接收： 1234567891011var g = function* () &#123; try &#123; yield &#125; catch (e) &#123; console.log(e) &#125;&#125;var i = g()i.next()i.throw(new Error(&#x27;test&#x27;))// Error: test 如果 Generator 函数内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误不影响下一次遍历，否则遍历直接终止。遍历器的 throw 与 throw 不同，后者只能被函数体外的 catch 捕获到throw 方法被捕获后会附带执行下一条 yield 表达式，即执行一次 next 方法： 1234567891011var gen = function* () &#123; try &#123; yield console.log(&#x27;a&#x27;) &#125; catch (e) &#123;&#125; yield console.log(&#x27;b&#x27;) yield console.log(&#x27;c&#x27;)&#125;var g = gen()g.next() // &#x27;a&#x27;g.throw() // &#x27;b&#x27;g.next() // &#x27;c&#x27; Generator 函数体内抛出的错误也能被函数体外的 catch 捕获： 123456789101112function* foo() &#123; var x = yield 3 var y = x.toUpperCase() yield y&#125;var it = foo()it.next() // &#123; value : 3, done : false &#125;try &#123; it.next(32)&#125; catch (e) &#123; console.log(e) //TypeError&#125; 一旦 Generator 执行过程中抛出错误，就不会再执行下去。如果此后再调用 next，将返回一个 value 属性等于 undefined，done 属性等于 true 的对象。 Generator.prototype.return()返回给定的值，并终结 Generator 函数的遍历： 123456789function* gen() &#123; yield 1 yield 2 yield 3&#125;var g = gen()g.next() // &#123; value : 1, done : false &#125;g.return(&#x27;foo&#x27;) // &#123; value : &#x27;foo&#x27;, done : true &#125;g.next() // &#123; value : undefined, done : true &#125; 如果 Generator 函数内部有 try…catch 代码块，那么 return 方法会推迟到 finally 代码块执行完成再执行。 yield*用于在一个 Generator 函数中执行另一个 Generator 函数。 1234567891011121314151617function* foo() &#123; yield &#x27;a&#x27; yield &#x27;b&#x27;&#125;function* bar() &#123; yield &#x27;x&#x27; yield* foo() yield &#x27;y&#x27;&#125;//等同于function* bar() &#123; yield &#x27;x&#x27; yield &#x27;a&#x27; yield &#x27;b&#x27; yield &#x27;y&#x27;&#125; 用 yield*取出嵌套数组成员： 1234567891011function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for (let i = 0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]) &#125; &#125; else &#123; yield tree &#125;&#125;const tree = [&#x27;a&#x27;, [&#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;, &#x27;e&#x27;]]for (let x of iterTree(tree)) console.log(x) // a b c d e 遍历完全二叉树： 123456789101112131415161718192021222324function Tree(left, label, right) &#123; this.left = left this.label = label this.right = right&#125;//中序遍历函数function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left) yield t.label yield* inorder(t.right) &#125;&#125;//生成二叉树function make(array) &#123; if (array.length === 1) return new Tree(null, array[0], null) return new Tree(make(array[0]), array[1], make(array[2]))&#125;let tree = make([[[&#x27;a&#x27;], &#x27;b&#x27;, [&#x27;c&#x27;]], &#x27;d&#x27;, [[&#x27;e&#x27;], &#x27;f&#x27;, [&#x27;g&#x27;]]])var result = []for (let node of inorder(tree)) &#123; result.push(node)&#125;result // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;] 作为对象属性的 Generator 函数1234567891011let obj = &#123; *myGeneratorMethod() &#123; //... &#125;,&#125;//等价写法let obj = &#123; myGeneratorMethod: function* () &#123; //... &#125;,&#125; Generator 函数 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，它也继承了 Generator 函数的 prototype 对象上的方法。 1234567function* g() &#123;&#125;g.prototype.hello = function () &#123; return &#x27;hi&#x27;&#125;let obj = g()obj instanceof g // trueobj.hello() // &#x27;hi&#x27; 让 Generator 函数返回一个正常对象的实例，既可以使用 next 方法，又可以获得正常的 this： 方法一： 12345678910111213function* F() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;var obj = &#123;&#125;var f = F.call(obj) // obj 绑定thisf.next() // &#123; value : 2, done : false &#125;f.next() // &#123; value : 3, done : false &#125;f.next() // &#123; value : undefined, done : true &#125;obj.a // 1obj.b // 2obj.c // 3 方法二： 123456789101112131415function* gen() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;function F() &#123; return gen.call(gen.prototype)&#125;var f = new F()f.next() // &#123; value : 2, done : false &#125;f.next() // &#123; value : 3, done : false &#125;f.next() // &#123; value : undefined, done : true &#125;f.a // 1f.b // 2f.c // 3 Generator 函数与状态机123456789101112var clock = function* () &#123; while (true) &#123; console.log(&#x27;Tick&#x27;) yield console.log(&#x27;Tock&#x27;) yield &#125;&#125;let c = clock()c.next() // Tickc.next() // Tockc.next() // Tick 异步操作的同步化表达123456789101112function* loadUI() &#123; showLoadingScreen() yield loadUIDataAsynchronously() hideLoadingScreen()&#125;var loader = loadUI()//加载UIloader.next()//卸载UIloader.next() 用同步方式表达 Generator 部署 AJAX 操作： 123456789101112function* main() &#123; var result = yield request(&#x27;http://some.url&#x27;) var resp = JSON.parse(result) console.log(resp.value)&#125;function request(url) &#123; makeAjaxCall(url, function (response) &#123; it.next(response) &#125;)&#125;var it = main()it.next() Async Generator123456789101112131415161718192021class A &#123; to = 0 constructor() &#123;&#125;&#125;const range = &#123; from: 1, to: 5, async *[Symbol.asyncIterator]() &#123; for (let i = this.from, to = this.to; i &lt; to; i++) &#123; await new Promise((resolve) =&gt; setTimeout(resolve, 1000)) yield i &#125; &#125;,&#125;;(async function () &#123; // for await of will call the [Symbol.asyncIterator] for await (const value of range) console.log(value)&#125;)()","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Iterator","path":"/2018/08/31/Iterator/","content":"Iterator 概念Iterator 是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署 Iterator 接口，就可以完成遍历操作。Iterator 的主要作用：为数据结构提供统一的、简便的访问接口；使得数据结构的成员能够按照某种次序排列；供 for…of 消费。遍历过程如下： 创建一个指针对象，指向当前数据结构的起始位置。 第一次调用指针对象的 next 方法，将指针指向数据结构的第一个成员。 第二次调用 next 方法，指向第二个成员。 不断调用 next 方法，直到指针指向数据结构的结束位置。 每次调用 next 方法都会返回数据结构当前成员的信息，返回一个包含 value 的 done 两个属性的对象。value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。模拟 next 方法返回值： 1234567891011121314var it = makeIterator([&quot;a&quot;, &quot;b&quot;]);it.next(); // &#123; value : &#x27;a&#x27;, done : false &#125;it.next(); // &#123; value : &#x27;b&#x27;, done : false &#125;it.next(); // &#123; value : undefined, done : true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function () &#123; return nextIndex &lt; array.length ? &#123; value: array[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125;; &#125;, &#125;;&#125; 遍历器与所遍历的数据结构实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者用遍历器对象模拟出数据结构。无限运行的遍历器对象的例子： 123456789101112var it = idMaker();it.next().value; // 0it.next().value; // 1//...function idMaker() &#123; var index = 0; return &#123; next: function () &#123; return &#123; value: index++, done: false &#125;; &#125;, &#125;;&#125; 默认 Iterator 接口类部署 Iterator 接口： 1234567891011121314151617181920212223class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123; value: value, done: false &#125;; &#125; return &#123; value: undefined, done: true &#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; 实现指针结构： 12345678910111213141516171819202122232425262728function Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function () &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; // 获取当前值 current = current.next; // 指向下一个实例 return &#123; value: value, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one) &#123; console.log(i); // 1, 2, 3&#125; 为对象添加 Iterator 接口： 12345678910111213141516171819let obj = &#123; data: [&quot;hello&quot;, &quot;world&quot;], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false, &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125;, &#125;; &#125;,&#125;; 类似数组对象调用数组的 Symbol.iterator 方法： 12345678910let iterable = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator],&#125;;for (let item of iterable) &#123; console.log(item); // &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; 普通对象部署数组的 Symbol.iterator 方法并无效果。如果 Symbol.iterator 方法对应的不是遍历器生成对象（即会返回一个遍历器对象），解释引擎将会报错。 调用 Iterator 的场合 解构赋值 123let set = new Set().add(&quot;a&quot;).add(&quot;b&quot;).add(&quot;c&quot;);let [x, y] = set; // x = a, y = blet [first, ...rest] = set; // first = &#x27;a&#x27;, rest = [&#x27;b&#x27;, &#x27;c&#x27;] 拓展运算符 1234var str = &quot;hello&quot;;[...str]; // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]let arr = [&quot;b&quot;, &quot;c&quot;];[&quot;a&quot;, ...arr, &quot;d&quot;]; // [&#x27;a&#x27;, b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] yield*yield*后面跟着是一个可遍历的结构，它会调用该结构的遍历器接口。 123456789101112let generator = function* () &#123; yield 1; yield* [2, 3, 4]; yield 5;&#125;;var iterator = generator();iterator.next(); // &#123; value : 1, done : false &#125;iterator.next(); // &#123; value : 2, done : false &#125;iterator.next(); // &#123; value : 3, done : false &#125;iterator.next(); // &#123; value : 4, done : false &#125;iterator.next(); // &#123; value : 5, done : false &#125;iterator.next(); // &#123; value : undefined, done : true &#125; 字符串的 Iterator 接口覆盖原生的 Symbol.iterator 方法达到修改遍历器行为的目的。 1234567891011121314151617var str = new String(&quot;hi&quot;);[...str]; // [&#x27;h&#x27;, &#x27;i&#x27;]str[Symbol.iterator] = function () &#123; return &#123; next: function () &#123; if (this._first) &#123; this._first = false; return &#123; value: &quot;bye&quot;, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, _first: true, &#125;;&#125;;[...str]; // [&#x27;bye&#x27;]str; //&#x27;hi&#x27; Iterator 接口与 Generator 函数Symbol.iterator 方法的最简单实现还是使用 Generator 函数。 1234567891011121314151617var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable]; // [1, 2, 3]//或下面的写法let obj = &#123; *[Symbol.iterator]() &#123; yield &quot;hello&quot;; yield &quot;world&quot;; &#125;,&#125;;for (let x of obj) &#123; console.log(x);&#125; return()、throw()return 使用的场合是，如果 for…of 循环提前退出（error、continue、break)，会调用 return 方法。如果一个对象在完成遍历以前需要清理或释放资源，就可以部署 return 方法。 123456789101112131415function readLinesSync(file) &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;;&#125;for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125; return 必须返回一个对象，这是 Generator 规定的 数组数组原生具备 Iterator 接口： 123456const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for (let v of arr) console.log(v);for (let v of obj) console.log(v);//完全相同的结果 for…of 可以代替 forEach 方法，for…in 获取对象的键名，for…of 获取对象的键值： 123var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];for (let a in arr) console.log(a); // 0 1 2 3for (let a of arr) console.log(a); // &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; for…of 只返回具有数字索引的属性： 1234let arr = [3, 4, 5];arr.foo = &quot;fun&quot;;for (let i in arr) console.log(i); // 0 1 2 foofor (let i of arr) console.log(i); // 3 4 5 Set 和 Map 结构Set 和 Map 结构原生具有 Iterator 接口，可以直接使用 for…of。 123456789var engines = new Set([&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]);for (var e of engines) console.log(e); // aaa bbb cccvar es = new Map();es.set(&quot;edition&quot;, 6);es.set(&quot;committee&quot;, &quot;TC39&quot;);for (var [name, value] of es) console.log(name + &quot; : &quot; + value);// edition : 6// committee : TC39 其他方法 entries()返回一个遍历器对象，用于遍历[键名，键值]组成的数组 keys()返回一个遍历器对象，用于遍历所有键名 values()返回一个遍历器对象，用于遍历所有键值 类似数组对象用 Array.from()方法转为数组： 12let arrayLike = &#123; length: 2, 0: &quot;a&quot;, 1: &quot;b&quot; &#125;;for (let x of Array.from(arrayLike)) console.log(x); // &#x27;a&#x27; &#x27;b&#x27; 普通对象for…in 仍可用于遍历键名，但是 for…of 不能使用，一种解决方法是使用 Object.keys()生成一个键名数组： 1for (var key of Object.keys(object)) console.log(key + &quot;:&quot; + object[key]); 另一个方法是使用 Generator 函数将对象重新包装： 12345678function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key + &quot;-&gt;&quot; + value);&#125; for…in 的不足： 数组的键名是数字，但是 for…in 循环是以字符串作为键名，’0’、’1’等 for…in 循环不仅会遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键 某些情况下，for…in 会以任意顺序遍历键名 Update on 6&#x2F;22&#x2F;2021Range123456789101112131415161718192021222324252627let range = &#123; from: 1, to: 5, [Symbol.iterator]() &#123; return &#123; current: this.from, last: this.to, next() &#123; if (this.current &lt;= this.last) &#123; return &#123; done: false, value: this.current++ &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, &#125;; &#125;,&#125;;for (let num of range) &#123; console.log(num);&#125;console.log(&quot;second range&quot;);for (let num of range) &#123; console.log(num);&#125; Another Range123456789101112131415161718192021222324let anotherRange = &#123; from: 1, to: 5, [Symbol.iterator]() &#123; this.current = this.from; return this; &#125;, next() &#123; if (this.current &lt;= this.to) &#123; return &#123; done: false, value: this.current++ &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;,&#125;;for (let num of anotherRange) &#123; console.log(num);&#125;console.log(&quot;another range&quot;);for (let num of anotherRange) &#123; console.log(num);&#125; Get Iterator12345678910let str = &quot;Hello&quot;;let iterator = str[Symbol.iterator]();while (true) &#123; let result = iterator.next(); if (result.done) break; console.log(result);&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Promise","path":"/2018/08/31/Promise/","content":"Promise 的特点 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Fulfilled（已成功）、Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变就不会再变，任何时候得到的都是这个结果。Promise 对象的状态改变只有两个可能：从 Pending 变为 Fulfilled，从 Pending 变为 Rejected。只要这两种情况发生，这时就成为 resolve。就算改变已经发生，再对 Promise 对象添加回调函数，也会立即得到这个结果。与 Event 完全不同，Event 一旦错过再监听是得不到结果的。 基本用法123456789var promise = new Promise(function (resolve, reject) &#123; //some code if (/*异步操作成功*/) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;) resolve 函数的作用是，将 Promise 对象的状态从 Pending 变为 Resolved，在异步操作成功时调用，并将异步操作的结果作为参数传递出去。reject 函数的作用是，将 Promise 对象的状态从 Pending 变为 Rejected，将报出的错误传递出去。Promise 实例生成后，可以用 then 方法分别制定 Resolve 状态和 Rejected 状态的回调函数： 12345678promise.then( function (value) &#123; //success &#125;, function (error) &#123; //failure &#125;,) then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调是 Promise 对象的状态变为 Rejected 时调用。其中，第二个参数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &#x27;done&#x27;) &#125;)&#125;timeout(100).then((value) =&gt; &#123; console.log(value)&#125;)//&#x27;done&#x27; 过了 ms 后，Promise 实例的状态变为 Resolved，触发 then 方法绑定的回调函数。Promise 新建后就会立即执行： 123456789101112let promise = new Promise(function (resolve, reject) &#123; console.log(&#x27;Promise&#x27;) resolve()&#125;)promise.then(function () &#123; console.log(&#x27;Resolve&#x27;)&#125;)console.log(&#x27;hi&#x27;)//Promise//hi//Resolve then 方法指定的回调函数将在当前脚本所有同步任务执行完成后才会执行，所以 Resolve 最后输出。异步加载图片： 123456789101112function loadImageAsync(url) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image() image.onload = function () &#123; resolve(image) &#125; image.onerror = function () &#123; reject(new Error(&#x27;Could not load image at &#x27; + url)) &#125; image.src = url &#125;)&#125; 使用 Promise 实现 AJAX： 123456789101112131415161718192021222324252627282930var getJSON = function (url) &#123; var promise = new Promise(function (resolve, reject) &#123; var client = new XMLHttpRequest() client.open(&#x27;GET&#x27;, url) client.onreadystatechange = handler client.responseType = &#x27;json&#x27; client.setRequestHeader(&#x27;Accept&#x27;, &#x27;application/json&#x27;) client.send() function handler() &#123; if (this.readyState !== 4) &#123; return &#125; if (this.status === 200) &#123; resolve(this.response) &#125; else &#123; reject(new Error(this.statusText)) &#125; &#125; &#125;) return promise&#125;getJSON(&#x27;/posts.json&#x27;).then( function (json) &#123; console.log(&#x27;Contents: &#x27; + json) &#125;, function (error) &#123; console.error(&#x27;出错了&#x27;, error) &#125;,) 以 Promise 对象作为 resolve 的参数1234567var p1 = new Promise(function (resolve, reject) &#123; //...&#125;)var p2 = new Promise(function (resolve, reject) &#123; //... resolve(p1)&#125;) 此时 p1 的状态决定了 p2 的状态。如果 p1 的状态是 Pending，那么 p2 的回调就会等待 p1 的改变；如果 p1 的状态已经是 Resolved 或者 Rejected，那么 p2 的回调函数就会立即执行。 1234567var p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;fail&#x27;)), 3000)&#125;)var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2.then((result) =&gt; console.log(result)).catch((error) =&gt; console.log(error)) p1 三秒后变为 Rejected，p2 在一秒后变为 Resolved，由于 p2 返回的是另一个 Promise，所以 p2 的状态无效，由 p1 的状态决定 p2 的状态。后面的 then 语句都变成针对 p2 的，再过两秒，p1 变为 Rejected，触发 catch 指定的回调函数。调用 resolve 或 reject 并不会结束 Promise 函数的执行因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。所以最好在前面加上 return 语句。 Promise.prototype.catch()是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456789101112131415161718192021222324252627282930313233343536373839404142getJSON(&#x27;/posts.json&#x27;) .then(function (posts) &#123; //... &#125;) .catch(function (error) &#123; //处理getJSON和前一个回调函数运行时发生的错误 &#125;)p.then((val) =&gt; console.log(&#x27;fulfilled:&#x27;, val)).catch((err) =&gt; console.log(&#x27;rejected:&#x27;, err),)//等同于p.then((val) =&gt; console.log(&#x27;fulfilled:&#x27;, val)).then(null, (err) =&gt; console.log(&#x27;rejected&#x27;, err),)var promise = new Promise(function (resolve, reject) &#123; throw new Error(&#x27;test&#x27;)&#125;)promise.catch(function (error) &#123; console.log(error)&#125;)//写法一var promise = new Promise(function (resolve, reject) &#123; try &#123; throw new Error(&#x27;test&#x27;) &#125; catch (e) &#123; reject(e) &#125;&#125;)promise.catch(function (error) &#123; console.log(error)&#125;)//写法二var promise = new Promise(function (resolve, reject) &#123; reject(new Error(&#x27;test&#x27;))&#125;)promise.catch(function (error) &#123; console.log(error)&#125;) 比较可知 reject 方法的作用等同于抛出错误。如果 Promise 状态已经变成 Resolved，再抛出错误是无效的 1234567891011var promise = new Promise(function (resolve, reject) &#123; resolve(&#x27;ok&#x27;) throw new Error(&#x27;test&#x27;)&#125;)promise .then(function (value) &#123; console.log(value) &#125;) .catch(function (error) &#123; console.log(error) &#125;) //&#x27;ok&#x27; Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止。一般来说，应用 Promise 的 catch 方法。与传统的 try&#x2F;catch 不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，不会有任何反应。需要注意的是，catch 返回的还是一个 Promise 对象。 1234567891011121314var someAsyncThing = function () &#123; return new Promise(function (resolve, reject) &#123; resolve(x + 2) //ReferenceError &#125;)&#125;someAsyncThing() .catch(function (error) &#123; console.log(&#x27;error:&#x27;, error) &#125;) .then(function () &#123; console.log(&#x27;carry on&#x27;) &#125;)//Error: ReferenceErro x is not defined//carry on 如果没有报错，会跳过 catch 方法。catch 方法中还能抛出错误： 123456789101112131415161718var someAsyncThing = function () &#123; return new Promise(function (resolve, reject) &#123; resolve(x + 2) //ReferenceError &#125;)&#125;someAsyncThing() .then(function () &#123; return someOtherAsyncThing() &#125;) .catch(function (error) &#123; console.log(error) y + 2 //ReferenceError &#125;) .catch(function (error) &#123; console.log(&#x27;carry on&#x27;, error) &#125;)//x in not defined//carry on y is not defined Promise.all将多个 Promise 对象包装成一个新的实例。 1var p = Promise.all(p1, p2, p3) p 的状态由 p1、p2、p3 决定： 只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1、p2、p3 有一个被 Rejected，p 的状态就变为 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。 123456const databasePromise = connectDatabase()const booksPromise = databasePromise.then(findAllBooks)const userPromise = databasePromise.then(getCurrentUser)Promise.all([booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user),) 只有 booksPromise 和 userPromise 结果都返回，才会触发 pickTopRecommentations 回调函数。如果作为参数的 Promise 实例自身定义了 catch 方法，那么它被 rejected 时并不会触发 Promise.all 的 catch 方法 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;) .then((result) =&gt; result) .catch((e) =&gt; e)const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;test&#x27;)&#125;) .then((result) =&gt; result) .catch((e) =&gt; e)Promise.all([p1, p2]) .then((result) =&gt; console.log(result)) .catch((e) =&gt; console.log(e))//[&#x27;hello&#x27;, Error: test] 如果 p2 没有自己的 catch 方法，就会调用 Promise.all 的 catch 方法： 12345678910const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;).then((result) =&gt; result)const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;test&#x27;)&#125;).then((result) =&gt; result)Promise.all([p1, p2]) .then((result) =&gt; console.log(result)) .catch((e) =&gt; console.log(e))//Error: test Promise.race将多个 Promise 实例包装成一个新的实例。 1var p = Promise.race([p1, p2, p3]) 只要 p1、p2、p3 有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的实例的返回值就传给 p 的回调函数。 123456789const p = Promise.race([ fetch(&#x27;/resource-that-may-take-a-while&#x27;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000) &#125;),])p.then((response) =&gt; console.log(response))p.catch((error) =&gt; console.log(error))//五秒内fetch无法返回变量，p的状态就变为Rejected，从而触发catch方法的回调函数 Promise.resolve 参数是一个 Promise 实例，不做任何修改，返回这个实例 参数是一个 thenable 对象，将这个对象转为 Promise 对象，然后立即执行 thenable 对象的 then 方法 12345678910let thenable = &#123; then: function (resolve, reject) &#123; resolve(42) &#125;,&#125;let p1 = Promise.resolve(thenable)p1.then(function (value) &#123; console.log(value)&#125;)//42 参数根本不是具有 then 方法的对象或者不是对象，返回一个新的 Promise 对象，状态为 Resolved 12345var p = Promise.resolve(&#x27;hello&#x27;)p.then(function (s) &#123; console.log(s)&#125;)//&#x27;hello&#x27; 不带有任何参数，直接返回一个 Resolved 状态的对象 Promise.reject 返回一个状态为 Rejected 的 Promise 对象 立即 resolve 的 Promise 对象是在本轮事件循环结束时，而不是在下次事件循环开始时 done只要最后一个方法抛出错误，都有可能无法捕捉到，为此可以配置一个 done 方法。 1asyncFunc().then(f1).catch(r1).then(f2).done() 实现的代码如下： 1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected).catch(function (reason) &#123; setTimeout(() =&gt; &#123; throw reason &#125;, 0) //抛出一个全局错误 &#125;)&#125; finally与 done 最大的区别在于，接受一个普通的回调函数作为参数，该函数不管怎样都执行。 123456server .listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop) 实现代码如下： 12345678910Promise.prototype.finally = function (callback) &#123; let P = this.constructor return this.then( (value) =&gt; P.resolve(callback()).then(() =&gt; value), (reason) =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;), )&#125; eg: 加载图片 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image() image.onload = resolve image.onerror = reject image.src = path &#125;)&#125; Generator 函数与 Promise 结合使用 Generator 函数管理流程，遇到异步操作时通常返回一个 Promise 对象。 1234567891011121314151617181920212223242526272829function getFoo() &#123; return new Promise(function (resolve, reject) &#123; resolve(&#x27;foo&#x27;) &#125;)&#125;var g = function* () &#123; try &#123; var foo = yield getFoo() console.log(foo) &#125; catch (e) &#123; console.log(e) &#125;&#125;function run(generator) &#123; var it = generator() function go(result) &#123; if (result.done) return result.value return result.value.then( function (value) &#123; return go(it.next(value)) &#125;, function (error) &#123; return go(it.throw(error)) &#125;, ) &#125; go(it.next())&#125;run(g) // 用run处理Promise对象，并调用下一个next方法 Promise chaining1234567891011121314151617181920212223242526272829function loadJSON(url) &#123; return fetch(url).then((response) =&gt; response.json())&#125;function loadUser(name) &#123; return fetch(`https://api.github.com/users/$&#123;name&#125;`).then((response) =&gt; response.json(), )&#125;function showAvatar(user) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = document.createElement(&#x27;img&#x27;) img.src = user.avatar_url img.className = &#x27;example-img&#x27; document.body.append(img) setTimeout(() =&gt; &#123; img.remove() resolve(loadUser) // here can resolve another promise &#125;, 3000) &#125;)&#125;loadJSON(&#x27;test.json&#x27;) .then((user) =&gt; loadUser(user.name)) .then(showAvatar) .then((user) =&gt; console.log(`github user: $&#123;user&#125;`))// ... and so on","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Reflect","path":"/2018/08/31/Reflect/","content":"从Reflect对象上可以获得语言内部的方法 修改某些Object方法的返回结果，让其变得更合理。比如Object.defineProperty在无法定义属性时会抛出一个错误，而Reflect.defineProperty则会返回false 让Object操作都变成函数行为。 只要是Proxy对象的方法，就能在Reflect对象上找到相应的方法，无论Proxy怎么修改默认行为，总可以在Reflect上获取默认行为 静态方法 Reflect.apply(target, thisArg, args)等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 Reflect.construct(target, args)等同于new target(…args)，提供了一种不使用new来调用构造函数的方法：123456789function Greeting(name) &#123; this.name = name;&#125;//new的写法const instance = new Greeting(&#x27;张三&#x27;);//Reflect.construct写法const instance = Reflect.construct(Greeting, [&#x27;张三&#x27;]); Reflect.get(target, name, receiver)查找并返回target的name属性，如果没有返回undefined。123456789let obj = &#123; foo : 1, bar : 2, get baz() &#123; return this.foo + this.bar; &#125;&#125;Reflect.get(obj, &#x27;foo&#x27;); //1Reflect.get(obj, &#x27;baz&#x27;); //3 如果name属性部署了getter，则getter的this绑定receiver：123456789101112let obj = &#123; foo : 1, bar : 2, get gaz() &#123; return this.foo + this.bar; &#125;&#125;;let myobj = &#123; foo : 2, bar : 4,&#125;Reflect.get(obj, &#x27;gaz&#x27;, myobj); //myobj.foo + myobj.bar 6 如果第一个参数不是object，会报错Reflect.set会触发Proxy.defineProperty拦截：1234567891011121314151617let p = &#123; a : &#x27;a&#x27;&#125;;let handler = &#123; set(target, key, value, receiver) &#123; console.log(&#x27;set&#x27;); Reflect.set(target, key, value, receiver); &#125;, defineProperty(target, key, attribute) &#123; console.log(&#x27;defineProperty&#x27;); Reflect.defineProperty(target, key, attribute); &#125;&#125;;let obj = new Proxy(p, handler);obj.a = &#x27;A&#x27;;//set//defineProperty Reflect.set(target, name, value, receiver)设置target的name属性等于value。123456789let obj = &#123; foo : 1, set bar(value) &#123; return this.foo = value; &#125;&#125;;obj.foo; //1Reflect.set(obj, &#x27;foo&#x27;, 2);obj.foo; //2 如果name属性设置了setter，则setter的this绑定receiver：1234567891011let obj = &#123; foo : 1, set bar(value) &#123; return this.foo = value; &#125;&#125;;let myobj = &#123; foo : 0&#125;;Reflect.set(obj, &#x27;bar&#x27;, 4, myobj);myobj.foo; //4 如果第一个参数不是object，会报错 Reflect.defineProperty(target, name, descriptor)用来定义对象的属性。 Reflect.deleteProperty(target, name)等同于delete obj[name]，用于删除对象的属性，返回一个布尔值，删除成功返回true，否则返回false。 Reflect.has(target, name)对应name in target中的in运算符，如果第一个参数不是对象，Reflect.has和in都会报错。 Reflect.ownKeys(target)返回对象的所有属性，包括Symbol属性。 Reflect.isExtensible(target)返回一个布尔值，表示当前对象是否可拓展。 Reflect.preventExtensions(target)用于使一个对象变为不可拓展的，返回一个布尔值，代表是否成功。 Reflect.getOwnPropertyDescriptor(target, name)基本等同于Object.getOwnPropertyDescriptor(target, propertyKey)，用于获得指定属性的描述对象。 Reflect.getPrototypeOf(target)用于读取对象的__prop__属性，对应Object.getPrototypeOf(obj)。 Reflect.setPrototypeOf(target, prototype)用于设置对象的__prop__属性，返回第一个参数对象。 用Proxy实现观察者模式Observe mode指的是函数自动观察数据对象的模式，一旦对象有变化，函数就会自动执行。思路：使用observable和observe这两个函数，observable函数返回一个原始对象的Proxy代理，拦截赋值操作，触发充当观察者的各个函数。 1234567891011121314151617181920const queueObservers = new Set();const observe = fn =&gt; queueObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123; set &#125;); //拦截setfunction set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); //完成原始操作 queueObservers.forEach(observer =&gt; observer()); return result;&#125;const person = observable(&#123; name : &#x27;张三&#x27;, age : 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;， $&#123;person.age&#125;`);&#125;observe(print);person.name = &#x27;李四&#x27;; //李四，20","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Proxy","path":"/2018/08/20/Proxy/","content":"Proxy用于修改某些操作的默认行为，等同与在语言层面做出修改，属于一种meta programming。 1234567891011121314let obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, receiver) &#123; console.log(`setting $&#123;key&#125;`); return Reflect.set(target, key, receiver); &#125;&#125;);obj.count = 1;//setting countobj.count;//getting count ES6提供Proxy构造函数，用于生成Proxy实例。 1let proxy = new Proxy(target, handler); 将Proxy对象设置到object.proxy属性，从而可以在object对象上调用： 1let obj = &#123; proxy: new Proxy(target, handler) &#125;; Proxy实例也可以作为其他对象的原型对象： 1234567let proxy = new Proxy(&#123;&#125;, &#123; get: function (target, handler) &#123; return 2; &#125;&#125;);let obj = Object.create(proxy);obj.time; //2 同一个Proxy可以设置多个拦截属性： 12345678910111213141516171819202122let handler = &#123; get: function (target, name) &#123; if (name === &#x27;prototype&#x27;) &#123; return Object.prototype; &#125; return &#x27;Hello, &#x27; + name; &#125;, apply: function (target, thisBinding, args) &#123; return args[0]; &#125;, construct: function (target, args) &#123; return &#123; value: args[1] &#125;; &#125;&#125;;let fproxy = new Proxy(function (x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2); //1new fproxy(1, 2); //2fproxy.prototype === Object.prototype; //truefproxy.foo; //&#x27;hello, foo&#x27; Proxy方法 get(target, propKey, receiver)拦截对象的属性读取，如proxy.foo和proxy[‘foo’]。最后一个参数是可选的。1234567891011121314let person = &#123; name : &#x27;张三&#x27;&#125;;let proxy = new Proxy(person, &#123; get : function (target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&#x27;Property \\&quot;&#x27; + property + &#x27;\\&quot; does not exist.&#x27;); &#125; &#125;&#125;);proxy.name; //张三proxy.age; //ReferenceError get方法可以继承：12345678let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(&#x27;get &#x27; + propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.aaa; //get aaa 使用get实现负数索引：12345678910111213141516function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey); if (index &lt; 0) &#123; propKey = String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; let target = []; target.push(...elements); return new Proxy(target, handler);&#125;let arr = createArray(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);arr[-1]; //&#x27;c&#x27; 将get转为执行某个函数，实现属性的链式操作：123456789101112131415161718192021var pipe = (function () &#123; return function (value) &#123; var funcStack = []; var oproxy = new Proxy(&#123;&#125;, &#123; get : function (pipeObject, fnName) &#123; if (fnName === &#x27;get&#x27;) &#123; return funcStack.reduce(function (val, fn) &#123; //reduce接受一个函数作为累加器，从左到右缩减，最终计算为一个值 return fn(val); &#125;, value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125;); return oproxy; &#125;&#125;());var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) | 0;pipe(3).double.pow.reverseInt.get; //63 set(target, propKey, value, receiver)拦截对象的属性设置，如proxy.foo &#x3D; 1，返回一个布尔值。123456789101112131415161718let validator = &#123; set : function (obj, prop, value) &#123; if (prop === &#x27;age&#x27;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&#x27;The age is not an integer&#x27;); &#125; if (value &gt; 200) &#123; throw new RangeError(&#x27;The age seems invalid&#x27;); &#125; &#125; //age &lt; 200直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age = 201; //RangeErrorperson.age = &#x27;tom&#x27;; //TypeError 给对象设置内部属性：1234567891011121314151617181920var handler = &#123; get(target, key) &#123; invariant(key, &#x27;get&#x27;); return target[key]; &#125;, set(target, key, value) &#123; invariant(key, &#x27;set&#x27;); target[key] = value; return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === &#x27;_&#x27;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`); &#125;&#125;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy._temp; //Errorproxy._temp = 2; //Error has(target, propKey)拦截propKey in proxy的操作，返回一个布尔值。has拦截对for…in循环不生效 deleteProperty(target, propKey)拦截delete proxy[propKey]的操作，返回一个布尔值。如果这个方法抛出错误或者返回false，当前属性就不能被delete删除。1234567891011121314var handler = &#123; deleteProperty(target, key) &#123; invariant(key, &#x27;delete&#x27;); return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === &#x27;_&#x27;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`); &#125;&#125;var target = &#123; _temp : &#x27;test&#x27; &#125;;var proxy = new Proxy(target, handler);delete proxy._temp; //Error ownKeys(target)拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回所有属性名，而Object.keys()返回结果仅包括目标对象和自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象或者undefined。123456789101112var handler = &#123; getOwnPropertyDescriptor(target, key) &#123; if (key[0] === &#x27;_&#x27;) &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo : &#x27;foo&#x27;, bar : &#x27;bar&#x27; &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, &#x27;_foo&#x27;); //undefinedObject.getOwnPropertyDescriptor(proxy, &#x27;bar&#x27;); //&#123; value : &#x27;bar&#x27;, writable : true, enumerable : true, configurable : true &#125; defineProperty(target, propKey, propDesc)拦截Objec.defineProperty:123456789var handler = &#123; defineProperty(target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = &#x27;bar&#x27;;proxy.foo; //undefined preventExtensions(target)拦截Object.preventExtensions，必须返回布尔值，否则会强制转换为布尔值。 getPrototypeOf(target)拦截获取对象原型 isExtensible(target)拦截Objec.isExtensible操作 setPrototypeOf(target, proto)拦截Object.setPrototypeOf方法 apply(target, object, args)拦截函数的调用、call和apply操作，12345678var target = function () &#123; return &#x27;test&#x27;; &#125;var handler = &#123; apply : function () &#123; return &#x27;apply&#x27;; &#125;&#125;;let p = new Proxy(target, handler);p(); //apply construct(target, args)拦截new命令，返回的必须是对象，否则会报错：123456789var p = new Proxy(function () &#123;&#125;, &#123; construct : function (target, args) &#123; console.log(&#x27;called &#x27; + args.join(&#x27;,&#x27;)); return &#123; value : args[0] * 10 &#125;; &#125;&#125;);(new p(1)).value; //called 1//10 Proxy.revocable()返回一个可取消的Proxy实例： 12345678let target = &#123;&#125;;let handler = &#123;&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo; //123revoke();proxy.foo; //TypeError 执行revoke函数后再访问Proxy实例，就会抛出一个错误。 this问题在Proxy代理下，目标对象内部的this关键字会指向Proxy代理： 12345678910111213const _name = new WeakMap();class Person &#123; constructor(name) &#123; _name.set(this, name); &#125; get(name) &#123; return _name.get(this); &#125;&#125;const jane = new Person(&#x27;Jane&#x27;);jane.name; //&#x27;Jane&#x27;const proxy = new Proxy(jane, &#123;&#125;);proxy.name; //undefined 此外，有些原生对象内部属性只有通过正确的this才能获取，所以Proxy也无法代理这些原生对象的属性 1234const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate();//TypeError: This is not a Date Object 这时，this绑定原始对象就可以解决 1234567891011const target = new Date(&#x27;2018-8-31&#x27;);const handler = &#123; get(target, prop) &#123; if (prop === &#x27;getDate&#x27;) &#123; return target.getDate.bind(target); &#125; return Reflect.get(target, prop); &#125;&#125;;const proxy = new Proxy(target, handler);proxy.getDate(); //31 观察者模式Observer mode：函数自动观察对象，一旦数据有变化，函数就会自动执行。 1234567891011121314151617181920212223242526272829303132let hero = &#123; // data object name: &#x27;test&#x27;, hp: 100, sp: 100, equipment: [&#x27;weapon&#x27;]&#125;const observableArray = new Set()const handler = &#123; set: (target, key, value, receiver) =&gt; &#123; const result = Reflect.set(target, key, value, receiver) observableArray.forEach(item =&gt; item(key)) return result &#125;&#125;/** * Create a Proxy object * @param &#123;Object&#125; obj the data object * @returns &#123;Object&#125; Proxy */const creatProxy = (obj) =&gt; new Proxy(obj, handler)const heroProxy = creatProxy(hero) // the data ProxyobservableArray.add((prop) =&gt; &#123; // callback function console.log(`new $&#123;prop&#125;: $&#123;heroProxy[prop]&#125;`); // log value of the prop handled&#125;)heroProxy.name = &#x27;change name&#x27; // new name: change nameheroProxy.sp = 12 // new sp: 12","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Map","path":"/2018/08/20/Map/","content":"ES6提供了Map数据结构，它类似对象，也是键值对的集合，但是‘键’的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map结构是一种更完善的Hash结构实现。如果需要‘键值对’的数据结构，Map比Object更合适。 1234let m = new Map();const o = &#123; p : &#x27;hello&#x27; &#125;;m.set(o, &#x27;content&#x27;);m.get(o); //&#x27;content&#x27; Map也可以接受一个数组作为参数，该数组的成员是一个表示键值对的数组： 12345678const map = new Map([ [&#x27;name&#x27;, &#x27;张三&#x27;], [&#x27;title&#x27;, &#x27;test&#x27;]]);map.size; //2map.has(&#x27;name&#x27;); //truemap.get(&#x27;name&#x27;); //&#x27;张三&#x27; Map构造函数接受数组作为参数，实际上执行的是下面的算法： 12345678const item = [ [&#x27;name&#x27;, &#x27;张三&#x27;], [&#x27;title&#x27;, &#x27;test&#x27;]];const map = new Map();item.forEach( ([key, valule]) =&gt; map.set(key, value)); 同名问题Map的键实际上是和内存地址绑定的，只要内存地址不一样，就视为两个键。如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map就视其为一个键，包括-0和0。另外，虽然NaN不严格等于自身，但Map将其视为同一个键。 实例的属性和操作方法 size属性size属性返回Map结构的成员总数。 set(key, value)set方法设置key所对应的键值，返回整个Map结构。如果key已经有值，则键值更新，否则新生成键值。 get(key)get方法读取key对应的键值，如果找不到key，返回undefined。 has(key)has方法返回一个布尔值，表示某个键是否在Map数据结构中。 delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。 clear()clear方法清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历Map的所有成员 Map的遍历顺序就是插入顺序 Map与其他数据结构相互转换 Map转为数组12const myMap = new Map().set(true, 1).set(false, 2).set(&#123; foo: 1 &#125;, [&#x27;abc&#x27;]);[...myMap]; //[[true, 1], [false, 2], [&#123;foo:1&#125;, [&#x27;abc&#x27;]]] 数组转为Map1234new Map([ [true, 1], [&#123; foo : 3 &#125;, [&#x27;abc&#x27;]]]) Map转为对象如果Map的所有键都是字符串，则可以转为对象。1234567function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125; 对象转为Map1234567function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k. obj[k]); &#125; return strMap;&#125; Map转为JSON Map的键名都是字符串：123function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125; 键名有非字符串123function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125; JSON转为Map 正常情况下所有键名都是字符串123function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125; JSON就是一个数组的情况123function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125; WeakMap 只接受对象作为键名（null除外） WeakMap中的对象都是弱引用，如果其他对象都不再引用该对象，那么GC会自动回收该对象所占的内存，不考虑该对象是否在WeakMap中 没有size属性，没有clear方法 WeakMap的专用场景就是它的键所对应的对象可能会在将来消失的场景，有助于防止内存泄露","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Set","path":"/2018/08/18/Set/","content":"基本用法Set类似于数组，但是成员的值都是唯一的，没有重复。Set本身是一个构造函数。 1234567891011const set = new Set();[1, 2, 3, 4].forEach(x =&gt; set.add(x));for (let value of set) &#123; console.log(value); //1, 2, 3, 4&#125;const set = new Set([1, 2, 3, 4]);[...set]; //[1, 2, 3, 4]//数组除重[...new Set(array)] 在Set内部，NaN是相等的，两个对象总是不相等的。 12345678let set = new Set();let a = NaN;let b = NaN;set.add(a).add(b);set.size; //1set.add(&#123;&#125;).add(&#123;&#125;);set.size; //3 Set实例的属性和方法Set结构的实例有以下属性： Set.prototype.constructor：构造函数，默认是Set函数 Set.prototype.size：返回Set成员的总数 Set实例的方法： add(value)：添加某个值，返回Set结构本身 delete(value)：删除某个值，返回布尔值表示是否删除成功 has(value)：返回一个布尔值，表示参数是否为Set的成员 clear()：清除所有成员，没有返回值 Array.from方法可以将Set转为数组： 1234567const item = new Set([1, 2, 3, 4]);const array = Array.from(item);//去重function dedupe(array) &#123; return Array.from(new Set(array));&#125; 遍历操作 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Set的遍历顺序就是插入顺序由于Set结构没有键名，所以values和keys方法的行为完全一致。 WeakSet 成员只能是对象，而不能是其他类型的值 WeakSet中的对象都是弱引用，如果其他对象都不再引用该对象，那么GC会自动回收该对象所占的内存，不考虑该对象是否在WeakSet中 没有size属性，不可遍历","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Symbol","path":"/2018/08/17/Symbol/","content":"ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol值通过Symbol函数生成，也就是说，对象的属性名现在可以有两种类型：一种是字符串，另一种就是Symbol类型。只要属性名属于Symbol类型，就是独一无二的，可以保证不会与其他属性名冲突。 12let s = Symbol();typeof s; //symbol Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在console显示。 12let s = Symbol(&#x27;str&#x27;);s.toString(); //&#x27;Symbol(str)&#x27; 如果Symbol的参数是一个对象，就会调用该对象的toString方法，再生成Symbol值 1234567const obj = &#123; toString() &#123; return &#x27;test&#x27;; &#125;&#125;;const s = Symbol(obj);s.toString(); //&#x27;Symbol(test)&#x27; Symbol函数只表示对当前Symbol值的描述，因此相同的Symbol函数的返回值是不相等的 123let s1 = Symbol();let s2 = Symbol();s1 === s2; //false 作为属性名的SymbolSymbol值可以作为标识符用于对象的属性名，保证不会出现同名的属性，还能防止某一个键被不小心覆盖。 1234567891011121314let symbol = Symbol();//写法一let a = &#123;&#125;;a[symbol] = &#x27;test&#x27;;//写法二let a = &#123; [symbol]: &#x27;test&#x27;&#125;//写法三let a = &#123;&#125;;Object.defineProperty(a, symbol, &#123; value : &#x27;test&#x27; &#125;); 实例：消除代码中的字符串 12345678910111213141516171819202122function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case &#x27;Triangle&#x27;: area = 0.5 * options.width * options.height; break; &#125; return area;&#125;//转变后const shaptType = &#123; triangle: Symbol();&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shaptType.triangle: area = 0.5 * options.width * options.height; break; &#125; return area;&#125; 属性名的遍历Symbol属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyName()返回。有一个Object.getOwnPropertySymbols方法可以获取指定对象的所有Symbol属性。 123456let obj = &#123;&#125;;let a = Symbol(&#x27;hello&#x27;);let b = Symbol(&#x27;world&#x27;);obj[a] = &#x27;a&#x27;;obj[b] = &#x27;b&#x27;;Object.getOwnPropertySymbols(obj); //[Symbol(hello), Symbol(world)] Symbol.for()、Symbol.keyFor()Symbol.for接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建一个以该字符串为名称的Symbol值。 123let str1 = Symbol.for(&#x27;test&#x27;);let str2 = Symbol.for(&#x27;test&#x27;);str1 === str2; //true Symbol.keyFor方法返回一个已登记的Symbol类型值的key： 12345let s1 = Symbol.for(&#x27;foo&#x27;);Symbol.keyFor(s1); //&#x27;foo&#x27;let s2 = Symbol(&#x27;foo&#x27;);Symbol.keyFor(s2); //undefined Symbol.for为Symbol登记的名字是全局环境的，可以在不同的iframe或serviceWorker中取到同一个值 内置的Symbol值 Symbol.hasInstancefoo instanceof Foo实际在内部调用的是Foo[Symbol.hasInstance](foo)：1234567891011121314class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125;&#125;[1, 2, 3] instanceof new MyClass(); //trueclass Even &#123; static [Symbol.hasInstance](obj) &#123; return Number(obj) % 2 === 0; &#125;&#125;1 instanceof Even; //false2 instanceof Even; //true Symbol.isConcatSpreadable等于一个布尔值，表示该对象使用Array.prototype.concat()时是否可以展开：1234567let arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];[1, 2].concat(arr1, &#x27;c&#x27;); //[1, 2, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]arr1[Symbol.isConcatSpreadable]; //undefinedlet arr2 = [&#x27;a&#x27;, &#x27;b&#x27;];arr2[Symbol.isConcatSpreadable] = false;[1, 2].concat(arr2, &#x27;c&#x27;); //[1, 2, [&#x27;a&#x27;, &#x27;b&#x27;], &#x27;c&#x27;] 类似数组的对象也可以展开，默认值为false，必须手动打开：1234let obj = &#123; length : 2, 0 : &#x27;c&#x27;, 1 : &#x27;d&#x27; &#125;;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj); //[&#x27;a&#x27;, &#x27;b&#x27;, obj]obj[Symbol.isConcatSpreadable] = true;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj); //[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 对一个类而言，Symbol.isConcatSprealable属性必须写成实例属性：123456class myClass extends Array &#123; constructor(args) &#123; super(args); this[Symbol.isConcatSpreadable] = true; &#125;&#125; Symbol.species对象的Symbol.species属性指向当前对象的构造函数，创造实例时会默认调用这个方法。123456789101112class myClass extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;let a = new myClass(1, 2, 3);let mapped = a.map(x =&gt; x * x);a instanceof Array; //truemapped instanceof Array; //truea instanceof myClass; //truemapped instanceof myClass; //false//默认值等同于下面的写法static get [Symbol.species]() &#123; return this; &#125; Symbol.match对象的Symbol.match属性指向一个函数，当执行str.match(myObject)时，如果该属性存在，会调用它的返回值：12345678910String.prototype.match(regexp);//等同于regexp[Symbol.match](this);class myMatcher &#123; [Symbol.match](string) &#123; return &#x27;hello world&#x27;.indexOf(string); &#125;&#125;e.match(new myMatcher()); //1 Symbol.replace对象的Symbol.replace属性指向一个方法，当对象被String.prototype.replace方法调用时会返回该方法的返回值：123String.prototype.replace(searchValue, replaceValue);//等同于searchValue[Symbol.replace](this, replaceValue); Symbol.replace方法会收到两个参数，一个是replace方法正在作用的对象，第二个是替换后的值：123const x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);&#x27;hello&#x27;.replace(x, &#x27;world&#x27;); //[&#x27;hello&#x27;, &#x27;world&#x27;] Symbol.search对象的Symbol.search属性指向一个方法，当对象被String.prototype.search方法调用时会返回该方法的返回值：12345678910111213String.prototype.search(regexp);//等同于regexp[Symbol.search](this);class mySearch &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;&#125;&#x27;foobar&#x27;.search(new mySearch(&#x27;foo&#x27;)); //3 Symbol.split对象的Symbol.split属性指向一个方法，当对象被String.prototype.split方法调用时会返回该方法的返回值：123String.prototype.split(separator, limit);//等同于separator[Symbol.split](this, limit); 重定义split方法的行为：12345678910111213141516class mySplit &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.split](string) &#123; let index = string.indexOf(this.value); if (index === -1) return string; return [ string.substr(0, index), string.substr(index + this.value.length); ]; &#125;&#125;&#x27;foobar&#x27;.split(new mySplit(&#x27;foo&#x27;)); //[&#x27;&#x27;, &#x27;bar&#x27;]&#x27;foobar&#x27;.split(new mySplit(&#x27;bar&#x27;)); //[&#x27;foo&#x27;, &#x27;&#x27;]&#x27;foobar&#x27;.split(new mySplit(&#x27;1&#x27;)); //&#x27;foobar&#x27; Symbol.iterator对象的Symbol.iterator属性指向该对象的默认遍历器方法：123456789101112131415161718192021222324let myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;[...myIterable]; //[1, 2, 3]class Collection &#123; *[Symbol.iterator]() &#123; let i = 0; while (this[i] !== undefined) &#123; yield this[i]; i++; &#125; &#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for (let value of myCollection) &#123; console.log(value); //1, 2&#125; Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"拖放事件","path":"/2018/08/15/拖放事件/","content":"拖拽元素事件： dragstart：拖拽前触发 drag：拖拽前到拖拽结束之间，连续触发 dragend：拖拽结束触发 123456789101112131415161718192021&lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let aLi = document.querySelectorAll(&#x27;li&#x27;); for (let li of aLi) &#123; let count = 0; li.ondragstart = function() &#123; this.style.backgroundColor = &#x27;red&#x27;; &#125;; li.ondrag = function () &#123; console.log(count++); //连续触发 &#125; li.ondragend = function() &#123; this.style.backgroundColor = &#x27;&#x27;; &#125; &#125;&lt;/script&gt; 目标元素事件： dragenter：进入目标元素触发，相当于mouseover dragover：进入目标到离开目标之间，连续触发 dragleave：离开目标元素触发，相当于mouseout drop：在目标元素上释放鼠标触发 12345678910111213141516171819&lt;div id=&quot;div1&quot; style=&quot;width:50px;height:50px;background:yellow&quot;&gt;&lt;/div&gt;&lt;script&gt; let oDiv = document.querySelector(&#x27;#div1&#x27;); oDiv.ondragenter = function () &#123; this.style.backgroundColor = &#x27;blue&#x27;; &#125;; oDiv.ondragover = function (ev) &#123; console.log(&#x27;test&#x27;); //连续触发 //要想触发drop事件，就必须在dragover中阻止默认事件 ev.preventDefault(); //阻止默认事件 &#125; oDiv.ondragleave = function () &#123; this.style.backgroundColor = &#x27;yellow&#x27;; &#125;; oDiv.ondrop = function () &#123; console.log(&#x27;drop&#x27;); &#125;&lt;/script&gt; dataTransfer对象 setData()：设置数据key和value值(必须是string) getDate()；获取数据，根据key值获取value 12345678910111213141516171819202122232425&lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;div1&quot; style=&quot;width:50px;height:50px;background:yellow&quot;&gt;&lt;/div&gt;&lt;script&gt; let oUl = document.querySelector(&#x27;ul&#x27;); let aLi = oUl.querySelectorAll(&#x27;li&#x27;); let oDiv = document.querySelector(&#x27;#div1&#x27;); for (let i = 0, length = aLi.length; i &lt; length; i++) &#123; aLi[i].index = i; aLi[i].ondragstart = function (ev) &#123; ev.dataTransfer.setData(&#x27;index&#x27;, this.index); &#125;; &#125; oDiv.ondrop = function (ev) &#123; oUl.removeChild(aLi[ev.dataTransfer.getData(&#x27;index&#x27;)]); for (let i = 0, length = aLi.length; i &lt; length; i++) &#123; //重新赋索引值 aLi[i].index = i; &#125; &#125;&lt;/script&gt; effectAllowed：设置光标样式(none, copy, copyLink, copyMove, link, linkMove, move all, uninitalized) setDragImage：参数为指定的元素、x坐标值、坐标值 files：获取外部拖拽文件，返回一个fileList列表，fileList下type属性返回文件类型 FileReaderFileReader用于读取文件信息 readAsDataURL：参数为要读取的文件对象，将文件读取为DataUrl onload：当读取文件完成时触发此事件，通过this.result获取读取文件的数据，如果是图片，返回base64格式的图片数据","tags":["整理","学习"],"categories":["HTML5"]},{"title":"data自定义数据","path":"/2018/08/15/data自定义数据/","content":"data自定义数据在query、mobile常用。 1234567&lt;div id=&quot;div1&quot; data-test=&quot;hello&quot; data-test-last=&quot;world&quot;&gt;&lt;/div&gt;&lt;script&gt; let oDiv = document.getElementById(&#x27;div1&#x27;); oDiv.dataset.test; //&#x27;hello&#x27; oDiv.dataset.testLast; //&#x27;world&#x27;&lt;/script&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"JSON新方法","path":"/2018/08/15/JSON新方法/","content":"eval()eval 可以解析任何字符串变成 JS： 123var str = &quot;function testFunction() &#123;console.log(&#x27;test&#x27;);&#125;&quot;;eval(str);testFunction(); //&#x27;test&#x27; JSON.parse()JSON.parse 只能解析 JSON 形式的字符串变成 JS，安全性比 eval 高一些。字符串中的属性要严格加上引号 123let str = &#x27;&#123; &quot;name&quot; : &quot;hello&quot; &#125;&#x27;;let json = JSON.parse(str);json.name; //&#x27;hello&#x27; JSON.stringify()JSON.stringify 将 JSON 转换成字符串： 12345let json = &#123; name: &quot;hello&quot;,&#125;;let str = JSON.stringify(json);str; //&#123;&quot;name&quot;:&quot;hello&quot;&#125; 复制对象出现的问题由于&#x3D;赋值，会有引用的问题，新对象属性改变可能会影响到源对象： 123456let a = &#123; name: &quot;hello&quot;,&#125;;let b = a;b.name = &quot;hi&quot;;a.name; //&#x27;hi&#x27; 可以用 JSON 的新方法解决： 123456let a = &#123; name: &quot;hello&quot;,&#125;;let b = JSON.parse(JSON.stringify(a));b.name = &quot;ni&quot;;a.name; //&#x27;hello&#x27; JS 历史管理触发历史管理的方法： 通过跳转页面 hash pushState Update at 2021&#x2F;6&#x2F;24123456789101112131415161718192021222324252627let room = &#123; number: 23 &#125;;let meetup = &#123; title: &quot;Conference&quot;, participants: [&#123; name: &quot;John&quot; &#125;, &#123; name: &quot;Alice&quot; &#125;], place: room,&#125;;room.occupiedBy = meetup; // circular referenceconsole.log( JSON.stringify( meetup, (key, value) =&gt; &#123; return key === &quot;occupiedBy&quot; ? undefined : value; &#125;, 2 ));let toJson = &#123; age: 32, toJSON() &#123; return this.age; &#125;,&#125;;console.log(JSON.stringify(toJson));","tags":["整理","学习"],"categories":["HTML5"]},{"title":"新的选择器","path":"/2018/08/15/新的选择器/","content":"querySelector()querySelector只能选择一组中的第一个元素： 123456&lt;div class=&quot;test&quot;&gt;div1&lt;/div&gt;&lt;div class=&quot;test&quot;&gt; div2&lt;/div&gt;&lt;script&gt; document.querySelector(&#x27;.test&#x27;).style.color = &#x27;red&#x27;; //只有第一个会变红&lt;/script&gt; querySelectorAll()querySelectorAll获取一组元素： 123456789&lt;div class=&quot;test&quot;&gt;div1&lt;/div&gt;&lt;div class=&quot;test&quot;&gt;div2&lt;/div&gt;&lt;script&gt; let aDiv = document.querySelectorAll(&#x27;.test&#x27;); for (let div of aDiv) &#123; div.style.color = &#x27;red&#x27;; &#125;&lt;/script&gt; getElementsByClassName()getElementsByClassName通过class name选择元素： 123456789&lt;div class=&quot;test&quot;&gt;div1&lt;/div&gt;&lt;div class=&quot;test&quot;&gt;div2&lt;/div&gt;&lt;script&gt; let aDiv = document.getElementsByClassName(&#x27;test&#x27;); for (let div of aDiv) &#123; div.style.color = &#x27;red&#x27; &#125;&lt;/script&gt; 获取classList属性123456789&lt;div id=&quot;div1&quot; class=&quot;box1 box2 box3&quot;&gt;&lt;/div&gt;&lt;script&gt; let oDiv = document.getElementById(&#x27;div1&#x27;); oDiv.classList; //[box1, box2, box3] oDiv.classList.add(&#x27;box4&#x27;); //添加className oDiv.classList.remove(&#x27;box2&#x27;); //删除className oDiv.classList.toggle(&#x27;box4&#x27;); //如果有box4，则删除；反之，则添加box4&lt;/script&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5表单验证反馈","path":"/2018/08/14/HTML5表单验证反馈/","content":"validity对象通过validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，有一种失败则返回false oText.addEventListener(‘invalid’, fn, false); ev.preventDefault() valueMissing: 输入值为空时 typeMismatch: 控件值与预期类型不匹配 patterMismatch: 输入值不满足pattern正则 tooLong: 超过maxLength最大限制 rangeUnderflow: 验证的range最小值 rangeOverflow: 验证的range最大值 setMismatch: 验证range的当前值是否符合min、max、step的规则 customError: 不符合自定义验证–setCustomValidity()设置自定义验证 1234567891011121314&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;text&quot; required /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;script&gt; let oText = document.getElementById(&#x27;text&#x27;); oText.addEventListener(&#x27;invalid&#x27;, fn, false); function fn() &#123; console.log(this.validity); console.log(this.validity.valid); &#125;&lt;/script&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5新标签(三)","path":"/2018/08/14/HTML5新标签-三/","content":"1234567891011121314151617181920212223&lt;form action=&quot;&quot;&gt; &lt;!--placeholder: 输入框提示信息--&gt; &lt;!--autocomplete: 自动保存用户输入过的值，默认为on--&gt; &lt;!--pattern: 正则验证--&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入6-8个数字&quot; pattern=&quot;\\d&#123;6,8&#125;&quot; name=&quot;user&quot; autocomplete=&quot;off&quot; id=&quot;&quot; /&gt; &lt;!--formaction: 定义提交地址--&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; formaction=&quot;http://www.baidu.com&quot; /&gt;&lt;/form&gt;&lt;form action=&quot;&quot;&gt; &lt;!--autofocus: 自动焦点--&gt; &lt;!--required: 必填项--&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; autofocus required /&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; required /&gt;&lt;/form&gt;&lt;!--datalist选项列表，与input元素配合使用，定义input的可能值--&gt;&lt;input type=&quot;text&quot; list=&quot;varList&quot; /&gt;&lt;datalist id=&quot;varList&quot;&gt; &lt;option value=&quot;javascript&quot;&gt;javascript&lt;/option&gt; &lt;option value=&quot;html&quot;&gt;html&lt;/option&gt; &lt;option value=&quot;css&quot;&gt;css&lt;/option&gt;&lt;/datalist&gt; JS延迟加载 123456789&lt;!--会在window.onload之前加载--&gt;&lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;&lt;!--异步加载--&gt;&lt;script src=&quot;a.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;&lt;script src=&quot;c.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt; contextmenu捕获右键菜单事件： 1234567891011121314151617&lt;ul id=&quot;myMenu&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var menu = document.querySelector(&#x27;#myMenu&#x27;) document.addEventListener(&#x27;contextmenu&#x27;, (event) =&gt; &#123; event.preventDefault() menu.style.left = event.clientX + &#x27;px&#x27; menu.style.top = event.clientY + &#x27;px&#x27; menu.style.visibility = &#x27;visible&#x27; &#125;, false) document.addEventListener(&#x27;click&#x27;, (event) =&gt; &#123; menu.style.visibility = &#x27;hidden&#x27; &#125;, false)&lt;/script&gt; DOMContentLoaded当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。 在使用 DOMContentLoaded 更加合适的情况下使用 load 是一个令人难以置信的流行的错误，所以要谨慎。注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。load 是在所有资源加载完成后才触发。 readystatechange当文档的readyState属性发生改变，readystatechange事件会被触发。 12345678910document.readyState === &quot;complete&quot;;// true// 替代 DOMContentLoadeddocument.onreadystatechange = function () &#123; if (document.readyState === &quot;interactive&quot;) &#123; initApplication(); &#125;&#125; dragable全局属性 draggable 是一个枚举类型的属性，用于标识元素是否允许使用 拖放操作API 拖动。它的取值如下： true，表示元素可以被拖动 false，表示元素不可以被拖动 如果该属性没有设值，则默认值 为 auto ，表示使用浏览器定义的默认行为。这个属性是枚举类型，而不是Boolean默认情况下，只有已选中的文本、图片、链接可以拖动。对其它的元素来说，必须按拖动机制的顺序设置 ondragstart 事件才能正常工作: 123&lt;div draggable=&quot;true&quot; ondragstart=&quot;event.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;This text may be dragged&#x27;)&quot;&gt; This text &lt;strong&gt;may&lt;/strong&gt; be dragged.&lt;/div&gt; Drag Data每一个drag events都有一个dataTransfer属性，用于保存drag data，dataTransfer是一个DataTransfer对象。使用setData(type, value)来设置值。例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt; .container &#123; display: flex; flex-direction: row; &#125; #draggable &#123; width: 100px; height: 100px; background: white; justify-content: center; line-height: 100px; display: flex; &#125; .dragger-container &#123; margin: 0 2px; width: 100px; height: 100px; background-color: gray; padding: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dragger-container&quot;&gt; &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt; Drag me &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;dragger-container&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dragger-container&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dragger-container&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; let dragged document.addEventListener(&#x27;dragstart&#x27;, (event) =&gt; &#123; dragged = event.target &#125;, false) document.addEventListener(&#x27;dragover&#x27;, (event) =&gt; &#123; event.preventDefault() &#125;, false) document.addEventListener(&#x27;drop&#x27;, (event) =&gt; &#123; event.preventDefault() if (event.target.className == &#x27;dragger-container&#x27;) &#123; dragged.parentNode.removeChild(dragged) event.target.appendChild(dragged) &#125; &#125;, false) &#125;&lt;/script&gt; storage sessionStorage: 关闭页面时会清空 localStorage: 关闭页面时不会清空 两者API一致。 requestAnimationFrame(callback)表示在重绘前执行指定的回调函数，一个栗子： 12&lt;div id=&quot;root&quot; style=&quot;width: 50px; height: 50px; background-color: red; position: relative;&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; 12345678910111213141516171819let root = document.querySelector(&#x27;#root&#x27;)let flag = truelet left = 0requestAnimFrame = (() =&gt; requestAnimationFrame || webkitRequestAnimationFrame || mozRequestAnimationFrame || (callback =&gt; &#123; setTimeout(callback, 1000 / 60) &#125;))();(function _animation() &#123; left == 0 ? flag = true : left == 100 ? flag = false : &#x27;&#x27;; flag ? root.style.left = `$&#123;left++&#125;px` : root.style.left = `$&#123;left--&#125;px`; requestAnimFrame(_animation);&#125;)()","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5新标签(二)","path":"/2018/08/14/HTML5新标签-二/","content":"123456789101112131415161718192021222324&lt;!--新的输入控件--&gt;&lt;!--email: 电子邮箱文本框，当输入的不是邮箱的时候，验证通不过。移动端的键盘会有变化--&gt;&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;!--tel: 电话号码--&gt;&lt;input type=&quot;tel&quot; name=&quot;&quot; id=&quot;&quot; /&gt;&lt;!--url: 网页的url--&gt;&lt;!--search: 搜索引擎，chrom下会多个关闭按钮--&gt;&lt;!--number: 只能输入数字--&gt;&lt;!--color: 颜色选择器--&gt;&lt;!--datetime: 显示日期--&gt;&lt;!--datetime-local: 显示完整日期，不含时区--&gt;&lt;!--time: 显示时间，不含时区--&gt;&lt;!--date: 显示日期--&gt;&lt;!--week: 显示周--&gt;&lt;!--month: 显示月--&gt;&lt;!--特定范围内的数值选择器 max、min、step、value--&gt;&lt;input type=&quot;range&quot; step=&quot;2&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;2&quot; name=&quot;&quot; id=&quot;&quot; /&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"HTML5新标签(一)","path":"/2018/08/14/HTML5新标签-一/","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!--语义化标签--&gt;&lt;header&gt;页面的头部&lt;/header&gt;&lt;hgroup&gt; &lt;h1&gt;Test&lt;/h1&gt; &lt;h2&gt;test&lt;/h2&gt;&lt;/hgroup&gt;&lt;footer&gt;页面的底部&lt;/footer&gt;&lt;nav&gt; &lt;a href=&quot;#&quot;&gt;导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;link1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;link2&lt;/a&gt;&lt;/nav&gt;&lt;section&gt;用来划分区域&lt;/section&gt;&lt;article&gt;用来在页面中表示一套结构完整且独立的内容部分（主题）&lt;/article&gt;&lt;aside&gt;和主题相关的附属信息&lt;/aside&gt;&lt;figure&gt;用于对元素进行组合，一般用于图片或视屏&lt;/figure&gt;&lt;figure&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; &lt;figcaption&gt;Test&lt;/figcaption&gt;&lt;/figure&gt;&lt;time&gt;9:00&lt;/time&gt;&lt;p&gt;明天 &lt;time datatime=&quot;2018-02-14&quot;&gt;情人节&lt;/time&gt;&lt;/p&gt;&lt;!--用于描述文档或文档某个部分的细节--&gt;&lt;details open&gt; &lt;!--open时默认打开--&gt; &lt;summary&gt;test&lt;/summary&gt; &lt;!--details元素的标题--&gt; &lt;p&gt;testjfkdsjkfsjd&lt;/p&gt;&lt;/details&gt;&lt;!--定义一段对话--&gt;&lt;dialog&gt; &lt;dt&gt;老师&lt;/dt&gt; &lt;dd&gt;2 + 3 ?&lt;/dd&gt; &lt;dt&gt;学生&lt;/dt&gt; &lt;dd&gt;5&lt;/dd&gt;&lt;/dialog&gt;&lt;address&gt;定义文章或页面作者的详细联系信息&lt;/address&gt;&lt;mark&gt;需要标记的词或句子&lt;/mark&gt;&lt;!--keygen给表单添加一个公钥--&gt;&lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; 用户： &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt; 公钥： &lt;keygen name=&quot;security&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;!--定义进度条--&gt;&lt;progress max=&quot;100&quot; value=&quot;76&quot;&gt; &lt;span&gt;76&lt;/span&gt;% &lt;!--为了兼容--&gt;&lt;/progress&gt;","tags":["整理","学习"],"categories":["HTML5"]},{"title":"对象的扩展","path":"/2018/08/13/对象的扩展/","content":"属性名表达式JavaScript定义属性有两种方法： 12obj.foo = true;obj[&#x27;a&#x27; + &#x27;bc&#x27;] = 123; ES6允许字面量定义对象时使用第二种方法： 12345678let propKey = &#x27;foo&#x27;;let obj = &#123; [propKey] : true, [&#x27;a&#x27; + &#x27;bc&#x27;] : 123, [&#x27;he&#x27; + &#x27;llo&#x27;]() &#123; return &#x27;hi&#x27;; &#125;&#125; 方法的name属性方法的name属性也返回函数名。 123456const person = &#123; sayName() &#123; console.log(&#x27;hello&#x27;); &#125;&#125;person.sayName.name; //&#x27;sayName&#x27; 如果对象的方法使用了getter和setter，则name的属性不是在该方法上面，而是在该方法属性的描述对象的get和set属性上面，返回值是方法名前面加上get和set 123456789const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;// obj.foo.name; //TypeError: Cannot read property &#x27;name&#x27; of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;);descriptor.get.name; //&#x27;get foo&#x27;descriptor.set.name; //&#x27;set foo&#x27; 如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。 12345678const key1 = Symbol(&#x27;description&#x27;);const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;&#125;;obj[key1].name; //&#x27;[description]&#x27;obj[key2].name; //&#x27;&#x27; Object.is()ES5比较两个值是否相等，只有两个相等运算符：&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;，他们都有个缺点，前者会自动转换数据类型，后者NaN不等于自身，以及+0等于-0。ES6提出了Same-value-equality算法来解决这个问题，Object.is()就是部署这个算法的新方法。不同之处只有两个： 1234+0 === -0; //trueNaN === NaN; //falseObject.is(+0, -0); //falseObject.is(NaN, NaN); //true ES5可以用代码部署： 12345678910111213Object.defineProperty(Object, &#x27;is&#x27; &#123; value : function(x, y) &#123; if (x === y) &#123; //针对+0不等于-0的情况 return x !== 0 || 1 / x === 1 / y; &#125; //针对NaN return x !== x &amp;&amp; y !== y; &#125;, configurable : true, enumerable : false, writable : true&#125;); Object.assign()Object.assign方法用于将源对象的所有 可枚举 属性复制到目标对象。第一个参数是目标对象，后面的参数都是源对象 12345var target = &#123; a : 1 &#125;;var source1 = &#123; b : 2 &#125;;var source2 = &#123; c : 3 &#125;;Object.assign(target, source1, source2);target; //&#123; a : 1, b : 2, c : 3 &#125; 如果只有一个参数，Object.assign()会直接返回该参数。如果参数不是对象，会先转成对象，然后返回，由于undefined和null无法转变，所以如果将他们作为参数，就会报错。但是，如果undefined和null不在首参数，那就不会报错。其他类型的值（数值、字符串和布尔值）不在首参数也不会报错，但是，除了字符串会以数组形式复制到目标对象，其他值都不会产生效果。Object.assign()方法实行的赋值是浅复制，如果源对象的某个属性的值是对象，那么目标对象得到的是这个对象的引用 1234var obj1 = &#123; a : &#123; b : 1 &#125; &#125;;var obj2 = Object.assign(obj2, obj1);obj1.a.b = 2;obj2.a.b; //2 对于这种嵌套对象，一旦遇到同名属性，处理的方法是替换而不是添加。 1234var target = &#123; a : &#123; b : &#x27;c&#x27;, d : &#x27;e&#x27; &#125; &#125;;var source = &#123; a : &#123; b : &#x27;hello&#x27; &#125; &#125;;Object.assign(target.source);//target对象的a属性被source对象的a属性整个替换掉了 Object.assign()可以用来处理数组，但是会把数组当成对象来处理。 1Object.assign([1, 2, 3], [4, 5]); //[4, 5, 3] 常见用途： 为对象添加属性：12345class Point &#123; constructor(x, y) &#123; Object.apply(this, &#123; x, y &#125;); &#125;&#125; 为对象添加方法：123456789101112131415Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; &#125;, anotherMethod() &#123; //... &#125;&#125;)//等同于SomeClass.prototype.someMethod = function (arg1, arg2) &#123; //...&#125;;SomeClass.prototype.anotherMethod = function () &#123; //...&#125; 克隆对象12345678910//只克隆对象自身值function clone(origin) &#123; Object.assign(&#123;&#125;, origin);&#125;//保持继承链的方法function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象1234const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);//合并到一个对象const merge = (...source) =&gt; Object.assign(&#123;&#125;, ...source); 为属性指定默认值123456789const DEFAULTS = &#123; logLevel : 0, outputFormat : &#x27;html&#x27;&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); //...&#125; 属性的可枚举性对象的每一个属性都有一描述对象，用于控制该属性的行为，Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = &#123; foo : 123 &#125;;Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;);// &#123;// value : 123,// writable : true,// enumerable : true,// configurable : false// &#125; enumerable属性成为可枚举性，如果该属性为false，就表示某些操作会忽略当前属性。ES5有三个操作会忽略enumerable为false的属性： for…in循环：只遍历对象自身和继承的可枚举属性。 Object.keys()： 返回对象自身的所有可枚举属性的键名。 JSON.stringify()：只串行化对象自身的可枚举属性。 ES6规定，所有Class的原型的方法都是不可枚举的 属性的遍历ES6共有五种方法遍历对象的属性： for…in循环：遍历对象自身和继承的可枚举属性（不含Symbol属性）。 Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有Symbol属性。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性，不管属性名是Symbol还是字符串，也不管是否可枚举。以上方法遍历对象属性时都遵守同样的属性遍历次序规则： 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 __proto__属性__proto__属性用来读取或设置当前对象的prototype对象。 123456789//ES6写法var obj = &#123; method : function() &#123;&#125;&#125;;obj.__proto__ = someOtherObj;//ES5写法var obj = Object.create(someOtherObj);obj.method = function() &#123;&#125;; 在实现上，__proto__调用的是Object.prototype.__proto__，实现如下： 123456789101112131415161718192021222324Object.defineProperty(Object.prototype, &#x27;__proto__&#x27;, &#123; get() &#123; let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); &#125;, set(proto) &#123; if (this === undefined || this === null) &#123; throw new TypeError(); &#125; if (!isObject(this)) &#123; return undefined; &#125; if (!isObject(proto)) &#123; return undefined; &#125; let status = Reflect.setPrototypeOf(this, proto); if (!status) &#123; throw new TypeError(); &#125; &#125;,&#125;);function isObject(value) &#123; return Object(value) === value;&#125; 如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。 1Object.getPrototypeOf(&#123; __proto__ : null &#125;); //null Object.setPrototypeOf()Object.setPrototypeOf()用于设置一个对象的prototype对象，返回参数本身。 12345678let proto = &#123;&#125;;let obj = &#123; x : 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 30;//obj对象可以读取proto对象的属性obj.y; //20obj.z; //30 如果第一个参数不是对象，就会自动转为对象，但是由于返回的还是第一个参数，所以这个操作不会有任何的结果。如果第一个参数是undefined或null，则会报错 Object.setPrototypeOf()Object.setPrototypeOf()用于读取一个对象的prototype对象。如果第一个参数不是对象，则会自动转为对象。如果第一个参数是undefined或null，则会报错 Object.keys()、Object.values()、Object.entries()Object.keys()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键名。Object.values()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值。Object.entries()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。实现Object.entries()： 123456789101112131415//Generator函数版本function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;//非Generator函数版本function entries(obj) &#123; let arr = []; for (let key of Object.keys(obj)) &#123; arr.push([key, obj[key]]); &#125; return arr;&#125; 对象的扩展运算符1234let &#123;x, y, ...z&#125; = &#123;x : 1, y : 2, a : 3, b : 4&#125;;x; //1y; //2z; //&#123; a : 3, b : 4 &#125; 扩展运算符可以用于合并两个对象 123let ab = &#123; ...a, ...b &#125;;//等同于let ab = Object.assign(&#123;&#125;, a, b); Object.getOwnPropertyDescriptors()ES5的Object.getOwnPropertyDescriptor()方法用来返回某个对象属性的descriptor。 12345678var obj = &#123; p : &#x27;a&#x27; &#125;;Object.getOwnPropertyDescriptor(obj, &#x27;p&#x27;);// Object &#123;// value : &#x27;a&#x27;,// writable : true,// enumerable: true,// configurable: true// &#125; ES2017引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承）的descriptor。 12345678910111213141516171819const obj = &#123; foo : 123, get bar() &#123; return this.foo; &#125;&#125;Object.getOwnPropertyDescriptors(obj);// &#123;// foo: &#123;// value : 123,// writable: true,// enumerable: true,// configurable: true// &#125;,// bar: &#123;// get: [Function bar],// set: undefined,// enumerable: true,// configurable: true// &#125;// &#125; 使用Object.prototype.toString()进行类型判断Object.prototype能够更好的识别出类型，typeof只能识别出基础类型。 1234let date = new Date()console.log(typeof date) // objectconsole.log(Object.prototype.toString.call(date)) // [object Date] 可以识别的类型有： 123: [object Number] ‘1234’: [object String] true: [object Boolean] undefined: [object Undefined] null: [object null] {foo: ‘bar’}: [object Object] [1, 2, 3]: [object Array] new Date(): [object Date] new Error(): [object Error] &#x2F;a+&#x2F;g: [object RegExp] function a() {}: [object Function] Math: [object Math] JSON: [object JSON] arguments: [object arguments]","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"数组的扩展","path":"/2018/08/13/数组的扩展/","content":"扩展运算符123456789console.log(...[1, 2, 3]); //1 2 3console.log(1, ...[2, 3], 4); //1 2 3 4[...document.querySelectorAll(&#x27;divi&#x27;)]; //[&lt;div&gt;, &lt;div&gt;, ...];function add(x, y) &#123; return x + y; &#125;add(...[1, 2]); //3//与表达式一同使用const arr = [...(x &gt; 0 ? [&#x27;a&#x27;] : []), &#x27;b&#x27;]; 扩展运算符的应用 替代数组的apply方法12345678910111213141516171819202122232425function f(x, y, z) &#123;&#125;var args = [0, 1, 2];//ES5写法f.apply(null, args);//ES6写法f(...args);//用Math.max求数组中最大的数//ES5写法Math.max.apply(null, [2, 33, 3]);//ES6写法Math.max(...[2, 33, 3]);//用push将一个数组添加到另一个数组尾部var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];//ES5写法Array.prototype.push.apply(arr1, arr2);//ES6写法arr1.push(...arr2); 合并数组123456789var arr1 = [&#x27;a&#x27;];var arr2 = [&#x27;b&#x27;, &#x27;c&#x27;];var arr3 = [&#x27;d&#x27;];//ES5写法arr1.concat(arr2, arr3);//ES6写法[...arr1, ...arr2, ...arr3]; 与解构赋值结合 如果将扩展运算符用于数组赋值，只能将其放在最后一位1const [first, ...middle, last] = [1, 2, 3, 4, 5]; //SyntaxError: Rest element must be last element 函数的返回值 字符串 实现了Iterator接口的对象 Map和Set解构、Generator函数 Array.from()Array.from()将两类对象转换成真正的数组： array-like object iterable object 123456789101112let arrayLike = &#123; &#x27;0&#x27; : &#x27;a&#x27;, &#x27;1&#x27; : &#x27;b&#x27;, &#x27;2&#x27; : &#x27;c&#x27;, length : 3&#125;;//ES5写法var arr = [].slice.call(arrayLike);//ES6写法let arr = Array.from(arrayLike); DOM操作返回的NodeList集合，以及函数内部的arguments对象，Array.from()都可以将他们转换成真正的数组 12//String有Iterator接口Array.from(&#x27;hello&#x27;); //[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] Array.from()还可以接受第二个参数，类似于数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。 12345Array.from(arrayLike, x =&gt; x * x);//等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from(&#123; length : 2 &#125;, () =&gt; &#x27;test&#x27;); //[&#x27;test&#x27;, &#x27;test&#x27;] 另一个用途是将字符串转为数组，然后返回长度，可以正确处理Unicode字符 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of用于将一组值转换为数组。 123Array.of(1, 2, 3); //[1, 2, 3]Array.of(); //[]Array.of(undefined); //[undefined] 模拟实现： 123function ArrayOf() &#123; return [].slice.call(arguments);&#125; 数组实例的copyWithin()在当前数组内将指定位置的成员复制到其他位置，然后返回当前数组。接受三个参数： 1Array.prototype.copyWithin(target, start = 0, end = this.length); target（必选）：从该位置开始替换数据 start（可选）：从该位置开始读取数据，默认为0。如果为负数，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负数，表示倒数。 这三个参数会自动转为数值 1234//从0位置开始，将3开始到this.length的位置的数据填入[1, 2, 3, 4, 5].copyWithin(0, 3); //[4, 5, 3, 4, 5];[1, 2, 3, 4, 5].copyWithin(0, 2); //[3, 4, 5, 4, 5]; 数组实例的find()和findIndex()find用于找出第一个符合条件的数组成员，参数是一个回调函数，如果没有符合的成员，返回undefined。 1[1, 3, -5, 3, 2].find((n) =&gt; n &lt; 0); //-5 findIndex方法与find()类似，没有符合的成员时返回-1。这两个方法都可以接受第二个参数，用来绑定回调函数的this对象，这两个函数都能发现NaN，弥补了IndexOf的不足。 12[NaN].indexOf(NaN); //-1[NaN].findIndex(y =&gt; Object.is(NaN, y)); //0 数组实例的fill()与copyWithin一样，接受三个参数： value：用于填充的值 start：起始位置 end：结束位置 1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(&#x27;7&#x27;, 0, 1); //[&#x27;7&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 数组实例的entries()、keys()和values()ES6提供了3个新方法用于遍历数组，他们都返回一个Generator对象，可用for…of遍历。唯一的区别在于keys()是对键名遍历，values()是对键值遍历，entries()是对键值对遍历。 数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与string的includes方法类似。ES2016引入了该方法。**Map和Set有has方法，需与includes区分 Map的has方法是查找键名的 Set的has方法是查找键值的 数组的空位数组的空位指数组的某一个位置没有任何值。比如Array构造函数返回的数组都是空位。 1Array(3); //[, , ,] 空位不是undefined 120 in [undefined, undefined, undefined];//0号位置有值0 in [,,,]; //0号位没值 ES5大多数情况下会忽略空位： forEach()、filter()、every()和some()都会跳过空位 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，undefined和null会被处理成空字符串 ES6将空位转为undefined由于空位的规则非常不统一，所以应避免出现空位","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"尾调用","path":"/2018/08/13/尾调用/","content":"尾调用Tail Call是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。 123function f(x) &#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 1234function f(x) &#123; if (x &gt; 0) return t(x); return m(x);&#125; 尾调用优化函数调用会在内存中形成一个call frame，保存调用位置和内部变量等信息。所有的call frame形成一个call stack。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的call frame，这就叫Tail Call Optimization，即只保留内层函数的调用帧。 尾递归递归非常耗内存，因为需要同时保存多个call frame，很容易发生stack overflow。但对于尾递归来说，由于只存在一个call frame，所以不会发生溢出。 1234567function Fibonacci(n) &#123; if (n &lt;= 1) return 1; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;console.log(Fibonacci(10)); //89console.log(Fibonacci(100)); //overflowconsole.log(Fibonacci(500)); //overflow 尾递归优化如下： 1234567function Fibonacci(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) return ac2; return Fibonacci(n - 1, ac2, ac1 + ac2);&#125;console.log(Fibonacci(10)); //89console.log(Fibonacci(100)); //573147844013817200000console.log(Fibonacci(500)); //2.2559151616193602e+104 由此可见，尾调用优化对递归操作意义重大，所有ECMAScript的实现都必须部署尾调用优化。 递归函数的改写函数式编程有一个概念，叫currying，将多参数的函数转换成单参数的形式。 123456789101112//阶乘的例子function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1); //fn, n都已设定factorial(5); //传m 120 第二种方法就是使用ES6的默认函数值 1234function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125; 尾递归优化的实现将递归转换成循环执行1234567891011121314151617function sum(x, y) &#123; //累加函数 if (y &gt; 0) return sum(x + 1, y - 1); else return x;&#125;// sum(1, 100000); //RangeError: Maximum call stack size exceeded//用trampoline将递归转换为循环执行function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125;function sum1(x, y) &#123; if (y &gt; 0) return sum1.bind(null, x + 1, y - 1); else return x;&#125;trampoline(sum1(1, 100000)); //100001 使用状态变量1234567891011121314151617181920function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function (x, y) &#123; if (y &gt; 0) return sum(x + 1, y - 1); else return x;&#125;);","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"函数的扩展","path":"/2018/08/13/函数的扩展/","content":"函数的默认值在ES6之前，不能直接为函数指定默认值，只能采用变通的方法： 12345678function log(x, y) &#123; if (y === &#x27;undefined&#x27;) &#123; y = &#x27;world&#x27;; &#125; console.log(x, y);&#125;log(&#x27;hello&#x27;); //hello testlog(&#x27;hello&#x27;, &#x27;&#x27;); //hello ES6允许为函数的参数设置默认值： 12345678910111213function log(x, y = &#x27;world&#x27;) &#123; console.log(x, y);&#125;log(&#x27;hello&#x27;); //hello worldlog(&#x27;hello&#x27;, &#x27;&#x27;); //helloeg:function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;let p = new Point();console.log(p.x + &#x27; &#x27; + p.y); //0 0 参数的默认值是lazy evaluation的，每次都重新计算默认值 1234567let x = 1;function foo(f = x + 1) &#123; console.log(f);&#125;foo(); //2x = 3;foo(); //4 解构赋值与默认值结合使用1234567function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;); //undefined 5foo(&#123;x : 1&#125;); //1 5foo(&#123;x : 1, y : 2&#125;); //1 2foo(); //TypeError: Cannot destructure property `x` of &#x27;undefined&#x27; or &#x27;null&#x27; 写法不同，默认值不同 123456789101112function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; //默认值是空对象 console.log(x, y);&#125;function m2(&#123;x, y&#125; = &#123;x : 0, y : 0&#125;) &#123; console.log(x, y);&#125;m1(); //0 0m2(); //0 0m1(&#123;x : 1, y : 2&#125;); //1 2m2(&#123;x : 1, y : 2&#125;); //1 2m1(&#123;&#125;); //0 0m2(&#123;&#125;); //undefined undefined 如果传入undefined，将触发该参数等于默认值，null没有效果 1234function foo(x = 1, y = 2) &#123; console.log(x, y);&#125;foo(undefined, null); //1 null 利用默认参数可以指定某一个参数不得省略，省略就报错 1234567function throwIfMissing() &#123; throw new Error(&#x27;Missing parameter&#x27;);&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo(); //Error: Missing parameter 可以将参数默认值设为undefined，表明这个参数是可以省略的 1function foo(optional = undefined) &#123;&#125; 函数的length属性length不计从默认参数开始的参数个数。 123(function (a) &#123;&#125;).length; //1(function (a = 5) &#123;&#125;).length; //0(function (a, b = 1) &#123;&#125;).length; //1 rest参数ES6引入了rest参数，用于获取函数的多余参数，这样就不用使用arguments对象了。 12345678910111213function add(...values) &#123; let sum = 0; for (let value of values) sum += value; return sum;&#125;add(1,2,3,4); //10//arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;//rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 函数的length属性也不包括rest参数 name属性函数的name属性返回该函数的函数名 12345678910111213function foo() &#123;&#125;foo.name; //&#x27;foo&#x27;var f = function () &#123;&#125;//ES5f.name; //&#x27;&#x27;//ES6f.name; //&#x27;f&#x27;const bar = function baz() &#123;&#125;bar.name; //&#x27;baz&#x27; Function构造函数返回的函数实例，name属性的值为anonymous。 1(new Function).name; //&#x27;anonymous&#x27; bind返回的函数，name属性值会加上bound前缀。 123function foo() &#123;&#125;foo.bind(&#123;&#125;).name; //&#x27;bound foo&#x27;(function () &#123;&#125;).bind(&#123;&#125;).name; //&#x27;bound &#x27; 箭头函数123var f = (v) =&gt; v;//等同于var f = function (v) &#123; return v; &#125; 如果箭头函数的代码块多于一条语句，就要使用大括号括起来。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果直接返回一个对象，必须在对象外加上括号。 1var get = id =&gt; (&#123;id : id, name : &#x27;get&#x27;&#125;); 可以与变量解构结合使用 12345const full = (&#123;first, last&#125;) =&gt; first + &#x27;,&#x27; + last;//等同于function full(person) &#123; return person.first + &#x27;,&#x27; + person.last;&#125; 注意事项 函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。 不可当做构造函数，不能使用new命令。 不可使用arguments对象，该对象在函数体内不存在，可以使用rest参数代替。 不可以使用yield命令，因此不能做Generator函数。 1234567function foo() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;id:&#x27;, this.id); &#125;, 1000);&#125;let id = 21;foo.call(&#123;id : 4&#125;); //id: 4 嵌套的箭头函数1234567891011121314function insert(value) &#123; return &#123; into: function (array) &#123; return &#123; after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); //[1, 2, 3]//箭头函数写法const insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123; after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array;&#125;&#125;)&#125;); apply的简易实现Function.apply(thisArg: any, argArray?: any)第一个参数用于接受this对象，剩余参数为arguments。所以可以根据思路： 将this挂载到thisArg.fn上 通过thisArg.fn传递参数，获取返回值 删除thisArg.fn 返回 在浏览器中，如果第一个参数为this，那么需要将thisArg设置为window对象。 123456789101112131415161718Function.prototype.my_apply = function (context, array) &#123; context = Object(context) || window context.fn = this let result if (!array) &#123; result = context.fn() &#125; else &#123; let args = [] for (let i = 0, len = array.length; i &lt; len; i++) &#123; args.push(`array[$&#123;i&#125;]`) &#125; result = eval(`context.fn($&#123;args&#125;)`) // context.fn(array[0], array[1]) &#125; delete context.fn return result&#125; call的简易实现与apply的实现类似，区别在于参数的获取方式不同。 12345678910111213Function.prototype.my_call = function (context) &#123; let args = [] context = Object(context) || window // if call(null) then point to window context.fn = this // put current function into context.fn for (let i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(`arguments[$&#123;i&#125;]`) // push the arguments into args &#125; let result = eval(`context.fn($&#123;args&#125;)`) // call function with parameters delete context.fn return result&#125; bind的简易实现bind有个最大的特点，就是绑定后的函数也可以使用new操作符创建对象，这时bind中指定的this就会被忽略，转而指向被构造的对象： 12345678910111213141516171819202122let age = 2let person = &#123; age: 12&#125;function foo(text) &#123; this.first = &#x27;Edward&#x27; console.log(this.age) console.log(text)&#125;foo.prototype.last = &#x27;Snowden&#x27;let bindFoo = foo.bind(person, &#x27;some text&#x27;)let obj = bindFoo()// 12// some textlet newObj = new bindFoo()// undefined// some textconsole.log(newObj.first, newObj.last) // Edward Snowden 在上面这个例子中，不管是person中的age还是Global中的age，都没有被打印出来，因为此时的this已经指向了newObj。所以需要通过修改返回值来实现。 1234567891011121314151617181920Function.prototype.my_bind = function (context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new Error(`need to be function`) &#125; let _this = this let args = Array.prototype.slice.call(arguments, 1) // get the rest of arguments let fTemp = function () &#123;&#125; let fBound = function () &#123; let bindArgs = Array.prototype.slice.call(arguments) // get the arguments from the return function return _this.apply(this instanceof fTemp ? this : context, args.concat(bindArgs)) // check if it is be a constructor &#125; fTemp.prototype = this.prototype fBound.prototype = new fTemp() return fBound&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"~运算符","path":"/2018/08/12/运算符/","content":"~运算符位运算符是三步处理的过程： 把运算数转换成32位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 123var iNum1 = 25; //25 等于 00000000000000000000000000011001var iNum2 = ~iNum1; //转换为 11111111111111111111111111100110alert(iNum2); //输出 &quot;-26&quot; ~~技巧这是刷题时看见别人的代码里使用的东西，通常用来代替Math.trunc()的方法。 123456//单个 ~console.log(~1337); // -1338//数字输入console.log(~~47.11); //47console.log(~~1.9999); //1console.log(~~3); //3 当原始输入不确定时，~~可以将任何非数字类型转换成0： 12345678console.log(~~[]) //0console.log(~~NaN) //0console.log(~~null) //0// | 0也是相同的效果console.log([] | 0) //0console.log(NaN | 0) //0console.log(null | 0) //0 在使用前应仔细检查值，数值大的情况： 1234let number = 2147483647.123; //比32位最大正数，再多一点console.log(~~number); //2147483647 (ok)number += 10000; //2147493647.123 (ok)console.log(~~number); //-2147473649","tags":["学习"],"categories":["ECMAScript"]},{"title":"Math的扩展","path":"/2018/08/11/Math的扩展/","content":"Math.trunc()Math.trunc用于除去一个数的小数部分。 123456789Math.trunc(111.22); //111Math.trunc(&#x27;123.456&#x27;); //123//对空和无法截取整数的值，返回NaNMath.trunc(NaN); //NaN//代码模拟Math.trunc = Math.trunc || function (x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.sign()Math.sign用于判断一个数到底是正数、负数、还是零。 参数为正数，返回+1 参数为负数，返回-1 参数为0，返回0 参数为-0，返回-0 其他值，返回NaN 12345678//代码模拟Math.sign = Math.sign || function (x) &#123; x = +x; //convert to a number if (x === 0 || isNaN(x)) &#123; return x; &#125; return x &gt; 0 ? 1 : -1;&#125;; Math.cbrt()Math.cbrt用于计算一个数的立方根，对于非数值，内部也是先使用Number方法转换为数值。 12345//代码模拟Math.cbrt = Math.cbrt || function (x) &#123; var y = Math.pow(Math.abs(x), 1 / 3); return x &lt; 0 ? -y : y;&#125;; Math.clz32()Math.clz32返回一个数的32位无符号整数形式有多少个前导0. 12345Math.clz32(0); //32Math.clz32(1); //31Math.clz32(0b01000000000000000000000000000000); //1Math.clz32(1 &lt;&lt; 1); //30 对于小数，Math.clz32()只考虑整数部分 1Math.clz32(3.9); //30 Math.imul()Math.imul返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位带符号整数。对于很大数的乘法，低位数值往往是不精确的，Math.imul()方法可以正确的返回低位数值。 Math.fround()Math.fround方法返回一个数的单精度浮点数形式。对于整数来说，Math.fround()方法的返回结果不会有任何不同，区别主要在于那些无法用64个二进制位精确表示的小数。这时，Math.fround()方法会返回最接近这个小数的单精度浮点数。 1234//代码模拟Math.fround = Math.fround || function (x) &#123; return new Float32Array([x])[0];&#125;; Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1Math.hypot(3, 4); //5 Math.expm1()Math.expm1(x)返回$e^x-1$， 即Math.exp(x) - 1; 1234//代码模拟Math.expm1 = Math.expm1 || function (x) &#123; return Math.exp(x) - 1;&#125;; Math.log1p()Math.log1p(x)返回$ln(1+x)$，即Math.log(1 + x)。如果x小于-1，则返回NaN。 1234//代码模拟Math.log1p = Math.log1p || function (x) &#123; return Math.log(1 + x);&#125; Math.log10()Math.log10(x)返回$log_{10}(x)$，如果x小于0，返回NaN。 1234//代码模拟Math.log10 = Math.log10 || function (x) &#123; return Math.log(x) / Math.LN10;&#125;; Math.log2()Math.log2(x)返回$log_2(x)$，如果x小于0，返回NaN。 1234//代码模拟Math.log2 = Math.log2 || function (x) &#123; return Math.log(x) / Math.LN2;&#125;; 双曲函数方法ES6新增了六个双曲函数方法 Math.sinh(x) 返回 $sinh\\ x&#x3D;\\frac{e^x-e^{-x}}{2}$ Math.cosh(x) 返回 $cosh\\ x&#x3D;\\frac{e^x+e^{-x}}{2}$ Math.tanh(x) 返回 $tanh\\ x&#x3D;\\frac{sinh\\ x}{cosh\\ x}&#x3D;\\frac{e^x-e^{-x}}{e^x+e^{-x}}$ Math.asinh(x) 返回 $arsinh\\ x&#x3D;ln(x+\\sqrt[\\ ]{x^2+1})$ Math.acosh(x) 返回 $arsinh\\ x&#x3D;ln(x+\\sqrt[\\ ]{x^2-1})$ Math.atanh(x) 返回 $artanh\\ x&#x3D;\\frac{1}{2}ln\\frac{1+x}{1-x}$ Math.sign()Math.sign用来判断一个数的正负，如果参数是-0，会返回-0。 指数运算符**123452 ** 2; //43 ** 3; //27let a = 1.5;a **= 3; //a = a * a * a; 在V8引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有差异","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"Number的扩展","path":"/2018/08/11/Number的扩展/","content":"进制表示0b(0B)表示二进制，0o(0O)表示八进制 Number.isFinite()、Number.isNaN()Number.isFinite用来检查一个数值是否为有限的。 123456Number.isFinite(NaN); //falseNumber.isFinite(Infinity); //falseNumber.isFinite(-Infinity); //falseNumber.isFinite(&#x27;15&#x27;); //falseNumber.isFinite(&#x27;foo&#x27;); //falseNumber.isFinite(true); //false ES5部署Number.isFinite()方法： 123456789101112(function (global) &#123; var global_isFinite = global.isFinite; Object.defineProperty(Number, &#x27;isFinite&#x27;, &#123; value : function isFinite(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; global_isFinite(value); &#125;, configurable : true, enumerable : false, writable : true &#125;);&#125;)(this); Number.isNaN用来检查一个值是否为NaN。 12345Number.isNaN(NaN); //trueNumber.isNaN(&#x27;15&#x27;); //falseNumber.isNaN(9 / NaN); //trueNumber.isNaN(&#x27;true&#x27; / 0); //trueNumber.isNaN(&#x27;true&#x27; / &#x27;true&#x27;); //true ES5部署Number.isNaN()方法： 123456789101112(function (global) &#123; var global_isNaN = global.isNaN; Object.defineProperty(Number, &#x27;isNaN&#x27;, &#123; value : function isNaN(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; global_isNaN(value); &#125;, configurable : true, enumerable : false, writable : true &#125;);&#125;)(this); Number.parseInt()、Number.parseFloat()ES6将全局方法parseInt和parseFloat移植到了Number对象上面，行为完全不变。 Number.isInteger()Number.isInteger判断一个值是否为整数。在JavaScript内部，整数和浮点数是相同的储存方法，所以3和3.0视为同一个值。 12Number.isInteger(&#x27;15&#x27;); //falseNumber.isInteger(true); //false ES5部署Number.isInteger()方法： 123456789101112(function (global) &#123; var floor = Math.floor, isFinite = global.isFinite; Object.defineProperty(Number, &#x27;isInteger&#x27;, &#123; value : function isInteger(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; isFinite(value) &amp;&amp; floor(value) == value; &#125;, configurable : true, enumerable : false, writable : true &#125;);&#125;)(this); Number.EPSILONES6在Number对象上面新增一个极小的常量–Number.EPSILON。浮点数计算是不精确的，但是如果这个误差可以小于Number.EPSILON，就可以认为得到了正确的结果。 Number.isSafeInteger()JavaScript能够准确表示的整数范围在$-2^{53}$到$2^{53}$之间（不含两个端点），超过这个范围就无法精确表示。ES6引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 两个常量来表示这个范围的上下限","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"正则的扩展","path":"/2018/08/11/正则的扩展/","content":"基本用法12345var regex = new RegExp(&#x27;xyz&#x27;, &#x27;i&#x27;);var regex = new RegExp(/xyz/i);var regex = /xyz/i;new RegExp(/abc/ig, &#x27;i&#x27;).flags; //ig被覆盖成i match()、replace()、search()、split()String.prototype.match 调用 RegExp.prototype[Symbol.match]String.prototype.replace 调用 RegExp.prototype[Symbol.replace]String.prototype.search 调用 RegExp.prototype[Symbol.search]String.prototype.split 调用 RegExp.prototype[Symbol.split] u修饰符、i修饰符、y修饰符ES6对正则表达式添加了u修饰符，用来处理大于\\uFFFF的Unicod字符。\\u004B与\\u212A都是K，不加修饰就无法识别非规范的K字符。y修饰符与g修饰符类似，也是全局匹配，不同之处在于g修饰符只要剩余位置中存在匹配就行，而y修饰符会确保匹配必须从剩余的第一个位置开始。 12345678var s = &#x27;aaa-aa-a&#x27;;var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); //[&#x27;aaa&#x27;]r2.exec(s); //[&#x27;aaa&#x27;]r1.exec(s); //[&#x27;aa&#x27;]r2.exec(s); //null sticky属性与y修饰符匹配，表示是否设置了y修饰符。 flags属性返回正则表达式的修饰符。 组匹配12345const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(&#x27;2018-03-01&#x27;);const year = matchObj[1]; //2018const month = matchObj[2]; //03const day = matchObj[3]; //01","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"字符串的扩展","path":"/2018/08/10/字符串的扩展/","content":"codePointAt()JavaScript-16的格式储存，每个字符固定为两个字节。需要四个字节储存的字符，JavaScript会认为那是两个字符。ES6提供了codePointAt方法，能够正确处理四个字节储存的字符，返回一个字符的码点。 String.fromCodePoint()识别UTF-32字符。 includes()、startsWith()、endsWith()1234567var s = &#x27;hello world&#x27;;s.startWith(&#x27;hello&#x27;); //trues.endsWith(&#x27;d&#x27;); //trues.includes(&#x27;o&#x27;); //trues.startsWith(&#x27;world&#x27;, 6); //true;s.includes(&#x27;hello&#x27;, 6); //false repeat()1234567891011&#x27;x&#x27;.repeat(3); //&#x27;xxx&#x27;&#x27;na&#x27;.repeat(0); //&#x27;&#x27;&#x27;na&#x27;.repeat(2.9); //取整 -&gt; &#x27;nana&#x27;&#x27;na&#x27;.repeat(Infinity); //Error&#x27;na&#x27;.repeat(-1); //Error&#x27;na&#x27;.repeat(-0.9); //&#x27;&#x27;&#x27;na&#x27;.repeat(NaN); //&#x27;&#x27;&#x27;na&#x27;.repeat(&#x27;3&#x27;); //&#x27;nanana&#x27; padStart(), padEnd()首、尾补全 123456789&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;); //&#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;); //&#x27;abax&#x27;&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;); //&#x27;xabab&#x27;&#x27;x&#x27;.padStart(5); //&#x27; x&#x27;&#x27;x&#x27;.padEnd(5); //&#x27;x &#x27;&#x27;1&#x27;.padStart(10, &#x27;0&#x27;); //&#x27;0000000001&#x27;&#x27;09-12&#x27;.padStart(10, &#x27;YYYY-MM-DD&#x27;); //&#x27;YYYY-09-12&#x27; 模板字符串1234567891011121314let name = &#x27;test&#x27;;`name : $&#123;name&#125;`;let x = 1, y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`;//1 + 2 = 3let obj = &#123; x : 1, y : 2 &#125;;`&#123;obj.x + obj.y&#125;`;function fn() &#123; return &#x27;test&#x27;&#125;`foo $(fn)`; String.raw()Sring.raw方法用来充当模板字符串的处理函数，返回一个斜线都被转义的字符串，对应于替换变量后的模板字符串。 12String.raw`Hi $&#123;1 + 3&#125;`;//Hi\\ 4","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"解构赋值","path":"/2018/08/10/解构赋值/","content":"基本用法12345678910111213141516171819let [a, b, c] = [1, 2, 3];let [foo, [[bar], baz]] = [1, [[2], 3]];let [, , third] = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;];third; //&#x27;baz&#x27;let [x, , y] = [1, 2, 3];x, y; //1, 3let [head, ...tail] = [1, 2, 3, 4];head; //1tail; //[2, 3, 4]let [x, y, ...z] = [&#x27;a&#x27;];x; //ay; //undefinedz; //[]let [x, y, z] = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);x; //&#x27;a&#x27; 不完全解构也会解构成功1234567let [x, y] = [1, 2, 3];x, y; //1, 2let [a, [b], d] = [1, [2, 3], 4];a; //1b; //2d; //4 只要具备Iterator接口，都可以进行解构赋值123456789function* fibs() &#123; let a = 0, b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth; //5 默认值1234567let [foo = &#x27;true&#x27;] = [];foo; //truelet [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; //x = a, y = blet [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;, undefined]; //x = a, y = b;let [x = 1] = [null]; //x = null, null不严格等于undefined 如果默认值是一个表达式，那么这个表达式是lazy evaluation的，只有在用到时才会求值。 12345function f() &#123; console.log(&#x27;f is run&#x27;);&#125;let [x = f()] = [1]; //f不会执行let [x = y, y = 1] = []; //ReferenceError 对象的解构赋值12345678let &#123; foo, bar &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27; &#125;;foo; //&#x27;aaa&#x27;bar; //&#x27;baz&#x27;let &#123; baz &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27; &#125;;baz; //undefinedlet &#123; foo : baz &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27; &#125;;baz; //&#x27;aaa&#x27; 前者是匹配模式，后者是变量。 1let &#123; foo : foo, bar : bar &#125; = &#123; foo : &#x27;aaa&#x27;, bar : &#x27;baz&#x27;&#125;; 解构的嵌套123456789101112131415161718192021222324let obj = &#123; p : [ &#x27;hello&#x27;, &#123; y : &#x27;world&#x27; &#125; ]&#125;;let &#123; p : [x, &#123;y&#125;]&#125; = obj;//x : &#x27;hello&#x27;, y : &#x27;world&#x27;var node = &#123; loc : &#123; start : &#123; line : 1, column : 5 &#125; &#125;&#125;;var &#123; loc, loc : &#123; start &#125;, loc : &#123; start : &#123; line &#125;&#125;&#125; = node;line; //1loc; //Object &#123;start : Object&#125;start; //Object &#123;line : 1, column : 5&#125;let x;(&#123;x&#125; = &#123;x : 1&#125;); //避免JavaScript解释为代码块 如果解构失败，变量的值等于undefined 解构的用途交换变量的值12let x = 1, y = 2;[x, y] = [y, x]; 从函数返回多个值1234567891011function example1() &#123; return [1, 2, 3];&#125;let [a, b, c] = example1();function example2() &#123; return &#123; foo : 1, bar : 2 &#125;;&#125;let &#123; foo, bar &#125; = example2(); 函数参数的定义1234function f([x, y, z]) &#123;&#125;f([1, 2, 3]);function f1(&#123;x, y, z&#125;) &#123;&#125;f1(&#123;z : 3, y : 1, x : 1&#125;); 提取JSON数据123456let jsonData = &#123; id : 32, status : &#x27;OK&#x27;, data : [332, 452]&#125;let &#123; id, status, data : number &#125; = jsonData;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"顶层对象","path":"/2018/08/10/顶层对象/","content":"ES6中，为了保持兼容性，var和function声明的全局变量依旧是顶层对象的属性1234var a = 1; //如果在Node的REPL环境，可以写成global.a或者this.awindow.a; //1let b = 1;window.b; //undefined global对象 在浏览器对象中，顶层对象是window，但Node和Web Worker没有window。 在浏览器和Web Worker中，self也指向顶层对象，但Node没有self。 在Node中，顶层对象是global，但其他环境都不支持。 以下为两种勉强可以取到顶层对象的方法： 1234567891011//方法一(typeof window !== &#x27;undefined&#x27; ? window : ( typeof process === &#x27;object&#x27; &amp;&amp; typeof require === &#x27;function&#x27; &amp;&amp; typeof global === &#x27;object&#x27;) ? global : this);//方法二var getGlobal = function () &#123; if (typeof self !== &#x27;undefined&#x27;) &#123; return self; &#125; if (typeof window !== &#x27;undefined&#x27;) &#123; return window; &#125; if (typeof global !== &#x27;undefined&#x27;) &#123; return global; &#125; throw new Error(&#x27;unalbe to locate global object&#x27;);&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"const","path":"/2018/08/10/const/","content":"一旦声明，值不可变12const PI = 3.14;PI = 3; //TypeError: Assignment to constant variable. 只声明不赋值也会报错。 1const foo; //SyntaxError: Missing initializer in const declaration 实质为变量指向的内存地址不可变动const只能保证这个指针是固定的，不能控制数据结构的变化。 123const foo = &#123;&#125;;foo.prop = 123; //Successfoo = &#123;&#125;; //TypeError: &#x27;foo&#x27; is read-only 对象冻结方法使用Object.freeze函数，冻结对象 1const foo = Object.freeze(&#123;&#125;); 冻结属性的函数 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if (typeof obj[key] === &#x27;object&#x27;) &#123; constantize(obj[key]); &#125; &#125;);&#125;;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"let","path":"/2018/08/10/let/","content":"let声明的变量在代码块内有效1234567var a [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); //6 不存在变量提升var命令的变量可以在声明之前使用，值为undefined 暂时性死区在代码块内，使用let命令声明变量之前，该变量都是不可用的。TDZ(temporal dead zone) 12345var temp = 123;if (true) &#123; temp = &#x27;abc&#x27;; //ReferenceError let temp;&#125; 有些死区是不易发现的 1234function bar(x = y, y = 2) &#123; //y is not defined return [x, y];&#125;let x = x; //ReferenceError: x is not defined 不允许重复声明1234function foo() &#123; var a; let a;&#125;","tags":["整理","学习"],"categories":["ECMAScript"]},{"title":"未看书导致的一个坑","path":"/2018/08/10/未看书导致的一个坑/","content":"某日被书中一段代码误导 1234567var promise = new Promise(function (resolve, reject) &#123; resolve(&#x27;ok&#x27;); setTimeout(function() &#123; throw new Error(&#x27;test&#x27;) &#125;, 0);&#125;);promise.then(function (value) &#123; console.log(value) &#125;);//ok//Uncaught Error : test 由于前面还有这样一段话 如果Promise状态已经变成Resolved，再抛出错误是无效的。 当时看到这，思索了许久，为什么已经resolve了这个ERROR还是可以往外抛出呢？后面发现，settimeout是一个异步函数，throw会在下一轮事件循环开始时抛出，所以无论是否resolve，这个ERROR都是会抛出的。","tags":["学习"]},{"title":"开坑","path":"/2018/08/10/开坑/","content":"开坑第一篇从大学开始就想着弄一篇自己的博客，但是一直都断断断续的。在这个风雨交加的午间，我决定开坑了。可能以后主要还是用于记笔记之类的吧，偶尔应该也会写点杂七杂八的东西。。","tags":["雜談"]},{"title":"ABOUT ME","path":"/about/index.html","content":"Freelancers"}]
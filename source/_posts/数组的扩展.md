---
title: 数组的扩展
date: 2018-08-13 15:54:32
tags:
- '学习'
- '整理'
categories:
- 'ECMAScript'
---
### 扩展运算符
{% codeblock lang:javascript %}
console.log(...[1, 2, 3]);              //1 2 3
console.log(1, ...[2, 3], 4);           //1 2 3 4
[...document.querySelectorAll('divi')]; //[<div>, <div>, ...];

function add(x, y) { return x + y; }
add(...[1, 2]);                         //3

//与表达式一同使用
const arr = [...(x > 0 ? ['a'] : []), 'b'];
{% endcodeblock %}
### 扩展运算符的应用
* 替代数组的apply方法
{% codeblock lang:javascript %}
function f(x, y, z) {}
var args = [0, 1, 2];

//ES5写法
f.apply(null, args);

//ES6写法
f(...args);

//用Math.max求数组中最大的数
//ES5写法
Math.max.apply(null, [2, 33, 3]);

//ES6写法
Math.max(...[2, 33, 3]);

//用push将一个数组添加到另一个数组尾部
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];

//ES5写法
Array.prototype.push.apply(arr1, arr2);

//ES6写法
arr1.push(...arr2);
{% endcodeblock %}
* 合并数组
{% codeblock lang:javascript %}
var arr1 = ['a'];
var arr2 = ['b', 'c'];
var arr3 = ['d'];

//ES5写法
arr1.concat(arr2, arr3);

//ES6写法
[...arr1, ...arr2, ...arr3];
{% endcodeblock %}
* 与解构赋值结合
**如果将扩展运算符用于数组赋值，只能将其放在最后一位**
{% codeblock lang:javascript %}
const [first, ...middle, last] = [1, 2, 3, 4, 5];   //SyntaxError: Rest element must be last element
{% endcodeblock %}
* 函数的返回值
* 字符串
* 实现了Iterator接口的对象
* Map和Set解构、Generator函数
### Array.from()
Array.from()将两类对象转换成真正的数组：
* array-like object
* iterable object

{% codeblock lang:javascript %}
let arrayLike = {
    '0' : 'a',
    '1' : 'b',
    '2' : 'c',
    length : 3
};

//ES5写法
var arr = [].slice.call(arrayLike);

//ES6写法
let arr = Array.from(arrayLike);
{% endcodeblock %}
**DOM操作返回的NodeList集合，以及函数内部的arguments对象，Array.from()都可以将他们转换成真正的数组**
{% codeblock lang:javascript %}
//String有Iterator接口
Array.from('hello');                        //['h', 'e', 'l', 'l', 'o']
{% endcodeblock %}
Array.from()还可以接受第二个参数，类似于数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。
{% codeblock lang:javascript %}
Array.from(arrayLike, x => x * x);
//等同于
Array.from(arrayLike).map(x => x * x);

Array.from({ length : 2 }, () => 'test');   //['test', 'test']
{% endcodeblock %}
**另一个用途是将字符串转为数组，然后返回长度，可以正确处理Unicode字符**
{% codeblock lang:javascript %}
function countSymbols(string) {
    return Array.from(string).length;
}
{% endcodeblock %}
### Array.of()
Array.of用于将一组值转换为数组。
{% codeblock lang:javascript %}
Array.of(1, 2, 3);      //[1, 2, 3]
Array.of();             //[]
Array.of(undefined);    //[undefined]
{% endcodeblock %}
模拟实现：
{% codeblock lang:javascript %}
function ArrayOf() {
    return [].slice.call(arguments);
}
{% endcodeblock %}
### 数组实例的copyWithin()
在当前数组内将指定位置的成员复制到其他位置，然后返回当前数组。接受三个参数：
{% codeblock lang:javascript %}
Array.prototype.copyWithin(target, start = 0, end = this.length);
{% endcodeblock %}
* target（必选）：从该位置开始替换数据
* start（可选）：从该位置开始读取数据，默认为0。如果为负数，表示倒数。
* end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负数，表示倒数。

**这三个参数会自动转为数值**
{% codeblock lang:javascript %}
//从0位置开始，将3开始到this.length的位置的数据填入
[1, 2, 3, 4, 5].copyWithin(0, 3);   //[4, 5, 3, 4, 5];

[1, 2, 3, 4, 5].copyWithin(0, 2);   //[3, 4, 5, 4, 5];
{% endcodeblock %}
### 数组实例的find()和findIndex()
find用于找出第一个符合条件的数组成员，参数是一个回调函数，如果没有符合的成员，返回undefined。
{% codeblock lang:javascript %}
[1, 3, -5,  3, 2].find((n) => n < 0);   //-5
{% endcodeblock %}
findIndex方法与find()类似，没有符合的成员时返回-1。
这两个方法都可以接受第二个参数，用来绑定回调函数的this对象，这两个函数都能发现NaN，弥补了IndexOf的不足。
{% codeblock lang:javascript %}
[NaN].indexOf(NaN);                         //-1
[NaN].findIndex(y => Object.is(NaN, y));    //0
{% endcodeblock %}
### 数组实例的fill()
与copyWithin一样，接受三个参数：
* value：用于填充的值
* start：起始位置
* end：结束位置

{% codeblock lang:javascript %}
['a', 'b', 'c'].fill('7', 0, 1);    //['7', 'b', 'c']
{% endcodeblock %}
### 数组实例的entries()、keys()和values()
ES6提供了3个新方法用于遍历数组，他们都返回一个Generator对象，可用for...of遍历。
唯一的区别在于keys()是对键名遍历，values()是对键值遍历，entries()是对键值对遍历。
### 数组实例的includes()
Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与string的includes方法类似。ES2016引入了该方法。
**Map和Set有has方法，需与includes区分
* Map的has方法是查找键名的
* Set的has方法是查找键值的
### 数组的空位
数组的空位指数组的某一个位置没有任何值。比如Array构造函数返回的数组都是空位。
{% codeblock lang:javascript %}
Array(3);   //[, , ,]
{% endcodeblock %}
**空位不是undefined**
{% codeblock lang:javascript %}
0 in [undefined, undefined, undefined];//0号位置有值
0 in [,,,];                            //0号位没值
{% endcodeblock %}
ES5大多数情况下会忽略空位：
* forEach()、filter()、every()和some()都会跳过空位
* map()会跳过空位，但会保留这个值
* join()和toString()会将空位视为undefined，undefined和null会被处理成空字符串

ES6将空位转为undefined
**由于空位的规则非常不统一，所以应避免出现空位**
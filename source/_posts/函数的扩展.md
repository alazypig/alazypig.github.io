---
title: 函数的扩展
date: 2018-08-13 11:03:55
tags:
- '学习'
- '整理'
categories:
- 'ECMAScript'
---
### 函数的默认值
在ES6之前，不能直接为函数指定默认值，只能采用变通的方法：
{% codeblock lang:javascript %}
function log(x, y) {
    if (y === 'undefined') {
        y = 'world';
    }
    console.log(x, y);
}
log('hello');       //hello test
log('hello', '');   //hello
{% endcodeblock %}
ES6允许为函数的参数设置默认值：
{% codeblock lang:javascript %}
function log(x, y = 'world') {
    console.log(x, y);
}
log('hello');       //hello world
log('hello', '');   //hello

eg:
function Point(x = 0, y = 0) {
    this.x = x;
    this.y = y;
}
let p = new Point();
console.log(p.x + ' ' + p.y);   //0 0
{% endcodeblock %}
**参数的默认值是lazy evaluation的，每次都重新计算默认值**
{% codeblock lang:javascript %}
let x = 1;
function foo(f = x + 1) {
    console.log(f);
}
foo();  //2
x = 3;
foo();  //4
{% endcodeblock %}
### 解构赋值与默认值结合使用
{% codeblock lang:javascript %}
function foo({x, y = 5}) {
    console.log(x, y);
}
foo({});                //undefined 5
foo({x : 1});           //1 5
foo({x : 1, y : 2});    //1 2
foo();                  //TypeError: Cannot destructure property `x` of 'undefined' or 'null'
{% endcodeblock %}
**写法不同，默认值不同**
{% codeblock lang:javascript %}
function m1({x = 0, y = 0} = {}) {  //默认值是空对象
    console.log(x, y);
}
function m2({x, y} = {x : 0, y : 0}) {
    console.log(x, y);
}
m1();               //0 0
m2();               //0 0
m1({x : 1, y : 2}); //1 2
m2({x : 1, y : 2}); //1 2
m1({});             //0 0
m2({});             //undefined undefined
{% endcodeblock %}
如果传入undefined，将触发该参数等于默认值，null没有效果
{% codeblock lang:javascript %}
function foo(x = 1, y = 2) {
    console.log(x, y);
}
foo(undefined, null);   //1 null
{% endcodeblock %}
**利用默认参数可以指定某一个参数不得省略，省略就报错**
{% codeblock lang:javascript %}
function throwIfMissing() {
    throw new Error('Missing parameter');
}
function foo(mustBeProvided = throwIfMissing()) {
    return mustBeProvided;
}
foo();  //Error: Missing parameter
{% endcodeblock %}
**可以将参数默认值设为undefined，表明这个参数是可以省略的**
{% codeblock lang:javascript %}
function foo(optional = undefined) {}
{% endcodeblock %}

### 函数的length属性
length不计从默认参数开始的参数个数。
{% codeblock lang:javascript %}
(function (a) {}).length;           //1
(function (a = 5) {}).length;       //0
(function (a, b = 1) {}).length;    //1
{% endcodeblock %}
### rest参数
ES6引入了rest参数，用于获取函数的多余参数，这样就不用使用arguments对象了。
{% codeblock lang:javascript %}
function add(...values) {
    let sum = 0;
    for (let value of values) sum += value;
    return sum;
}
add(1,2,3,4);   //10

//arguments变量的写法
function sortNumbers() {
    return Array.prototype.slice.call(arguments).sort();
}
//rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
{% endcodeblock %}
**函数的length属性也不包括rest参数**
### name属性
函数的name属性返回该函数的函数名
{% codeblock lang:javascript %}
function foo() {}
foo.name;   //'foo'

var f = function () {}

//ES5
f.name; //''

//ES6
f.name; //'f'

const bar = function baz() {}
bar.name;   //'baz'
{% endcodeblock %}
Function构造函数返回的函数实例，name属性的值为anonymous。
{% codeblock lang:javascript %}
(new Function).name;    //'anonymous'
{% endcodeblock %}
bind返回的函数，name属性值会加上bound前缀。
{% codeblock lang:javascript %}
function foo() {}
foo.bind({}).name;              //'bound foo'
(function () {}).bind({}).name; //'bound '
{% endcodeblock %}
### 箭头函数
{% codeblock lang:javascript %}
var f = (v) => v;
//等同于
var f = function (v) { return v; }
{% endcodeblock %}
如果箭头函数的代码块多于一条语句，就要使用大括号括起来。
{% codeblock lang:javascript %}
var sum = (num1, num2) => { return num1 + num2; }
{% endcodeblock %}
由于大括号被解释为代码块，所以如果直接返回一个对象，必须在对象外加上括号。
{% codeblock lang:javascript %}
var get = id => ({id : id, name : 'get'});
{% endcodeblock %}
可以与变量解构结合使用
{% codeblock lang:javascript %}
const full = ({first, last}) => first + ',' + last;
//等同于
function full(person) {
    return person.first + ',' + person.last;
}
{% endcodeblock %}
**注意事项**
* 函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。
* 不可当做构造函数，不能使用new命令。
* 不可使用arguments对象，该对象在函数体内不存在，可以使用rest参数代替。
* 不可以使用yield命令，因此不能做Generator函数。

{% codeblock lang:javascript %}
function foo() {
    setTimeout(() => {
        console.log('id:', this.id);
    }, 1000);
}
let id = 21;
foo.call({id : 4}); //id: 4
{% endcodeblock %}
### 嵌套的箭头函数
{% codeblock lang:javascript %}
function insert(value) {
    return { into: function (array) {
        return { after: function (afterValue) {
            array.splice(array.indexOf(afterValue) + 1, 0, value);
            return array;
        }};
    }};
}
insert(2).into([1, 3]).after(1);    //[1, 2, 3]
//箭头函数写法
const insert = (value) => ({into: (array) => ({ after: (afterValue) => {
    array.splice(array.indexOf(afterValue) + 1, 0, value);
    return array;
}})});
{% endcodeblock %}
---
title: 对象的扩展
date: 2018-08-13 20:35:12
tags:
- '学习'
- '整理'
categories:
- 'ECMAScript'
---
### 属性名表达式
JavaScript定义属性有两种方法：
{% codeblock lang:javascript %}
obj.foo = true;
obj['a' + 'bc'] = 123;
{% endcodeblock %}
ES6允许字面量定义对象时使用第二种方法：
{% codeblock lang:javascript %}
let propKey = 'foo';
let obj = {
    [propKey] : true,
    ['a' + 'bc'] : 123,
    ['he' + 'llo']() {
        return 'hi';
    }
}
{% endcodeblock %}
### 方法的name属性
方法的name属性也返回函数名。
{% codeblock lang:javascript %}
const person = {
    sayName() {
        console.log('hello');
    }
}
person.sayName.name;    //'sayName'
{% endcodeblock %}
**如果对象的方法使用了getter和setter，则name的属性不是在该方法上面，而是在该方法属性的描述对象的get和set属性上面，返回值是方法名前面加上get和set**
{% codeblock lang:javascript %}
const obj = {
    get foo() {},
    set foo(x) {}
};
// obj.foo.name;   //TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
descriptor.get.name;    //'get foo'
descriptor.set.name;    //'set foo'
{% endcodeblock %}
如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。
{% codeblock lang:javascript %}
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
    [key1]() {},
    [key2]() {}
};
obj[key1].name; //'[description]'
obj[key2].name; //''
{% endcodeblock %}
### Object.is()
ES5比较两个值是否相等，只有两个相等运算符：==和===，他们都有个缺点，前者会自动转换数据类型，后者NaN不等于自身，以及+0等于-0。
ES6提出了*Same-value-equality*算法来解决这个问题，Object.is()就是部署这个算法的新方法。
不同之处只有两个：
{% codeblock lang:javascript %}
+0 === -0;              //true
NaN === NaN;            //false
Object.is(+0, -0);      //false
Object.is(NaN, NaN);    //true
{% endcodeblock %}
ES5可以用代码部署：
{% codeblock lang:javascript %}
Object.defineProperty(Object, 'is' {
    value : function(x, y) {
        if (x === y) {
            //针对+0不等于-0的情况
            return x !== 0 || 1 / x === 1 / y;
        }
        //针对NaN
        return x !== x && y !== y;
    },
    configurable : true,
    enumerable : false,
    writable : true
});
{% endcodeblock %}
### Object.assign()
Object.assign方法用于将源对象的所有 **可枚举** 属性复制到目标对象。第一个参数是目标对象，后面的参数都是源对象
{% codeblock lang:javascript %}
var target = { a : 1 };
var source1 = { b : 2 };
var source2 = { c : 3 };
Object.assign(target, source1, source2);
target; //{ a : 1, b : 2, c : 3 }
{% endcodeblock %}
如果只有一个参数，Object.assign()会直接返回该参数。
如果参数不是对象，会先转成对象，然后返回，由于undefined和null无法转变，所以如果将他们作为参数，就会报错。但是，如果undefined和null不在首参数，那就不会报错。
其他类型的值（数值、字符串和布尔值）不在首参数也不会报错，但是，除了字符串会以数组形式复制到目标对象，其他值都不会产生效果。
**Object.assign()方法实行的赋值是浅复制，如果源对象的某个属性的值是对象，那么目标对象得到的是这个对象的引用**
{% codeblock lang:javascript %}
var obj1 = { a : { b : 1 } };
var obj2 = Object.assign(obj2, obj1);
obj1.a.b = 2;
obj2.a.b;   //2
{% endcodeblock %}
对于这种嵌套对象，一旦遇到同名属性，处理的方法是替换而不是添加。
{% codeblock lang:javascript %}
var target = { a : { b : 'c', d : 'e' } };
var source = { a : { b : 'hello' } };
Object.assign(target.source);
//target对象的a属性被source对象的a属性整个替换掉了
{% endcodeblock %}
**Object.assign()可以用来处理数组，但是会把数组当成对象来处理。**
{% codeblock lang:javascript %}
Object.assign([1, 2, 3], [4, 5]);   //[4, 5, 3]
{% endcodeblock %}
常见用途：
* 为对象添加属性：
{% codeblock lang:javascript %}
class Point {
    constructor(x, y) {
        Object.apply(this, { x, y });
    }
}
{% endcodeblock %}
* 为对象添加方法：
{% codeblock lang:javascript %}
Object.assign(SomeClass.prototype, {
    someMethod(arg1, arg2) {
        
    },
    anotherMethod() {
        //...
    }
})
//等同于
SomeClass.prototype.someMethod = function (arg1, arg2) {
    //...
};
SomeClass.prototype.anotherMethod = function () {
    //...
}
{% endcodeblock %}
* 克隆对象
{% codeblock lang:javascript %}
//只克隆对象自身值
function clone(origin) {
    Object.assign({}, origin);
}

//保持继承链的方法
function clone(origin) {
    let originProto = Object.getPrototypeOf(origin);
    return Object.assign(Object.create(originProto), origin);
}
{% endcodeblock %}
* 合并多个对象
{% codeblock lang:javascript %}
const merge = (target, ...sources) => Object.assign(target, ...sources);

//合并到一个对象
const merge = (...source) => Object.assign({}, ...source);
{% endcodeblock %}
* 为属性指定默认值
{% codeblock lang:javascript %}
const DEFAULTS = {
    logLevel : 0,
    outputFormat : 'html'
};
function processContent(options) {
    options = Object.assign({}, DEFAULTS, options);
    console.log(options);
    //...
}
{% endcodeblock %}
### 属性的可枚举性
对象的每一个属性都有一描述对象，用于控制该属性的行为，Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
{% codeblock lang:javascript %}
let obj = { foo : 123 };
Object.getOwnPropertyDescriptor(obj, 'foo');
// {
//     value : 123,
//     writable : true,
//     enumerable : true,
//     configurable : false
// }
{% endcodeblock %}
enumerable属性成为可枚举性，如果该属性为false，就表示某些操作会忽略当前属性。
ES5有三个操作会忽略enumerable为false的属性：
* for...in循环：只遍历对象自身和继承的可枚举属性。
* Object.keys()： 返回对象自身的所有可枚举属性的键名。
* JSON.stringify()：只串行化对象自身的可枚举属性。

**ES6规定，所有Class的原型的方法都是不可枚举的**
### 属性的遍历
ES6共有五种方法遍历对象的属性：
* for...in循环：遍历对象自身和继承的可枚举属性（不含Symbol属性）。
* Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。
* Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。
* Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有Symbol属性。
* Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性，不管属性名是Symbol还是字符串，也不管是否可枚举。
以上方法遍历对象属性时都遵守同样的属性遍历次序规则：
* 首先遍历所有属性名为数值的属性，按照数字排序。
* 其次遍历所有属性名为字符串的属性，按照生成时间排序。
* 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。
### __proto__属性
__proto__属性用来读取或设置当前对象的prototype对象。
{% codeblock lang:javascript %}
//ES6写法
var obj = {
    method : function() {}
};
obj.__proto__ = someOtherObj;

//ES5写法
var obj = Object.create(someOtherObj);
obj.method = function() {};
{% endcodeblock %}
在实现上，__proto__调用的是Object.prototype.__proto__，实现如下：
{% codeblock lang:javascript %}
Object.defineProperty(Object.prototype, '__proto__', {
    get() {
        let _thisObj = Object(this);
        return Object.getPrototypeOf(_thisObj);
    },
    set(proto) {
        if (this === undefined || this === null) {
            throw new TypeError();
        }
        if (!isObject(this)) {
            return undefined;
        }
        if (!isObject(proto)) {
            return undefined;
        }
        let status = Reflect.setPrototypeOf(this, proto);
        if (!status) {
            throw new TypeError();
        }
    },
});
function isObject(value) {
    return Object(value) === value;
}
{% endcodeblock %}
如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。
{% codeblock lang:javascript %}
Object.getPrototypeOf({ __proto__ : null });    //null
{% endcodeblock %}
### Object.setPrototypeOf()
Object.setPrototypeOf()用于设置一个对象的prototype对象，返回参数本身。
{% codeblock lang:javascript %}
let proto = {};
let obj = { x : 10 };
Object.setPrototypeOf(obj, proto);
proto.y = 20;
proto.z = 30;
//obj对象可以读取proto对象的属性
obj.y;  //20
obj.z;  //30
{% endcodeblock %}
如果第一个参数不是对象，就会自动转为对象，但是由于返回的还是第一个参数，所以这个操作不会有任何的结果。
**如果第一个参数是undefined或null，则会报错**
### Object.setPrototypeOf()
Object.setPrototypeOf()用于读取一个对象的prototype对象。
如果第一个参数不是对象，则会自动转为对象。
**如果第一个参数是undefined或null，则会报错**
### Object.keys()、Object.values()、Object.entries()
Object.keys()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键名。
Object.values()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值。
Object.entries()返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。
实现Object.entries()：
{% codeblock lang:javascript %}
//Generator函数版本
function* entries(obj) {
    for (let key of Object.keys(obj)) {
        yield [key, obj[key]];
    }
}

//非Generator函数版本
function entries(obj) {
    let arr = [];
    for (let key of Object.keys(obj)) {
        arr.push([key, obj[key]]);
    }
    return arr;
}
{% endcodeblock %}
### 对象的扩展运算符
{% codeblock lang:javascript %}
let {x, y, ...z} = {x : 1, y : 2, a : 3, b : 4};
x;  //1
y;  //2
z;  //{ a : 3, b : 4 }
{% endcodeblock %}
扩展运算符可以用于合并两个对象
{% codeblock lang:javascript %}
let ab = { ...a, ...b };
//等同于
let ab = Object.assign({}, a, b);
{% endcodeblock %}
### Object.getOwnPropertyDescriptors()
ES5的Object.getOwnPropertyDescriptor()方法用来返回某个对象属性的descriptor。
{% codeblock lang:javascript %}
var obj = { p : 'a' };
Object.getOwnPropertyDescriptor(obj, 'p');
// Object {
//     value : 'a',
//     writable : true,
//     enumerable: true,
//     configurable: true
// }
{% endcodeblock %}
ES2017引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承）的descriptor。
{% codeblock lang:javascript %}
const obj = {
    foo : 123,
    get bar() { return this.foo; }
}
Object.getOwnPropertyDescriptors(obj);
// {
//     foo: {
//         value : 123,
//         writable: true,
//         enumerable: true,
//         configurable: true
//     },
//     bar: {
//         get: [Function bar],
//         set: undefined,
//         enumerable: true,
//         configurable: true
//     }
// }
{% endcodeblock %}